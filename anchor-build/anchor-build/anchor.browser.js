// ✅ Custom Anchor browser build for SanctOS
(function() {
  console.log("[SanctOS] ⚙️ Loading custom Anchor browser runtime...");
})();
var anchor = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1) validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset2, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset2 + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset2 + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset2 + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset2, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset2 + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset2 + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset2 + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      var base642 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string2, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string2, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string2, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array3) {
        const length = array3.length < 0 ? 0 : checked(array3.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array3[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array3, byteOffset, length) {
        if (byteOffset < 0 || array3.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array3.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array3);
        } else if (length === void 0) {
          buf = new Uint8Array(array3, byteOffset);
        } else {
          buf = new Uint8Array(array3, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b) return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string2, encoding) {
        if (Buffer2.isBuffer(string2)) {
          return string2.length;
        }
        if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
          return string2.byteLength;
        }
        if (typeof string2 !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
          );
        }
        const len = string2.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0) return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes2(string2).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string2).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes2(string2).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding) encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString2() {
        const length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
        if (this === b) return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str2 = "";
        const max = exports.INSPECT_MAX_BYTES;
        str2 = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max) str2 += " ... ";
        return "<Buffer " + str2 + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir) return -1;
          else byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i;
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found) return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string2, offset2, length) {
        offset2 = Number(offset2) || 0;
        const remaining = buf.length - offset2;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string2.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string2.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed)) return i;
          buf[offset2 + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string2, offset2, length) {
        return blitBuffer(utf8ToBytes2(string2, buf.length - offset2), buf, offset2, length);
      }
      function asciiWrite(buf, string2, offset2, length) {
        return blitBuffer(asciiToBytes(string2), buf, offset2, length);
      }
      function base64Write(buf, string2, offset2, length) {
        return blitBuffer(base64ToBytes(string2), buf, offset2, length);
      }
      function ucs2Write(buf, string2, offset2, length) {
        return blitBuffer(utf16leToBytes(string2, buf.length - offset2), buf, offset2, length);
      }
      Buffer2.prototype.write = function write(string2, offset2, length, encoding) {
        if (offset2 === void 0) {
          encoding = "utf8";
          length = this.length;
          offset2 = 0;
        } else if (length === void 0 && typeof offset2 === "string") {
          encoding = offset2;
          length = this.length;
          offset2 = 0;
        } else if (isFinite(offset2)) {
          offset2 = offset2 >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset2;
        if (length === void 0 || length > remaining) length = remaining;
        if (string2.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string2, offset2, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string2, offset2, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string2, offset2, length);
            case "base64":
              return base64Write(this, string2, offset2, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string2, offset2, length);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base642.fromByteArray(buf);
        } else {
          return base642.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len) end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start) end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset2, ext, length) {
        if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
        if (offset2 + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset2, byteLength2, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset2, byteLength2, this.length);
        let val = this[offset2];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset2 + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset2, byteLength2, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset2, byteLength2, this.length);
        }
        let val = this[offset2 + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset2 + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 1, this.length);
        return this[offset2];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        return this[offset2] | this[offset2 + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        return this[offset2] << 8 | this[offset2 + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const lo = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
        const hi = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
        const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset2, byteLength2, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset2, byteLength2, this.length);
        let val = this[offset2];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset2 + i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset2, byteLength2, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset2, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset2 + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset2 + --i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 1, this.length);
        if (!(this[offset2] & 128)) return this[offset2];
        return (255 - this[offset2] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        const val = this[offset2] | this[offset2 + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        const val = this[offset2 + 1] | this[offset2] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return ieee754.read(this, offset2, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return ieee754.read(this, offset2, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 8, this.length);
        return ieee754.read(this, offset2, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 8, this.length);
        return ieee754.read(this, offset2, false, 52, 8);
      };
      function checkInt(buf, value, offset2, ext, max, min) {
        if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
        if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset2, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset2] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset2 + i] = value / mul & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset2, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset2 + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset2 + i] = value / mul & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 1, 255, 0);
        this[offset2] = value & 255;
        return offset2 + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
        this[offset2] = value & 255;
        this[offset2 + 1] = value >>> 8;
        return offset2 + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
        this[offset2] = value >>> 8;
        this[offset2 + 1] = value & 255;
        return offset2 + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
        this[offset2 + 3] = value >>> 24;
        this[offset2 + 2] = value >>> 16;
        this[offset2 + 1] = value >>> 8;
        this[offset2] = value & 255;
        return offset2 + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
        this[offset2] = value >>> 24;
        this[offset2 + 1] = value >>> 16;
        this[offset2 + 2] = value >>> 8;
        this[offset2 + 3] = value & 255;
        return offset2 + 4;
      };
      function wrtBigUInt64LE(buf, value, offset2, min, max) {
        checkIntBI(value, min, max, buf, offset2, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset2++] = lo;
        lo = lo >> 8;
        buf[offset2++] = lo;
        lo = lo >> 8;
        buf[offset2++] = lo;
        lo = lo >> 8;
        buf[offset2++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset2++] = hi;
        hi = hi >> 8;
        buf[offset2++] = hi;
        hi = hi >> 8;
        buf[offset2++] = hi;
        hi = hi >> 8;
        buf[offset2++] = hi;
        return offset2;
      }
      function wrtBigUInt64BE(buf, value, offset2, min, max) {
        checkIntBI(value, min, max, buf, offset2, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset2 + 7] = lo;
        lo = lo >> 8;
        buf[offset2 + 6] = lo;
        lo = lo >> 8;
        buf[offset2 + 5] = lo;
        lo = lo >> 8;
        buf[offset2 + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset2 + 3] = hi;
        hi = hi >> 8;
        buf[offset2 + 2] = hi;
        hi = hi >> 8;
        buf[offset2 + 1] = hi;
        hi = hi >> 8;
        buf[offset2] = hi;
        return offset2 + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {
        return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {
        return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset2] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset2 + i - 1] !== 0) {
            sub = 1;
          }
          this[offset2 + i] = (value / mul >> 0) - sub & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset2 + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset2 + i + 1] !== 0) {
            sub = 1;
          }
          this[offset2 + i] = (value / mul >> 0) - sub & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset2] = value & 255;
        return offset2 + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
        this[offset2] = value & 255;
        this[offset2 + 1] = value >>> 8;
        return offset2 + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
        this[offset2] = value >>> 8;
        this[offset2 + 1] = value & 255;
        return offset2 + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
        this[offset2] = value & 255;
        this[offset2 + 1] = value >>> 8;
        this[offset2 + 2] = value >>> 16;
        this[offset2 + 3] = value >>> 24;
        return offset2 + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset2] = value >>> 24;
        this[offset2 + 1] = value >>> 16;
        this[offset2 + 2] = value >>> 8;
        this[offset2 + 3] = value & 255;
        return offset2 + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {
        return wrtBigUInt64LE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {
        return wrtBigUInt64BE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset2, ext, max, min) {
        if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
        if (offset2 < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset2, littleEndian, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset2, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset2, littleEndian, 23, 4);
        return offset2 + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
        return writeFloat(this, value, offset2, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
        return writeFloat(this, value, offset2, false, noAssert);
      };
      function writeDouble(buf, value, offset2, littleEndian, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset2, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset2, littleEndian, 52, 8);
        return offset2 + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
        return writeDouble(this, value, offset2, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
        return writeDouble(this, value, offset2, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str2, range, input) {
          let msg = `The value of "${str2}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset2, byteLength2) {
        validateNumber(offset2, "offset");
        if (buf[offset2] === void 0 || buf[offset2 + byteLength2] === void 0) {
          boundsError(offset2, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset2, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset2, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type2) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type2);
          throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type2 || "offset",
          `>= ${type2 ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str2) {
        str2 = str2.split("=")[0];
        str2 = str2.trim().replace(INVALID_BASE64_RE, "");
        if (str2.length < 2) return "";
        while (str2.length % 4 !== 0) {
          str2 = str2 + "=";
        }
        return str2;
      }
      function utf8ToBytes2(string2, units) {
        units = units || Infinity;
        let codePoint;
        const length = string2.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string2.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str2) {
        const byteArray = [];
        for (let i = 0; i < str2.length; ++i) {
          byteArray.push(str2.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str2, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str2.length; ++i) {
          if ((units -= 2) < 0) break;
          c = str2.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str2) {
        return base642.toByteArray(base64clean(str2));
      }
      function blitBuffer(src, dst, offset2, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset2 >= dst.length || i >= src.length) break;
          dst[i + offset2] = src[i];
        }
        return i;
      }
      function isInstance(obj, type2) {
        return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = (function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i162 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i162 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      })();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/@noble/hashes/crypto.js
  var require_crypto = __commonJS({
    "node_modules/@noble/hashes/crypto.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crypto = void 0;
      exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@noble/hashes/utils.js
  var require_utils = __commonJS({
    "node_modules/@noble/hashes/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
      exports.isBytes = isBytes2;
      exports.anumber = anumber;
      exports.abytes = abytes2;
      exports.ahash = ahash;
      exports.aexists = aexists2;
      exports.aoutput = aoutput2;
      exports.u8 = u83;
      exports.u32 = u323;
      exports.clean = clean2;
      exports.createView = createView2;
      exports.rotr = rotr2;
      exports.rotl = rotl;
      exports.byteSwap = byteSwap;
      exports.byteSwap32 = byteSwap32;
      exports.bytesToHex = bytesToHex;
      exports.hexToBytes = hexToBytes;
      exports.asyncLoop = asyncLoop;
      exports.utf8ToBytes = utf8ToBytes2;
      exports.bytesToUtf8 = bytesToUtf8;
      exports.toBytes = toBytes2;
      exports.kdfInputToBytes = kdfInputToBytes;
      exports.concatBytes = concatBytes;
      exports.checkOpts = checkOpts;
      exports.createHasher = createHasher2;
      exports.createOptHasher = createOptHasher;
      exports.createXOFer = createXOFer;
      exports.randomBytes = randomBytes;
      var crypto_1 = require_crypto();
      function isBytes2(a) {
        return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
      }
      function anumber(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error("positive integer expected, got " + n);
      }
      function abytes2(b, ...lengths) {
        if (!isBytes2(b))
          throw new Error("Uint8Array expected");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
      }
      function ahash(h) {
        if (typeof h !== "function" || typeof h.create !== "function")
          throw new Error("Hash should be wrapped by utils.createHasher");
        anumber(h.outputLen);
        anumber(h.blockLen);
      }
      function aexists2(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      function aoutput2(out, instance) {
        abytes2(out);
        const min = instance.outputLen;
        if (out.length < min) {
          throw new Error("digestInto() expects output buffer of length at least " + min);
        }
      }
      function u83(arr) {
        return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      }
      function u323(arr) {
        return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      }
      function clean2(...arrays) {
        for (let i = 0; i < arrays.length; i++) {
          arrays[i].fill(0);
        }
      }
      function createView2(arr) {
        return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      }
      function rotr2(word, shift) {
        return word << 32 - shift | word >>> shift;
      }
      function rotl(word, shift) {
        return word << shift | word >>> 32 - shift >>> 0;
      }
      exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
      function byteSwap(word) {
        return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
      }
      exports.swap8IfBE = exports.isLE ? (n) => n : (n) => byteSwap(n);
      exports.byteSwapIfBE = exports.swap8IfBE;
      function byteSwap32(arr) {
        for (let i = 0; i < arr.length; i++) {
          arr[i] = byteSwap(arr[i]);
        }
        return arr;
      }
      exports.swap32IfBE = exports.isLE ? (u) => u : byteSwap32;
      var hasHexBuiltin = /* @__PURE__ */ (() => (
        // @ts-ignore
        typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
      ))();
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        abytes2(bytes);
        if (hasHexBuiltin)
          return bytes.toHex();
        let hex2 = "";
        for (let i = 0; i < bytes.length; i++) {
          hex2 += hexes[bytes[i]];
        }
        return hex2;
      }
      var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function asciiToBase16(ch) {
        if (ch >= asciis._0 && ch <= asciis._9)
          return ch - asciis._0;
        if (ch >= asciis.A && ch <= asciis.F)
          return ch - (asciis.A - 10);
        if (ch >= asciis.a && ch <= asciis.f)
          return ch - (asciis.a - 10);
        return;
      }
      function hexToBytes(hex2) {
        if (typeof hex2 !== "string")
          throw new Error("hex string expected, got " + typeof hex2);
        if (hasHexBuiltin)
          return Uint8Array.fromHex(hex2);
        const hl = hex2.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("hex string expected, got unpadded hex of length " + hl);
        const array3 = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
          const n1 = asciiToBase16(hex2.charCodeAt(hi));
          const n2 = asciiToBase16(hex2.charCodeAt(hi + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex2[hi] + hex2[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
          }
          array3[ai] = n1 * 16 + n2;
        }
        return array3;
      }
      var nextTick = async () => {
      };
      exports.nextTick = nextTick;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports.nextTick)();
          ts += diff;
        }
      }
      function utf8ToBytes2(str2) {
        if (typeof str2 !== "string")
          throw new Error("string expected");
        return new Uint8Array(new TextEncoder().encode(str2));
      }
      function bytesToUtf8(bytes) {
        return new TextDecoder().decode(bytes);
      }
      function toBytes2(data) {
        if (typeof data === "string")
          data = utf8ToBytes2(data);
        abytes2(data);
        return data;
      }
      function kdfInputToBytes(data) {
        if (typeof data === "string")
          data = utf8ToBytes2(data);
        abytes2(data);
        return data;
      }
      function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          abytes2(a);
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad);
          pad += a.length;
        }
        return res;
      }
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
          throw new Error("options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      var Hash2 = class {
      };
      exports.Hash = Hash2;
      function createHasher2(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      function createOptHasher(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      function createXOFer(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports.wrapConstructor = createHasher2;
      exports.wrapConstructorWithOpts = createOptHasher;
      exports.wrapXOFConstructorWithOpts = createXOFer;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
          return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
    }
  });

  // node_modules/@noble/hashes/_md.js
  var require_md = __commonJS({
    "node_modules/@noble/hashes/_md.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
      exports.setBigUint64 = setBigUint642;
      exports.Chi = Chi2;
      exports.Maj = Maj2;
      var utils_ts_1 = require_utils();
      function setBigUint642(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      function Chi2(a, b, c) {
        return a & b ^ ~a & c;
      }
      function Maj2(a, b, c) {
        return a & b ^ a & c ^ b & c;
      }
      var HashMD2 = class extends utils_ts_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_ts_1.createView)(this.buffer);
        }
        update(data) {
          (0, utils_ts_1.aexists)(this);
          data = (0, utils_ts_1.toBytes)(data);
          (0, utils_ts_1.abytes)(data);
          const { view, buffer, blockLen } = this;
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_ts_1.createView)(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, utils_ts_1.aexists)(this);
          (0, utils_ts_1.aoutput)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          (0, utils_ts_1.clean)(this.buffer.subarray(pos));
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_ts_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.destroyed = destroyed;
          to.finished = finished;
          to.length = length;
          to.pos = pos;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
        clone() {
          return this._cloneInto();
        }
      };
      exports.HashMD = HashMD2;
      exports.SHA256_IV = Uint32Array.from([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      exports.SHA224_IV = Uint32Array.from([
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ]);
      exports.SHA384_IV = Uint32Array.from([
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ]);
      exports.SHA512_IV = Uint32Array.from([
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ]);
    }
  });

  // node_modules/@noble/hashes/_u64.js
  var require_u64 = __commonJS({
    "node_modules/@noble/hashes/_u64.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
      exports.add = add;
      exports.fromBig = fromBig;
      exports.split = split;
      var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      var _32n = /* @__PURE__ */ BigInt(32);
      function fromBig(n, le = false) {
        if (le)
          return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
        return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
      }
      function split(lst, le = false) {
        const len = lst.length;
        let Ah = new Uint32Array(len);
        let Al = new Uint32Array(len);
        for (let i = 0; i < len; i++) {
          const { h, l } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      exports.toBig = toBig;
      var shrSH = (h, _l, s) => h >>> s;
      exports.shrSH = shrSH;
      var shrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports.shrSL = shrSL;
      var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      exports.rotrSH = rotrSH;
      var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports.rotrSL = rotrSL;
      var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      exports.rotrBH = rotrBH;
      var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      exports.rotrBL = rotrBL;
      var rotr32H = (_h, l) => l;
      exports.rotr32H = rotr32H;
      var rotr32L = (h, _l) => h;
      exports.rotr32L = rotr32L;
      var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      exports.rotlSH = rotlSH;
      var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      exports.rotlSL = rotlSL;
      var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      exports.rotlBH = rotlBH;
      var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      exports.rotlBL = rotlBL;
      function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
      }
      var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      exports.add3L = add3L;
      var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      exports.add3H = add3H;
      var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      exports.add4L = add4L;
      var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      exports.add4H = add4H;
      var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      exports.add5L = add5L;
      var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      exports.add5H = add5H;
      var u643 = {
        fromBig,
        split,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      exports.default = u643;
    }
  });

  // node_modules/@noble/hashes/sha2.js
  var require_sha2 = __commonJS({
    "node_modules/@noble/hashes/sha2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
      var _md_ts_1 = require_md();
      var u643 = require_u64();
      var utils_ts_1 = require_utils();
      var SHA256_K2 = /* @__PURE__ */ Uint32Array.from([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      var SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
      var SHA2562 = class extends _md_ts_1.HashMD {
        constructor(outputLen = 32) {
          super(64, outputLen, 8, false);
          this.A = _md_ts_1.SHA256_IV[0] | 0;
          this.B = _md_ts_1.SHA256_IV[1] | 0;
          this.C = _md_ts_1.SHA256_IV[2] | 0;
          this.D = _md_ts_1.SHA256_IV[3] | 0;
          this.E = _md_ts_1.SHA256_IV[4] | 0;
          this.F = _md_ts_1.SHA256_IV[5] | 0;
          this.G = _md_ts_1.SHA256_IV[6] | 0;
          this.H = _md_ts_1.SHA256_IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset2) {
          for (let i = 0; i < 16; i++, offset2 += 4)
            SHA256_W2[i] = view.getUint32(offset2, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W2[i - 15];
            const W2 = SHA256_W2[i - 2];
            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
            const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
            const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          (0, utils_ts_1.clean)(SHA256_W2);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          (0, utils_ts_1.clean)(this.buffer);
        }
      };
      exports.SHA256 = SHA2562;
      var SHA2242 = class extends SHA2562 {
        constructor() {
          super(28);
          this.A = _md_ts_1.SHA224_IV[0] | 0;
          this.B = _md_ts_1.SHA224_IV[1] | 0;
          this.C = _md_ts_1.SHA224_IV[2] | 0;
          this.D = _md_ts_1.SHA224_IV[3] | 0;
          this.E = _md_ts_1.SHA224_IV[4] | 0;
          this.F = _md_ts_1.SHA224_IV[5] | 0;
          this.G = _md_ts_1.SHA224_IV[6] | 0;
          this.H = _md_ts_1.SHA224_IV[7] | 0;
        }
      };
      exports.SHA224 = SHA2242;
      var K512 = /* @__PURE__ */ (() => u643.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n) => BigInt(n))))();
      var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
      var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
      var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
      var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
      var SHA512 = class extends _md_ts_1.HashMD {
        constructor(outputLen = 64) {
          super(128, outputLen, 16, false);
          this.Ah = _md_ts_1.SHA512_IV[0] | 0;
          this.Al = _md_ts_1.SHA512_IV[1] | 0;
          this.Bh = _md_ts_1.SHA512_IV[2] | 0;
          this.Bl = _md_ts_1.SHA512_IV[3] | 0;
          this.Ch = _md_ts_1.SHA512_IV[4] | 0;
          this.Cl = _md_ts_1.SHA512_IV[5] | 0;
          this.Dh = _md_ts_1.SHA512_IV[6] | 0;
          this.Dl = _md_ts_1.SHA512_IV[7] | 0;
          this.Eh = _md_ts_1.SHA512_IV[8] | 0;
          this.El = _md_ts_1.SHA512_IV[9] | 0;
          this.Fh = _md_ts_1.SHA512_IV[10] | 0;
          this.Fl = _md_ts_1.SHA512_IV[11] | 0;
          this.Gh = _md_ts_1.SHA512_IV[12] | 0;
          this.Gl = _md_ts_1.SHA512_IV[13] | 0;
          this.Hh = _md_ts_1.SHA512_IV[14] | 0;
          this.Hl = _md_ts_1.SHA512_IV[15] | 0;
        }
        // prettier-ignore
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset2) {
          for (let i = 0; i < 16; i++, offset2 += 4) {
            SHA512_W_H[i] = view.getUint32(offset2);
            SHA512_W_L[i] = view.getUint32(offset2 += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u643.rotrSH(W15h, W15l, 1) ^ u643.rotrSH(W15h, W15l, 8) ^ u643.shrSH(W15h, W15l, 7);
            const s0l = u643.rotrSL(W15h, W15l, 1) ^ u643.rotrSL(W15h, W15l, 8) ^ u643.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u643.rotrSH(W2h, W2l, 19) ^ u643.rotrBH(W2h, W2l, 61) ^ u643.shrSH(W2h, W2l, 6);
            const s1l = u643.rotrSL(W2h, W2l, 19) ^ u643.rotrBL(W2h, W2l, 61) ^ u643.shrSL(W2h, W2l, 6);
            const SUMl = u643.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u643.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = u643.rotrSH(Eh, El, 14) ^ u643.rotrSH(Eh, El, 18) ^ u643.rotrBH(Eh, El, 41);
            const sigma1l = u643.rotrSL(Eh, El, 14) ^ u643.rotrSL(Eh, El, 18) ^ u643.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = u643.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u643.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            const sigma0h = u643.rotrSH(Ah, Al, 28) ^ u643.rotrBH(Ah, Al, 34) ^ u643.rotrBH(Ah, Al, 39);
            const sigma0l = u643.rotrSL(Ah, Al, 28) ^ u643.rotrBL(Ah, Al, 34) ^ u643.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u643.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u643.add3L(T1l, sigma0l, MAJl);
            Ah = u643.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = u643.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = u643.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = u643.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = u643.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = u643.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = u643.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = u643.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = u643.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
        }
        destroy() {
          (0, utils_ts_1.clean)(this.buffer);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      exports.SHA512 = SHA512;
      var SHA384 = class extends SHA512 {
        constructor() {
          super(48);
          this.Ah = _md_ts_1.SHA384_IV[0] | 0;
          this.Al = _md_ts_1.SHA384_IV[1] | 0;
          this.Bh = _md_ts_1.SHA384_IV[2] | 0;
          this.Bl = _md_ts_1.SHA384_IV[3] | 0;
          this.Ch = _md_ts_1.SHA384_IV[4] | 0;
          this.Cl = _md_ts_1.SHA384_IV[5] | 0;
          this.Dh = _md_ts_1.SHA384_IV[6] | 0;
          this.Dl = _md_ts_1.SHA384_IV[7] | 0;
          this.Eh = _md_ts_1.SHA384_IV[8] | 0;
          this.El = _md_ts_1.SHA384_IV[9] | 0;
          this.Fh = _md_ts_1.SHA384_IV[10] | 0;
          this.Fl = _md_ts_1.SHA384_IV[11] | 0;
          this.Gh = _md_ts_1.SHA384_IV[12] | 0;
          this.Gl = _md_ts_1.SHA384_IV[13] | 0;
          this.Hh = _md_ts_1.SHA384_IV[14] | 0;
          this.Hl = _md_ts_1.SHA384_IV[15] | 0;
        }
      };
      exports.SHA384 = SHA384;
      var T224_IV = /* @__PURE__ */ Uint32Array.from([
        2352822216,
        424955298,
        1944164710,
        2312950998,
        502970286,
        855612546,
        1738396948,
        1479516111,
        258812777,
        2077511080,
        2011393907,
        79989058,
        1067287976,
        1780299464,
        286451373,
        2446758561
      ]);
      var T256_IV = /* @__PURE__ */ Uint32Array.from([
        573645204,
        4230739756,
        2673172387,
        3360449730,
        596883563,
        1867755857,
        2520282905,
        1497426621,
        2519219938,
        2827943907,
        3193839141,
        1401305490,
        721525244,
        746961066,
        246885852,
        2177182882
      ]);
      var SHA512_224 = class extends SHA512 {
        constructor() {
          super(28);
          this.Ah = T224_IV[0] | 0;
          this.Al = T224_IV[1] | 0;
          this.Bh = T224_IV[2] | 0;
          this.Bl = T224_IV[3] | 0;
          this.Ch = T224_IV[4] | 0;
          this.Cl = T224_IV[5] | 0;
          this.Dh = T224_IV[6] | 0;
          this.Dl = T224_IV[7] | 0;
          this.Eh = T224_IV[8] | 0;
          this.El = T224_IV[9] | 0;
          this.Fh = T224_IV[10] | 0;
          this.Fl = T224_IV[11] | 0;
          this.Gh = T224_IV[12] | 0;
          this.Gl = T224_IV[13] | 0;
          this.Hh = T224_IV[14] | 0;
          this.Hl = T224_IV[15] | 0;
        }
      };
      exports.SHA512_224 = SHA512_224;
      var SHA512_256 = class extends SHA512 {
        constructor() {
          super(32);
          this.Ah = T256_IV[0] | 0;
          this.Al = T256_IV[1] | 0;
          this.Bh = T256_IV[2] | 0;
          this.Bl = T256_IV[3] | 0;
          this.Ch = T256_IV[4] | 0;
          this.Cl = T256_IV[5] | 0;
          this.Dh = T256_IV[6] | 0;
          this.Dl = T256_IV[7] | 0;
          this.Eh = T256_IV[8] | 0;
          this.El = T256_IV[9] | 0;
          this.Fh = T256_IV[10] | 0;
          this.Fl = T256_IV[11] | 0;
          this.Gh = T256_IV[12] | 0;
          this.Gl = T256_IV[13] | 0;
          this.Hh = T256_IV[14] | 0;
          this.Hl = T256_IV[15] | 0;
        }
      };
      exports.SHA512_256 = SHA512_256;
      exports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA2562());
      exports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA2242());
      exports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
      exports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
      exports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
      exports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
    }
  });

  // node_modules/@noble/curves/utils.js
  var require_utils2 = __commonJS({
    "node_modules/@noble/curves/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
      exports.abool = abool;
      exports._abool2 = _abool2;
      exports._abytes2 = _abytes2;
      exports.numberToHexUnpadded = numberToHexUnpadded;
      exports.hexToNumber = hexToNumber;
      exports.bytesToNumberBE = bytesToNumberBE;
      exports.bytesToNumberLE = bytesToNumberLE;
      exports.numberToBytesBE = numberToBytesBE;
      exports.numberToBytesLE = numberToBytesLE;
      exports.numberToVarBytesBE = numberToVarBytesBE;
      exports.ensureBytes = ensureBytes;
      exports.equalBytes = equalBytes;
      exports.copyBytes = copyBytes;
      exports.asciiToBytes = asciiToBytes;
      exports.inRange = inRange;
      exports.aInRange = aInRange;
      exports.bitLen = bitLen;
      exports.bitGet = bitGet;
      exports.bitSet = bitSet;
      exports.createHmacDrbg = createHmacDrbg;
      exports.validateObject = validateObject;
      exports.isHash = isHash;
      exports._validateObject = _validateObject;
      exports.memoized = memoized;
      var utils_js_1 = require_utils();
      var utils_js_2 = require_utils();
      Object.defineProperty(exports, "abytes", { enumerable: true, get: function() {
        return utils_js_2.abytes;
      } });
      Object.defineProperty(exports, "anumber", { enumerable: true, get: function() {
        return utils_js_2.anumber;
      } });
      Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
        return utils_js_2.bytesToHex;
      } });
      Object.defineProperty(exports, "bytesToUtf8", { enumerable: true, get: function() {
        return utils_js_2.bytesToUtf8;
      } });
      Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
        return utils_js_2.concatBytes;
      } });
      Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
        return utils_js_2.hexToBytes;
      } });
      Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
        return utils_js_2.isBytes;
      } });
      Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
        return utils_js_2.randomBytes;
      } });
      Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
        return utils_js_2.utf8ToBytes;
      } });
      var _0n = /* @__PURE__ */ BigInt(0);
      var _1n = /* @__PURE__ */ BigInt(1);
      function abool(title, value) {
        if (typeof value !== "boolean")
          throw new Error(title + " boolean expected, got " + value);
      }
      function _abool2(value, title = "") {
        if (typeof value !== "boolean") {
          const prefix = title && `"${title}"`;
          throw new Error(prefix + "expected boolean, got type=" + typeof value);
        }
        return value;
      }
      function _abytes2(value, length, title = "") {
        const bytes = (0, utils_js_1.isBytes)(value);
        const len = value?.length;
        const needsLen = length !== void 0;
        if (!bytes || needsLen && len !== length) {
          const prefix = title && `"${title}" `;
          const ofLen = needsLen ? ` of length ${length}` : "";
          const got = bytes ? `length=${len}` : `type=${typeof value}`;
          throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
        }
        return value;
      }
      function numberToHexUnpadded(num) {
        const hex2 = num.toString(16);
        return hex2.length & 1 ? "0" + hex2 : hex2;
      }
      function hexToNumber(hex2) {
        if (typeof hex2 !== "string")
          throw new Error("hex string expected, got " + typeof hex2);
        return hex2 === "" ? _0n : BigInt("0x" + hex2);
      }
      function bytesToNumberBE(bytes) {
        return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
      }
      function bytesToNumberLE(bytes) {
        (0, utils_js_1.abytes)(bytes);
        return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
      }
      function numberToBytesBE(n, len) {
        return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, "0"));
      }
      function numberToBytesLE(n, len) {
        return numberToBytesBE(n, len).reverse();
      }
      function numberToVarBytesBE(n) {
        return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
      }
      function ensureBytes(title, hex2, expectedLength) {
        let res;
        if (typeof hex2 === "string") {
          try {
            res = (0, utils_js_1.hexToBytes)(hex2);
          } catch (e) {
            throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
          }
        } else if ((0, utils_js_1.isBytes)(hex2)) {
          res = Uint8Array.from(hex2);
        } else {
          throw new Error(title + " must be hex string or Uint8Array");
        }
        const len = res.length;
        if (typeof expectedLength === "number" && len !== expectedLength)
          throw new Error(title + " of length " + expectedLength + " expected, got " + len);
        return res;
      }
      function equalBytes(a, b) {
        if (a.length !== b.length)
          return false;
        let diff = 0;
        for (let i = 0; i < a.length; i++)
          diff |= a[i] ^ b[i];
        return diff === 0;
      }
      function copyBytes(bytes) {
        return Uint8Array.from(bytes);
      }
      function asciiToBytes(ascii) {
        return Uint8Array.from(ascii, (c, i) => {
          const charCode = c.charCodeAt(0);
          if (c.length !== 1 || charCode > 127) {
            throw new Error(`string contains non-ASCII character "${ascii[i]}" with code ${charCode} at position ${i}`);
          }
          return charCode;
        });
      }
      var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
      function inRange(n, min, max) {
        return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
      }
      function aInRange(title, n, min, max) {
        if (!inRange(n, min, max))
          throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
      }
      function bitLen(n) {
        let len;
        for (len = 0; n > _0n; n >>= _1n, len += 1)
          ;
        return len;
      }
      function bitGet(n, pos) {
        return n >> BigInt(pos) & _1n;
      }
      function bitSet(n, pos, value) {
        return n | (value ? _1n : _0n) << BigInt(pos);
      }
      var bitMask = (n) => (_1n << BigInt(n)) - _1n;
      exports.bitMask = bitMask;
      function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== "number" || hashLen < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        if (typeof hmacFn !== "function")
          throw new Error("hmacFn must be a function");
        const u8n = (len) => new Uint8Array(len);
        const u8of = (byte) => Uint8Array.of(byte);
        let v = u8n(hashLen);
        let k = u8n(hashLen);
        let i = 0;
        const reset = () => {
          v.fill(1);
          k.fill(0);
          i = 0;
        };
        const h = (...b) => hmacFn(k, v, ...b);
        const reseed = (seed2 = u8n(0)) => {
          k = h(u8of(0), seed2);
          v = h();
          if (seed2.length === 0)
            return;
          k = h(u8of(1), seed2);
          v = h();
        };
        const gen = () => {
          if (i++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
          let len = 0;
          const out = [];
          while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
          }
          return (0, utils_js_1.concatBytes)(...out);
        };
        const genUntil = (seed2, pred) => {
          reset();
          reseed(seed2);
          let res = void 0;
          while (!(res = pred(gen())))
            reseed();
          reset();
          return res;
        };
        return genUntil;
      }
      var validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        stringOrUint8Array: (val) => typeof val === "string" || (0, utils_js_1.isBytes)(val),
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
      function validateObject(object, validators, optValidators = {}) {
        const checkField = (fieldName, type2, isOptional) => {
          const checkVal = validatorFns[type2];
          if (typeof checkVal !== "function")
            throw new Error("invalid validator function");
          const val = object[fieldName];
          if (isOptional && val === void 0)
            return;
          if (!checkVal(val, object)) {
            throw new Error("param " + String(fieldName) + " is invalid. Expected " + type2 + ", got " + val);
          }
        };
        for (const [fieldName, type2] of Object.entries(validators))
          checkField(fieldName, type2, false);
        for (const [fieldName, type2] of Object.entries(optValidators))
          checkField(fieldName, type2, true);
        return object;
      }
      function isHash(val) {
        return typeof val === "function" && Number.isSafeInteger(val.outputLen);
      }
      function _validateObject(object, fields, optFields = {}) {
        if (!object || typeof object !== "object")
          throw new Error("expected valid options object");
        function checkField(fieldName, expectedType, isOpt) {
          const val = object[fieldName];
          if (isOpt && val === void 0)
            return;
          const current = typeof val;
          if (current !== expectedType || val === null)
            throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
        }
        Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
        Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
      }
      var notImplemented = () => {
        throw new Error("not implemented");
      };
      exports.notImplemented = notImplemented;
      function memoized(fn) {
        const map = /* @__PURE__ */ new WeakMap();
        return (arg, ...args) => {
          const val = map.get(arg);
          if (val !== void 0)
            return val;
          const computed = fn(arg, ...args);
          map.set(arg, computed);
          return computed;
        };
      }
    }
  });

  // node_modules/@noble/curves/abstract/modular.js
  var require_modular = __commonJS({
    "node_modules/@noble/curves/abstract/modular.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isNegativeLE = void 0;
      exports.mod = mod;
      exports.pow = pow;
      exports.pow2 = pow2;
      exports.invert = invert;
      exports.tonelliShanks = tonelliShanks;
      exports.FpSqrt = FpSqrt;
      exports.validateField = validateField;
      exports.FpPow = FpPow;
      exports.FpInvertBatch = FpInvertBatch;
      exports.FpDiv = FpDiv;
      exports.FpLegendre = FpLegendre;
      exports.FpIsSquare = FpIsSquare;
      exports.nLength = nLength;
      exports.Field = Field;
      exports.FpSqrtOdd = FpSqrtOdd;
      exports.FpSqrtEven = FpSqrtEven;
      exports.hashToPrivateScalar = hashToPrivateScalar;
      exports.getFieldBytesLength = getFieldBytesLength;
      exports.getMinHashLength = getMinHashLength;
      exports.mapHashToField = mapHashToField;
      var utils_ts_1 = require_utils2();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = /* @__PURE__ */ BigInt(2);
      var _3n = /* @__PURE__ */ BigInt(3);
      var _4n = /* @__PURE__ */ BigInt(4);
      var _5n = /* @__PURE__ */ BigInt(5);
      var _7n = /* @__PURE__ */ BigInt(7);
      var _8n = /* @__PURE__ */ BigInt(8);
      var _9n = /* @__PURE__ */ BigInt(9);
      var _16n = /* @__PURE__ */ BigInt(16);
      function mod(a, b) {
        const result = a % b;
        return result >= _0n ? result : b + result;
      }
      function pow(num, power, modulo) {
        return FpPow(Field(modulo), num, power);
      }
      function pow2(x, power, modulo) {
        let res = x;
        while (power-- > _0n) {
          res *= res;
          res %= modulo;
        }
        return res;
      }
      function invert(number2, modulo) {
        if (number2 === _0n)
          throw new Error("invert: expected non-zero number");
        if (modulo <= _0n)
          throw new Error("invert: expected positive modulus, got " + modulo);
        let a = mod(number2, modulo);
        let b = modulo;
        let x = _0n, y = _1n, u = _1n, v = _0n;
        while (a !== _0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n)
          throw new Error("invert: does not exist");
        return mod(x, modulo);
      }
      function assertIsSquare(Fp, root, n) {
        if (!Fp.eql(Fp.sqr(root), n))
          throw new Error("Cannot find square root");
      }
      function sqrt3mod4(Fp, n) {
        const p1div4 = (Fp.ORDER + _1n) / _4n;
        const root = Fp.pow(n, p1div4);
        assertIsSquare(Fp, root, n);
        return root;
      }
      function sqrt5mod8(Fp, n) {
        const p5div8 = (Fp.ORDER - _5n) / _8n;
        const n2 = Fp.mul(n, _2n);
        const v = Fp.pow(n2, p5div8);
        const nv = Fp.mul(n, v);
        const i = Fp.mul(Fp.mul(nv, _2n), v);
        const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
        assertIsSquare(Fp, root, n);
        return root;
      }
      function sqrt9mod16(P) {
        const Fp_ = Field(P);
        const tn = tonelliShanks(P);
        const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
        const c2 = tn(Fp_, c1);
        const c3 = tn(Fp_, Fp_.neg(c1));
        const c4 = (P + _7n) / _16n;
        return (Fp, n) => {
          let tv1 = Fp.pow(n, c4);
          let tv2 = Fp.mul(tv1, c1);
          const tv3 = Fp.mul(tv1, c2);
          const tv4 = Fp.mul(tv1, c3);
          const e1 = Fp.eql(Fp.sqr(tv2), n);
          const e2 = Fp.eql(Fp.sqr(tv3), n);
          tv1 = Fp.cmov(tv1, tv2, e1);
          tv2 = Fp.cmov(tv4, tv3, e2);
          const e3 = Fp.eql(Fp.sqr(tv2), n);
          const root = Fp.cmov(tv1, tv2, e3);
          assertIsSquare(Fp, root, n);
          return root;
        };
      }
      function tonelliShanks(P) {
        if (P < _3n)
          throw new Error("sqrt is not defined for small field");
        let Q = P - _1n;
        let S = 0;
        while (Q % _2n === _0n) {
          Q /= _2n;
          S++;
        }
        let Z = _2n;
        const _Fp = Field(P);
        while (FpLegendre(_Fp, Z) === 1) {
          if (Z++ > 1e3)
            throw new Error("Cannot find square root: probably non-prime P");
        }
        if (S === 1)
          return sqrt3mod4;
        let cc = _Fp.pow(Z, Q);
        const Q1div2 = (Q + _1n) / _2n;
        return function tonelliSlow(Fp, n) {
          if (Fp.is0(n))
            return n;
          if (FpLegendre(Fp, n) !== 1)
            throw new Error("Cannot find square root");
          let M = S;
          let c = Fp.mul(Fp.ONE, cc);
          let t = Fp.pow(n, Q);
          let R = Fp.pow(n, Q1div2);
          while (!Fp.eql(t, Fp.ONE)) {
            if (Fp.is0(t))
              return Fp.ZERO;
            let i = 1;
            let t_tmp = Fp.sqr(t);
            while (!Fp.eql(t_tmp, Fp.ONE)) {
              i++;
              t_tmp = Fp.sqr(t_tmp);
              if (i === M)
                throw new Error("Cannot find square root");
            }
            const exponent = _1n << BigInt(M - i - 1);
            const b = Fp.pow(c, exponent);
            M = i;
            c = Fp.sqr(b);
            t = Fp.mul(t, c);
            R = Fp.mul(R, b);
          }
          return R;
        };
      }
      function FpSqrt(P) {
        if (P % _4n === _3n)
          return sqrt3mod4;
        if (P % _8n === _5n)
          return sqrt5mod8;
        if (P % _16n === _9n)
          return sqrt9mod16(P);
        return tonelliShanks(P);
      }
      var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
      exports.isNegativeLE = isNegativeLE;
      var FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
      function validateField(field) {
        const initial = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "number",
          BITS: "number"
        };
        const opts = FIELD_FIELDS.reduce((map, val) => {
          map[val] = "function";
          return map;
        }, initial);
        (0, utils_ts_1._validateObject)(field, opts);
        return field;
      }
      function FpPow(Fp, num, power) {
        if (power < _0n)
          throw new Error("invalid exponent, negatives unsupported");
        if (power === _0n)
          return Fp.ONE;
        if (power === _1n)
          return num;
        let p = Fp.ONE;
        let d = num;
        while (power > _0n) {
          if (power & _1n)
            p = Fp.mul(p, d);
          d = Fp.sqr(d);
          power >>= _1n;
        }
        return p;
      }
      function FpInvertBatch(Fp, nums, passZero = false) {
        const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
        const multipliedAcc = nums.reduce((acc, num, i) => {
          if (Fp.is0(num))
            return acc;
          inverted[i] = acc;
          return Fp.mul(acc, num);
        }, Fp.ONE);
        const invertedAcc = Fp.inv(multipliedAcc);
        nums.reduceRight((acc, num, i) => {
          if (Fp.is0(num))
            return acc;
          inverted[i] = Fp.mul(acc, inverted[i]);
          return Fp.mul(acc, num);
        }, invertedAcc);
        return inverted;
      }
      function FpDiv(Fp, lhs, rhs) {
        return Fp.mul(lhs, typeof rhs === "bigint" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
      }
      function FpLegendre(Fp, n) {
        const p1mod2 = (Fp.ORDER - _1n) / _2n;
        const powered = Fp.pow(n, p1mod2);
        const yes = Fp.eql(powered, Fp.ONE);
        const zero2 = Fp.eql(powered, Fp.ZERO);
        const no = Fp.eql(powered, Fp.neg(Fp.ONE));
        if (!yes && !zero2 && !no)
          throw new Error("invalid Legendre symbol result");
        return yes ? 1 : zero2 ? 0 : -1;
      }
      function FpIsSquare(Fp, n) {
        const l = FpLegendre(Fp, n);
        return l === 1;
      }
      function nLength(n, nBitLength) {
        if (nBitLength !== void 0)
          (0, utils_ts_1.anumber)(nBitLength);
        const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
        const nByteLength = Math.ceil(_nBitLength / 8);
        return { nBitLength: _nBitLength, nByteLength };
      }
      function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
        if (ORDER <= _0n)
          throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
        let _nbitLength = void 0;
        let _sqrt = void 0;
        let modFromBytes = false;
        let allowedLengths = void 0;
        if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
          if (opts.sqrt || isLE)
            throw new Error("cannot specify opts in two arguments");
          const _opts = bitLenOrOpts;
          if (_opts.BITS)
            _nbitLength = _opts.BITS;
          if (_opts.sqrt)
            _sqrt = _opts.sqrt;
          if (typeof _opts.isLE === "boolean")
            isLE = _opts.isLE;
          if (typeof _opts.modFromBytes === "boolean")
            modFromBytes = _opts.modFromBytes;
          allowedLengths = _opts.allowedLengths;
        } else {
          if (typeof bitLenOrOpts === "number")
            _nbitLength = bitLenOrOpts;
          if (opts.sqrt)
            _sqrt = opts.sqrt;
        }
        const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
        if (BYTES > 2048)
          throw new Error("invalid field: expected ORDER of <= 2048 bytes");
        let sqrtP;
        const f2 = Object.freeze({
          ORDER,
          isLE,
          BITS,
          BYTES,
          MASK: (0, utils_ts_1.bitMask)(BITS),
          ZERO: _0n,
          ONE: _1n,
          allowedLengths,
          create: (num) => mod(num, ORDER),
          isValid: (num) => {
            if (typeof num !== "bigint")
              throw new Error("invalid field element: expected bigint, got " + typeof num);
            return _0n <= num && num < ORDER;
          },
          is0: (num) => num === _0n,
          // is valid and invertible
          isValidNot0: (num) => !f2.is0(num) && f2.isValid(num),
          isOdd: (num) => (num & _1n) === _1n,
          neg: (num) => mod(-num, ORDER),
          eql: (lhs, rhs) => lhs === rhs,
          sqr: (num) => mod(num * num, ORDER),
          add: (lhs, rhs) => mod(lhs + rhs, ORDER),
          sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
          mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
          pow: (num, power) => FpPow(f2, num, power),
          div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
          // Same as above, but doesn't normalize
          sqrN: (num) => num * num,
          addN: (lhs, rhs) => lhs + rhs,
          subN: (lhs, rhs) => lhs - rhs,
          mulN: (lhs, rhs) => lhs * rhs,
          inv: (num) => invert(num, ORDER),
          sqrt: _sqrt || ((n) => {
            if (!sqrtP)
              sqrtP = FpSqrt(ORDER);
            return sqrtP(f2, n);
          }),
          toBytes: (num) => isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES),
          fromBytes: (bytes, skipValidation = true) => {
            if (allowedLengths) {
              if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
                throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
              }
              const padded = new Uint8Array(BYTES);
              padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
              bytes = padded;
            }
            if (bytes.length !== BYTES)
              throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
            let scalar = isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
            if (modFromBytes)
              scalar = mod(scalar, ORDER);
            if (!skipValidation) {
              if (!f2.isValid(scalar))
                throw new Error("invalid field element: outside of range 0..ORDER");
            }
            return scalar;
          },
          // TODO: we don't need it here, move out to separate fn
          invertBatch: (lst) => FpInvertBatch(f2, lst),
          // We can't move this out because Fp6, Fp12 implement it
          // and it's unclear what to return in there.
          cmov: (a, b, c) => c ? b : a
        });
        return Object.freeze(f2);
      }
      function FpSqrtOdd(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error("Field doesn't have isOdd");
        const root = Fp.sqrt(elm);
        return Fp.isOdd(root) ? root : Fp.neg(root);
      }
      function FpSqrtEven(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error("Field doesn't have isOdd");
        const root = Fp.sqrt(elm);
        return Fp.isOdd(root) ? Fp.neg(root) : root;
      }
      function hashToPrivateScalar(hash2, groupOrder, isLE = false) {
        hash2 = (0, utils_ts_1.ensureBytes)("privateHash", hash2);
        const hashLen = hash2.length;
        const minLen = nLength(groupOrder).nByteLength + 8;
        if (minLen < 24 || hashLen < minLen || hashLen > 1024)
          throw new Error("hashToPrivateScalar: expected " + minLen + "-1024 bytes of input, got " + hashLen);
        const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash2) : (0, utils_ts_1.bytesToNumberBE)(hash2);
        return mod(num, groupOrder - _1n) + _1n;
      }
      function getFieldBytesLength(fieldOrder) {
        if (typeof fieldOrder !== "bigint")
          throw new Error("field order must be bigint");
        const bitLength = fieldOrder.toString(2).length;
        return Math.ceil(bitLength / 8);
      }
      function getMinHashLength(fieldOrder) {
        const length = getFieldBytesLength(fieldOrder);
        return length + Math.ceil(length / 2);
      }
      function mapHashToField(key, fieldOrder, isLE = false) {
        const len = key.length;
        const fieldLen = getFieldBytesLength(fieldOrder);
        const minLen = getMinHashLength(fieldOrder);
        if (len < 16 || len < minLen || len > 1024)
          throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
        const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
        const reduced = mod(num, fieldOrder - _1n) + _1n;
        return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
      }
    }
  });

  // node_modules/@noble/curves/abstract/curve.js
  var require_curve = __commonJS({
    "node_modules/@noble/curves/abstract/curve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.wNAF = void 0;
      exports.negateCt = negateCt;
      exports.normalizeZ = normalizeZ;
      exports.mulEndoUnsafe = mulEndoUnsafe;
      exports.pippenger = pippenger;
      exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
      exports.validateBasic = validateBasic;
      exports._createCurveFields = _createCurveFields;
      var utils_ts_1 = require_utils2();
      var modular_ts_1 = require_modular();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function negateCt(condition, item) {
        const neg = item.negate();
        return condition ? neg : item;
      }
      function normalizeZ(c, points) {
        const invertedZs = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map((p) => p.Z));
        return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
      }
      function validateW(W, bits) {
        if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
          throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
      }
      function calcWOpts(W, scalarBits) {
        validateW(W, scalarBits);
        const windows = Math.ceil(scalarBits / W) + 1;
        const windowSize = 2 ** (W - 1);
        const maxNumber = 2 ** W;
        const mask2 = (0, utils_ts_1.bitMask)(W);
        const shiftBy = BigInt(W);
        return { windows, windowSize, mask: mask2, maxNumber, shiftBy };
      }
      function calcOffsets(n, window2, wOpts) {
        const { windowSize, mask: mask2, maxNumber, shiftBy } = wOpts;
        let wbits = Number(n & mask2);
        let nextN = n >> shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          nextN += _1n;
        }
        const offsetStart = window2 * windowSize;
        const offset2 = offsetStart + Math.abs(wbits) - 1;
        const isZero = wbits === 0;
        const isNeg = wbits < 0;
        const isNegF = window2 % 2 !== 0;
        const offsetF = offsetStart;
        return { nextN, offset: offset2, isZero, isNeg, isNegF, offsetF };
      }
      function validateMSMPoints(points, c) {
        if (!Array.isArray(points))
          throw new Error("array expected");
        points.forEach((p, i) => {
          if (!(p instanceof c))
            throw new Error("invalid point at index " + i);
        });
      }
      function validateMSMScalars(scalars, field) {
        if (!Array.isArray(scalars))
          throw new Error("array of scalars expected");
        scalars.forEach((s, i) => {
          if (!field.isValid(s))
            throw new Error("invalid scalar at index " + i);
        });
      }
      var pointPrecomputes = /* @__PURE__ */ new WeakMap();
      var pointWindowSizes = /* @__PURE__ */ new WeakMap();
      function getW(P) {
        return pointWindowSizes.get(P) || 1;
      }
      function assert0(n) {
        if (n !== _0n)
          throw new Error("invalid wNAF");
      }
      var wNAF = class {
        // Parametrized with a given Point class (not individual point)
        constructor(Point, bits) {
          this.BASE = Point.BASE;
          this.ZERO = Point.ZERO;
          this.Fn = Point.Fn;
          this.bits = bits;
        }
        // non-const time multiplication ladder
        _unsafeLadder(elm, n, p = this.ZERO) {
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        }
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @param point Point instance
         * @param W window size
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(point, W) {
          const { windows, windowSize } = calcWOpts(W, this.bits);
          const points = [];
          let p = point;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        }
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * More compact implementation:
         * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          if (!this.Fn.isValid(n))
            throw new Error("invalid scalar");
          let p = this.ZERO;
          let f2 = this.BASE;
          const wo = calcWOpts(W, this.bits);
          for (let window2 = 0; window2 < wo.windows; window2++) {
            const { nextN, offset: offset2, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
            n = nextN;
            if (isZero) {
              f2 = f2.add(negateCt(isNegF, precomputes[offsetF]));
            } else {
              p = p.add(negateCt(isNeg, precomputes[offset2]));
            }
          }
          assert0(n);
          return { p, f: f2 };
        }
        /**
         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
         * @param acc accumulator point to add result of multiplication
         * @returns point
         */
        wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
          const wo = calcWOpts(W, this.bits);
          for (let window2 = 0; window2 < wo.windows; window2++) {
            if (n === _0n)
              break;
            const { nextN, offset: offset2, isZero, isNeg } = calcOffsets(n, window2, wo);
            n = nextN;
            if (isZero) {
              continue;
            } else {
              const item = precomputes[offset2];
              acc = acc.add(isNeg ? item.negate() : item);
            }
          }
          assert0(n);
          return acc;
        }
        getPrecomputes(W, point, transform) {
          let comp = pointPrecomputes.get(point);
          if (!comp) {
            comp = this.precomputeWindow(point, W);
            if (W !== 1) {
              if (typeof transform === "function")
                comp = transform(comp);
              pointPrecomputes.set(point, comp);
            }
          }
          return comp;
        }
        cached(point, scalar, transform) {
          const W = getW(point);
          return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
        }
        unsafe(point, scalar, transform, prev) {
          const W = getW(point);
          if (W === 1)
            return this._unsafeLadder(point, scalar, prev);
          return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
        }
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        createCache(P, W) {
          validateW(W, this.bits);
          pointWindowSizes.set(P, W);
          pointPrecomputes.delete(P);
        }
        hasCache(elm) {
          return getW(elm) !== 1;
        }
      };
      exports.wNAF = wNAF;
      function mulEndoUnsafe(Point, point, k1, k2) {
        let acc = point;
        let p1 = Point.ZERO;
        let p2 = Point.ZERO;
        while (k1 > _0n || k2 > _0n) {
          if (k1 & _1n)
            p1 = p1.add(acc);
          if (k2 & _1n)
            p2 = p2.add(acc);
          acc = acc.double();
          k1 >>= _1n;
          k2 >>= _1n;
        }
        return { p1, p2 };
      }
      function pippenger(c, fieldN, points, scalars) {
        validateMSMPoints(points, c);
        validateMSMScalars(scalars, fieldN);
        const plength = points.length;
        const slength = scalars.length;
        if (plength !== slength)
          throw new Error("arrays of points and scalars must have equal length");
        const zero2 = c.ZERO;
        const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
        let windowSize = 1;
        if (wbits > 12)
          windowSize = wbits - 3;
        else if (wbits > 4)
          windowSize = wbits - 2;
        else if (wbits > 0)
          windowSize = 2;
        const MASK = (0, utils_ts_1.bitMask)(windowSize);
        const buckets = new Array(Number(MASK) + 1).fill(zero2);
        const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
        let sum = zero2;
        for (let i = lastBits; i >= 0; i -= windowSize) {
          buckets.fill(zero2);
          for (let j = 0; j < slength; j++) {
            const scalar = scalars[j];
            const wbits2 = Number(scalar >> BigInt(i) & MASK);
            buckets[wbits2] = buckets[wbits2].add(points[j]);
          }
          let resI = zero2;
          for (let j = buckets.length - 1, sumI = zero2; j > 0; j--) {
            sumI = sumI.add(buckets[j]);
            resI = resI.add(sumI);
          }
          sum = sum.add(resI);
          if (i !== 0)
            for (let j = 0; j < windowSize; j++)
              sum = sum.double();
        }
        return sum;
      }
      function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
        validateW(windowSize, fieldN.BITS);
        validateMSMPoints(points, c);
        const zero2 = c.ZERO;
        const tableSize = 2 ** windowSize - 1;
        const chunks2 = Math.ceil(fieldN.BITS / windowSize);
        const MASK = (0, utils_ts_1.bitMask)(windowSize);
        const tables = points.map((p) => {
          const res = [];
          for (let i = 0, acc = p; i < tableSize; i++) {
            res.push(acc);
            acc = acc.add(p);
          }
          return res;
        });
        return (scalars) => {
          validateMSMScalars(scalars, fieldN);
          if (scalars.length > points.length)
            throw new Error("array of scalars must be smaller than array of points");
          let res = zero2;
          for (let i = 0; i < chunks2; i++) {
            if (res !== zero2)
              for (let j = 0; j < windowSize; j++)
                res = res.double();
            const shiftBy = BigInt(chunks2 * windowSize - (i + 1) * windowSize);
            for (let j = 0; j < scalars.length; j++) {
              const n = scalars[j];
              const curr = Number(n >> shiftBy & MASK);
              if (!curr)
                continue;
              res = res.add(tables[j][curr - 1]);
            }
          }
          return res;
        };
      }
      function validateBasic(curve) {
        (0, modular_ts_1.validateField)(curve.Fp);
        (0, utils_ts_1.validateObject)(curve, {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field"
        }, {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger"
        });
        return Object.freeze({
          ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
          ...curve,
          ...{ p: curve.Fp.ORDER }
        });
      }
      function createField(order, field, isLE) {
        if (field) {
          if (field.ORDER !== order)
            throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
          (0, modular_ts_1.validateField)(field);
          return field;
        } else {
          return (0, modular_ts_1.Field)(order, { isLE });
        }
      }
      function _createCurveFields(type2, CURVE, curveOpts = {}, FpFnLE) {
        if (FpFnLE === void 0)
          FpFnLE = type2 === "edwards";
        if (!CURVE || typeof CURVE !== "object")
          throw new Error(`expected valid ${type2} CURVE object`);
        for (const p of ["p", "n", "h"]) {
          const val = CURVE[p];
          if (!(typeof val === "bigint" && val > _0n))
            throw new Error(`CURVE.${p} must be positive bigint`);
        }
        const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
        const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
        const _b = type2 === "weierstrass" ? "b" : "d";
        const params = ["Gx", "Gy", "a", _b];
        for (const p of params) {
          if (!Fp.isValid(CURVE[p]))
            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
        }
        CURVE = Object.freeze(Object.assign({}, CURVE));
        return { CURVE, Fp, Fn };
      }
    }
  });

  // node_modules/@noble/curves/abstract/edwards.js
  var require_edwards = __commonJS({
    "node_modules/@noble/curves/abstract/edwards.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PrimeEdwardsPoint = void 0;
      exports.edwards = edwards;
      exports.eddsa = eddsa;
      exports.twistedEdwards = twistedEdwards;
      var utils_ts_1 = require_utils2();
      var curve_ts_1 = require_curve();
      var modular_ts_1 = require_modular();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _8n = BigInt(8);
      function isEdValidXY(Fp, CURVE, x, y) {
        const x2 = Fp.sqr(x);
        const y2 = Fp.sqr(y);
        const left = Fp.add(Fp.mul(CURVE.a, x2), y2);
        const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
        return Fp.eql(left, right);
      }
      function edwards(params, extraOpts = {}) {
        const validated = (0, curve_ts_1._createCurveFields)("edwards", params, extraOpts, extraOpts.FpFnLE);
        const { Fp, Fn } = validated;
        let CURVE = validated.CURVE;
        const { h: cofactor } = CURVE;
        (0, utils_ts_1._validateObject)(extraOpts, {}, { uvRatio: "function" });
        const MASK = _2n << BigInt(Fn.BYTES * 8) - _1n;
        const modP = (n) => Fp.create(n);
        const uvRatio = extraOpts.uvRatio || ((u, v) => {
          try {
            return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };
          } catch (e) {
            return { isValid: false, value: _0n };
          }
        });
        if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))
          throw new Error("bad curve params: generator point");
        function acoord(title, n, banZero = false) {
          const min = banZero ? _1n : _0n;
          (0, utils_ts_1.aInRange)("coordinate " + title, n, min, MASK);
          return n;
        }
        function aextpoint(other) {
          if (!(other instanceof Point))
            throw new Error("ExtendedPoint expected");
        }
        const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
          const { X, Y, Z } = p;
          const is0 = p.is0();
          if (iz == null)
            iz = is0 ? _8n : Fp.inv(Z);
          const x = modP(X * iz);
          const y = modP(Y * iz);
          const zz = Fp.mul(Z, iz);
          if (is0)
            return { x: _0n, y: _1n };
          if (zz !== _1n)
            throw new Error("invZ was invalid");
          return { x, y };
        });
        const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
          const { a, d } = CURVE;
          if (p.is0())
            throw new Error("bad point: ZERO");
          const { X, Y, Z, T } = p;
          const X2 = modP(X * X);
          const Y2 = modP(Y * Y);
          const Z2 = modP(Z * Z);
          const Z4 = modP(Z2 * Z2);
          const aX2 = modP(X2 * a);
          const left = modP(Z2 * modP(aX2 + Y2));
          const right = modP(Z4 + modP(d * modP(X2 * Y2)));
          if (left !== right)
            throw new Error("bad point: equation left != right (1)");
          const XY = modP(X * Y);
          const ZT = modP(Z * T);
          if (XY !== ZT)
            throw new Error("bad point: equation left != right (2)");
          return true;
        });
        class Point {
          constructor(X, Y, Z, T) {
            this.X = acoord("x", X);
            this.Y = acoord("y", Y);
            this.Z = acoord("z", Z, true);
            this.T = acoord("t", T);
            Object.freeze(this);
          }
          static CURVE() {
            return CURVE;
          }
          static fromAffine(p) {
            if (p instanceof Point)
              throw new Error("extended point not allowed");
            const { x, y } = p || {};
            acoord("x", x);
            acoord("y", y);
            return new Point(x, y, _1n, modP(x * y));
          }
          // Uses algo from RFC8032 5.1.3.
          static fromBytes(bytes, zip215 = false) {
            const len = Fp.BYTES;
            const { a, d } = CURVE;
            bytes = (0, utils_ts_1.copyBytes)((0, utils_ts_1._abytes2)(bytes, len, "point"));
            (0, utils_ts_1._abool2)(zip215, "zip215");
            const normed = (0, utils_ts_1.copyBytes)(bytes);
            const lastByte = bytes[len - 1];
            normed[len - 1] = lastByte & ~128;
            const y = (0, utils_ts_1.bytesToNumberLE)(normed);
            const max = zip215 ? MASK : Fp.ORDER;
            (0, utils_ts_1.aInRange)("point.y", y, _0n, max);
            const y2 = modP(y * y);
            const u = modP(y2 - _1n);
            const v = modP(d * y2 - a);
            let { isValid, value: x } = uvRatio(u, v);
            if (!isValid)
              throw new Error("bad point: invalid y coordinate");
            const isXOdd = (x & _1n) === _1n;
            const isLastByteOdd = (lastByte & 128) !== 0;
            if (!zip215 && x === _0n && isLastByteOdd)
              throw new Error("bad point: x=0 and x_0=1");
            if (isLastByteOdd !== isXOdd)
              x = modP(-x);
            return Point.fromAffine({ x, y });
          }
          static fromHex(bytes, zip215 = false) {
            return Point.fromBytes((0, utils_ts_1.ensureBytes)("point", bytes), zip215);
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          precompute(windowSize = 8, isLazy = true) {
            wnaf.createCache(this, windowSize);
            if (!isLazy)
              this.multiply(_2n);
            return this;
          }
          // Useful in fromAffine() - not for fromBytes(), which always created valid points.
          assertValidity() {
            assertValidMemo(this);
          }
          // Compare one point to another.
          equals(other) {
            aextpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          negate() {
            return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
          }
          // Fast algo for doubling Extended Point.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
          // Cost: 4M + 4S + 1*a + 6add + 1*2.
          double() {
            const { a } = CURVE;
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const A = modP(X1 * X1);
            const B = modP(Y1 * Y1);
            const C = modP(_2n * modP(Z1 * Z1));
            const D = modP(a * A);
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B);
            const G = D + B;
            const F = G - C;
            const H = D - B;
            const X3 = modP(E * F);
            const Y3 = modP(G * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G);
            return new Point(X3, Y3, Z3, T3);
          }
          // Fast algo for adding 2 Extended Points.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
          // Cost: 9M + 1*a + 1*d + 7add.
          add(other) {
            aextpoint(other);
            const { a, d } = CURVE;
            const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
            const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
            const A = modP(X1 * X2);
            const B = modP(Y1 * Y2);
            const C = modP(T1 * d * T2);
            const D = modP(Z1 * Z2);
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
            const F = D - C;
            const G = D + C;
            const H = modP(B - a * A);
            const X3 = modP(E * F);
            const Y3 = modP(G * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G);
            return new Point(X3, Y3, Z3, T3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          // Constant-time multiplication.
          multiply(scalar) {
            if (!Fn.isValidNot0(scalar))
              throw new Error("invalid scalar: expected 1 <= sc < curve.n");
            const { p, f: f2 } = wnaf.cached(this, scalar, (p2) => (0, curve_ts_1.normalizeZ)(Point, p2));
            return (0, curve_ts_1.normalizeZ)(Point, [p, f2])[0];
          }
          // Non-constant-time multiplication. Uses double-and-add algorithm.
          // It's faster, but should only be used when you don't care about
          // an exposed private key e.g. sig verification.
          // Does NOT allow scalars higher than CURVE.n.
          // Accepts optional accumulator to merge with multiply (important for sparse scalars)
          multiplyUnsafe(scalar, acc = Point.ZERO) {
            if (!Fn.isValid(scalar))
              throw new Error("invalid scalar: expected 0 <= sc < curve.n");
            if (scalar === _0n)
              return Point.ZERO;
            if (this.is0() || scalar === _1n)
              return this;
            return wnaf.unsafe(this, scalar, (p) => (0, curve_ts_1.normalizeZ)(Point, p), acc);
          }
          // Checks if point is of small order.
          // If you add something to small order point, you will have "dirty"
          // point with torsion component.
          // Multiplies point by cofactor and checks if the result is 0.
          isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
          }
          // Multiplies point by curve order and checks if the result is 0.
          // Returns `false` is the point is dirty.
          isTorsionFree() {
            return wnaf.unsafe(this, CURVE.n).is0();
          }
          // Converts Extended point to default (x, y) coordinates.
          // Can accept precomputed Z^-1 - for example, from invertBatch.
          toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
          }
          clearCofactor() {
            if (cofactor === _1n)
              return this;
            return this.multiplyUnsafe(cofactor);
          }
          toBytes() {
            const { x, y } = this.toAffine();
            const bytes = Fp.toBytes(y);
            bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
            return bytes;
          }
          toHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes());
          }
          toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
          }
          // TODO: remove
          get ex() {
            return this.X;
          }
          get ey() {
            return this.Y;
          }
          get ez() {
            return this.Z;
          }
          get et() {
            return this.T;
          }
          static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, points);
          }
          static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
          }
          _setWindowSize(windowSize) {
            this.precompute(windowSize);
          }
          toRawBytes() {
            return this.toBytes();
          }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
        Point.ZERO = new Point(_0n, _1n, _1n, _0n);
        Point.Fp = Fp;
        Point.Fn = Fn;
        const wnaf = new curve_ts_1.wNAF(Point, Fn.BITS);
        Point.BASE.precompute(8);
        return Point;
      }
      var PrimeEdwardsPoint = class {
        constructor(ep) {
          this.ep = ep;
        }
        // Static methods that must be implemented by subclasses
        static fromBytes(_bytes) {
          (0, utils_ts_1.notImplemented)();
        }
        static fromHex(_hex) {
          (0, utils_ts_1.notImplemented)();
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        // Common implementations
        clearCofactor() {
          return this;
        }
        assertValidity() {
          this.ep.assertValidity();
        }
        toAffine(invertedZ) {
          return this.ep.toAffine(invertedZ);
        }
        toHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes());
        }
        toString() {
          return this.toHex();
        }
        isTorsionFree() {
          return true;
        }
        isSmallOrder() {
          return false;
        }
        add(other) {
          this.assertSame(other);
          return this.init(this.ep.add(other.ep));
        }
        subtract(other) {
          this.assertSame(other);
          return this.init(this.ep.subtract(other.ep));
        }
        multiply(scalar) {
          return this.init(this.ep.multiply(scalar));
        }
        multiplyUnsafe(scalar) {
          return this.init(this.ep.multiplyUnsafe(scalar));
        }
        double() {
          return this.init(this.ep.double());
        }
        negate() {
          return this.init(this.ep.negate());
        }
        precompute(windowSize, isLazy) {
          return this.init(this.ep.precompute(windowSize, isLazy));
        }
        /** @deprecated use `toBytes` */
        toRawBytes() {
          return this.toBytes();
        }
      };
      exports.PrimeEdwardsPoint = PrimeEdwardsPoint;
      function eddsa(Point, cHash, eddsaOpts = {}) {
        if (typeof cHash !== "function")
          throw new Error('"hash" function param is required');
        (0, utils_ts_1._validateObject)(eddsaOpts, {}, {
          adjustScalarBytes: "function",
          randomBytes: "function",
          domain: "function",
          prehash: "function",
          mapToCurve: "function"
        });
        const { prehash } = eddsaOpts;
        const { BASE, Fp, Fn } = Point;
        const randomBytes = eddsaOpts.randomBytes || utils_ts_1.randomBytes;
        const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
        const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
          (0, utils_ts_1._abool2)(phflag, "phflag");
          if (ctx.length || phflag)
            throw new Error("Contexts/pre-hash are not supported");
          return data;
        });
        function modN_LE(hash2) {
          return Fn.create((0, utils_ts_1.bytesToNumberLE)(hash2));
        }
        function getPrivateScalar(key) {
          const len = lengths.secretKey;
          key = (0, utils_ts_1.ensureBytes)("private key", key, len);
          const hashed = (0, utils_ts_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
          const head = adjustScalarBytes(hashed.slice(0, len));
          const prefix = hashed.slice(len, 2 * len);
          const scalar = modN_LE(head);
          return { head, prefix, scalar };
        }
        function getExtendedPublicKey(secretKey) {
          const { head, prefix, scalar } = getPrivateScalar(secretKey);
          const point = BASE.multiply(scalar);
          const pointBytes = point.toBytes();
          return { head, prefix, scalar, point, pointBytes };
        }
        function getPublicKey(secretKey) {
          return getExtendedPublicKey(secretKey).pointBytes;
        }
        function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
          const msg = (0, utils_ts_1.concatBytes)(...msgs);
          return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)("context", context), !!prehash)));
        }
        function sign(msg, secretKey, options = {}) {
          msg = (0, utils_ts_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
          const r = hashDomainToScalar(options.context, prefix, msg);
          const R = BASE.multiply(r).toBytes();
          const k = hashDomainToScalar(options.context, R, pointBytes, msg);
          const s = Fn.create(r + k * scalar);
          if (!Fn.isValid(s))
            throw new Error("sign failed: invalid s");
          const rs = (0, utils_ts_1.concatBytes)(R, Fn.toBytes(s));
          return (0, utils_ts_1._abytes2)(rs, lengths.signature, "result");
        }
        const verifyOpts = { zip215: true };
        function verify(sig, msg, publicKey3, options = verifyOpts) {
          const { context, zip215 } = options;
          const len = lengths.signature;
          sig = (0, utils_ts_1.ensureBytes)("signature", sig, len);
          msg = (0, utils_ts_1.ensureBytes)("message", msg);
          publicKey3 = (0, utils_ts_1.ensureBytes)("publicKey", publicKey3, lengths.publicKey);
          if (zip215 !== void 0)
            (0, utils_ts_1._abool2)(zip215, "zip215");
          if (prehash)
            msg = prehash(msg);
          const mid = len / 2;
          const r = sig.subarray(0, mid);
          const s = (0, utils_ts_1.bytesToNumberLE)(sig.subarray(mid, len));
          let A, R, SB;
          try {
            A = Point.fromBytes(publicKey3, zip215);
            R = Point.fromBytes(r, zip215);
            SB = BASE.multiplyUnsafe(s);
          } catch (error) {
            return false;
          }
          if (!zip215 && A.isSmallOrder())
            return false;
          const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
          const RkA = R.add(A.multiplyUnsafe(k));
          return RkA.subtract(SB).clearCofactor().is0();
        }
        const _size = Fp.BYTES;
        const lengths = {
          secretKey: _size,
          publicKey: _size,
          signature: 2 * _size,
          seed: _size
        };
        function randomSecretKey(seed2 = randomBytes(lengths.seed)) {
          return (0, utils_ts_1._abytes2)(seed2, lengths.seed, "seed");
        }
        function keygen(seed2) {
          const secretKey = utils.randomSecretKey(seed2);
          return { secretKey, publicKey: getPublicKey(secretKey) };
        }
        function isValidSecretKey(key) {
          return (0, utils_ts_1.isBytes)(key) && key.length === Fn.BYTES;
        }
        function isValidPublicKey(key, zip215) {
          try {
            return !!Point.fromBytes(key, zip215);
          } catch (error) {
            return false;
          }
        }
        const utils = {
          getExtendedPublicKey,
          randomSecretKey,
          isValidSecretKey,
          isValidPublicKey,
          /**
           * Converts ed public key to x public key. Uses formula:
           * - ed25519:
           *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
           *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
           * - ed448:
           *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
           *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
           */
          toMontgomery(publicKey3) {
            const { y } = Point.fromBytes(publicKey3);
            const size = lengths.publicKey;
            const is25519 = size === 32;
            if (!is25519 && size !== 57)
              throw new Error("only defined for 25519 and 448");
            const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);
            return Fp.toBytes(u);
          },
          toMontgomerySecret(secretKey) {
            const size = lengths.secretKey;
            (0, utils_ts_1._abytes2)(secretKey, size);
            const hashed = cHash(secretKey.subarray(0, size));
            return adjustScalarBytes(hashed).subarray(0, size);
          },
          /** @deprecated */
          randomPrivateKey: randomSecretKey,
          /** @deprecated */
          precompute(windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
          }
        };
        return Object.freeze({
          keygen,
          getPublicKey,
          sign,
          verify,
          utils,
          Point,
          lengths
        });
      }
      function _eddsa_legacy_opts_to_new(c) {
        const CURVE = {
          a: c.a,
          d: c.d,
          p: c.Fp.ORDER,
          n: c.n,
          h: c.h,
          Gx: c.Gx,
          Gy: c.Gy
        };
        const Fp = c.Fp;
        const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength, true);
        const curveOpts = { Fp, Fn, uvRatio: c.uvRatio };
        const eddsaOpts = {
          randomBytes: c.randomBytes,
          adjustScalarBytes: c.adjustScalarBytes,
          domain: c.domain,
          prehash: c.prehash,
          mapToCurve: c.mapToCurve
        };
        return { CURVE, curveOpts, hash: c.hash, eddsaOpts };
      }
      function _eddsa_new_output_to_legacy(c, eddsa2) {
        const Point = eddsa2.Point;
        const legacy = Object.assign({}, eddsa2, {
          ExtendedPoint: Point,
          CURVE: c,
          nBitLength: Point.Fn.BITS,
          nByteLength: Point.Fn.BYTES
        });
        return legacy;
      }
      function twistedEdwards(c) {
        const { CURVE, curveOpts, hash: hash2, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
        const Point = edwards(CURVE, curveOpts);
        const EDDSA = eddsa(Point, hash2, eddsaOpts);
        return _eddsa_new_output_to_legacy(c, EDDSA);
      }
    }
  });

  // node_modules/@noble/curves/abstract/hash-to-curve.js
  var require_hash_to_curve = __commonJS({
    "node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._DST_scalar = void 0;
      exports.expand_message_xmd = expand_message_xmd;
      exports.expand_message_xof = expand_message_xof;
      exports.hash_to_field = hash_to_field;
      exports.isogenyMap = isogenyMap;
      exports.createHasher = createHasher2;
      var utils_ts_1 = require_utils2();
      var modular_ts_1 = require_modular();
      var os2ip = utils_ts_1.bytesToNumberBE;
      function i2osp(value, length) {
        anum(value);
        anum(length);
        if (value < 0 || value >= 1 << 8 * length)
          throw new Error("invalid I2OSP input: " + value);
        const res = Array.from({ length }).fill(0);
        for (let i = length - 1; i >= 0; i--) {
          res[i] = value & 255;
          value >>>= 8;
        }
        return new Uint8Array(res);
      }
      function strxor(a, b) {
        const arr = new Uint8Array(a.length);
        for (let i = 0; i < a.length; i++) {
          arr[i] = a[i] ^ b[i];
        }
        return arr;
      }
      function anum(item) {
        if (!Number.isSafeInteger(item))
          throw new Error("number expected");
      }
      function normDST(DST) {
        if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== "string")
          throw new Error("DST must be Uint8Array or string");
        return typeof DST === "string" ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;
      }
      function expand_message_xmd(msg, DST, lenInBytes, H) {
        (0, utils_ts_1.abytes)(msg);
        anum(lenInBytes);
        DST = normDST(DST);
        if (DST.length > 255)
          DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
        const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
        const ell = Math.ceil(lenInBytes / b_in_bytes);
        if (lenInBytes > 65535 || ell > 255)
          throw new Error("expand_message_xmd: invalid lenInBytes");
        const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
        const Z_pad = i2osp(0, r_in_bytes);
        const l_i_b_str = i2osp(lenInBytes, 2);
        const b = new Array(ell);
        const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
        b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
        for (let i = 1; i <= ell; i++) {
          const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
          b[i] = H((0, utils_ts_1.concatBytes)(...args));
        }
        const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
        return pseudo_random_bytes.slice(0, lenInBytes);
      }
      function expand_message_xof(msg, DST, lenInBytes, k, H) {
        (0, utils_ts_1.abytes)(msg);
        anum(lenInBytes);
        DST = normDST(DST);
        if (DST.length > 255) {
          const dkLen = Math.ceil(2 * k / 8);
          DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
        }
        if (lenInBytes > 65535 || DST.length > 255)
          throw new Error("expand_message_xof: invalid lenInBytes");
        return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
      }
      function hash_to_field(msg, count, options) {
        (0, utils_ts_1._validateObject)(options, {
          p: "bigint",
          m: "number",
          k: "number",
          hash: "function"
        });
        const { p, k, m, hash: hash2, expand, DST } = options;
        if (!(0, utils_ts_1.isHash)(options.hash))
          throw new Error("expected valid hash");
        (0, utils_ts_1.abytes)(msg);
        anum(count);
        const log2p = p.toString(2).length;
        const L = Math.ceil((log2p + k) / 8);
        const len_in_bytes = count * m * L;
        let prb;
        if (expand === "xmd") {
          prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
        } else if (expand === "xof") {
          prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
        } else if (expand === "_internal_pass") {
          prb = msg;
        } else {
          throw new Error('expand must be "xmd" or "xof"');
        }
        const u = new Array(count);
        for (let i = 0; i < count; i++) {
          const e = new Array(m);
          for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
          }
          u[i] = e;
        }
        return u;
      }
      function isogenyMap(field, map) {
        const coeff = map.map((i) => Array.from(i).reverse());
        return (x, y) => {
          const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
          const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);
          x = field.mul(xn, xd_inv);
          y = field.mul(y, field.mul(yn, yd_inv));
          return { x, y };
        };
      }
      exports._DST_scalar = (0, utils_ts_1.utf8ToBytes)("HashToScalar-");
      function createHasher2(Point, mapToCurve, defaults) {
        if (typeof mapToCurve !== "function")
          throw new Error("mapToCurve() must be defined");
        function map(num) {
          return Point.fromAffine(mapToCurve(num));
        }
        function clear(initial) {
          const P = initial.clearCofactor();
          if (P.equals(Point.ZERO))
            return Point.ZERO;
          P.assertValidity();
          return P;
        }
        return {
          defaults,
          hashToCurve(msg, options) {
            const opts = Object.assign({}, defaults, options);
            const u = hash_to_field(msg, 2, opts);
            const u0 = map(u[0]);
            const u1 = map(u[1]);
            return clear(u0.add(u1));
          },
          encodeToCurve(msg, options) {
            const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
            const opts = Object.assign({}, defaults, optsDst, options);
            const u = hash_to_field(msg, 1, opts);
            const u0 = map(u[0]);
            return clear(u0);
          },
          /** See {@link H2CHasher} */
          mapToCurve(scalars) {
            if (!Array.isArray(scalars))
              throw new Error("expected array of bigints");
            for (const i of scalars)
              if (typeof i !== "bigint")
                throw new Error("expected array of bigints");
            return clear(map(scalars));
          },
          // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
          // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
          hashToScalar(msg, options) {
            const N = Point.Fn.ORDER;
            const opts = Object.assign({}, defaults, { p: N, m: 1, DST: exports._DST_scalar }, options);
            return hash_to_field(msg, 1, opts)[0][0];
          }
        };
      }
    }
  });

  // node_modules/@noble/curves/abstract/montgomery.js
  var require_montgomery = __commonJS({
    "node_modules/@noble/curves/abstract/montgomery.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.montgomery = montgomery;
      var utils_ts_1 = require_utils2();
      var modular_ts_1 = require_modular();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      function validateOpts(curve) {
        (0, utils_ts_1._validateObject)(curve, {
          adjustScalarBytes: "function",
          powPminus2: "function"
        });
        return Object.freeze({ ...curve });
      }
      function montgomery(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { P, type: type2, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;
        const is25519 = type2 === "x25519";
        if (!is25519 && type2 !== "x448")
          throw new Error("invalid type");
        const randomBytes_ = rand || utils_ts_1.randomBytes;
        const montgomeryBits = is25519 ? 255 : 448;
        const fieldLen = is25519 ? 32 : 56;
        const Gu = is25519 ? BigInt(9) : BigInt(5);
        const a24 = is25519 ? BigInt(121665) : BigInt(39081);
        const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);
        const maxAdded = is25519 ? BigInt(8) * _2n ** BigInt(251) - _1n : BigInt(4) * _2n ** BigInt(445) - _1n;
        const maxScalar = minScalar + maxAdded + _1n;
        const modP = (n) => (0, modular_ts_1.mod)(n, P);
        const GuBytes = encodeU(Gu);
        function encodeU(u) {
          return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);
        }
        function decodeU(u) {
          const _u = (0, utils_ts_1.ensureBytes)("u coordinate", u, fieldLen);
          if (is25519)
            _u[31] &= 127;
          return modP((0, utils_ts_1.bytesToNumberLE)(_u));
        }
        function decodeScalar(scalar) {
          return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes((0, utils_ts_1.ensureBytes)("scalar", scalar, fieldLen)));
        }
        function scalarMult(scalar, u) {
          const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
          if (pu === _0n)
            throw new Error("invalid private or public key received");
          return encodeU(pu);
        }
        function scalarMultBase(scalar) {
          return scalarMult(scalar, GuBytes);
        }
        function cswap(swap, x_2, x_3) {
          const dummy = modP(swap * (x_2 - x_3));
          x_2 = modP(x_2 - dummy);
          x_3 = modP(x_3 + dummy);
          return { x_2, x_3 };
        }
        function montgomeryLadder(u, scalar) {
          (0, utils_ts_1.aInRange)("u", u, _0n, P);
          (0, utils_ts_1.aInRange)("scalar", scalar, minScalar, maxScalar);
          const k = scalar;
          const x_1 = u;
          let x_2 = _1n;
          let z_2 = _0n;
          let x_3 = u;
          let z_3 = _1n;
          let swap = _0n;
          for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            const k_t = k >> t & _1n;
            swap ^= k_t;
            ({ x_2, x_3 } = cswap(swap, x_2, x_3));
            ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
            swap = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
          }
          ({ x_2, x_3 } = cswap(swap, x_2, x_3));
          ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
          const z2 = powPminus2(z_2);
          return modP(x_2 * z2);
        }
        const lengths = {
          secretKey: fieldLen,
          publicKey: fieldLen,
          seed: fieldLen
        };
        const randomSecretKey = (seed2 = randomBytes_(fieldLen)) => {
          (0, utils_ts_1.abytes)(seed2, lengths.seed);
          return seed2;
        };
        function keygen(seed2) {
          const secretKey = randomSecretKey(seed2);
          return { secretKey, publicKey: scalarMultBase(secretKey) };
        }
        const utils = {
          randomSecretKey,
          randomPrivateKey: randomSecretKey
        };
        return {
          keygen,
          getSharedSecret: (secretKey, publicKey3) => scalarMult(secretKey, publicKey3),
          getPublicKey: (secretKey) => scalarMultBase(secretKey),
          scalarMult,
          scalarMultBase,
          utils,
          GuBytes: GuBytes.slice(),
          lengths
        };
      }
    }
  });

  // node_modules/@noble/curves/ed25519.js
  var require_ed25519 = __commonJS({
    "node_modules/@noble/curves/ed25519.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.encodeToCurve = exports.hashToCurve = exports.RistrettoPoint = exports.edwardsToMontgomery = exports.ED25519_TORSION_SUBGROUP = exports.ristretto255_hasher = exports.ristretto255 = exports.ed25519_hasher = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = void 0;
      exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
      exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
      var sha2_js_1 = require_sha2();
      var utils_js_1 = require_utils();
      var curve_ts_1 = require_curve();
      var edwards_ts_1 = require_edwards();
      var hash_to_curve_ts_1 = require_hash_to_curve();
      var modular_ts_1 = require_modular();
      var montgomery_ts_1 = require_montgomery();
      var utils_ts_1 = require_utils2();
      var _0n = /* @__PURE__ */ BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _3n = BigInt(3);
      var _5n = BigInt(5);
      var _8n = BigInt(8);
      var ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
      var ed25519_CURVE = /* @__PURE__ */ (() => ({
        p: ed25519_CURVE_p,
        n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
        h: _8n,
        a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
        d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
        Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
        Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
      }))();
      function ed25519_pow_2_252_3(x) {
        const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
        const P = ed25519_CURVE_p;
        const x2 = x * x % P;
        const b2 = x2 * x % P;
        const b4 = (0, modular_ts_1.pow2)(b2, _2n, P) * b2 % P;
        const b5 = (0, modular_ts_1.pow2)(b4, _1n, P) * x % P;
        const b10 = (0, modular_ts_1.pow2)(b5, _5n, P) * b5 % P;
        const b20 = (0, modular_ts_1.pow2)(b10, _10n, P) * b10 % P;
        const b40 = (0, modular_ts_1.pow2)(b20, _20n, P) * b20 % P;
        const b80 = (0, modular_ts_1.pow2)(b40, _40n, P) * b40 % P;
        const b160 = (0, modular_ts_1.pow2)(b80, _80n, P) * b80 % P;
        const b240 = (0, modular_ts_1.pow2)(b160, _80n, P) * b80 % P;
        const b250 = (0, modular_ts_1.pow2)(b240, _10n, P) * b10 % P;
        const pow_p_5_8 = (0, modular_ts_1.pow2)(b250, _2n, P) * x % P;
        return { pow_p_5_8, b2 };
      }
      function adjustScalarBytes(bytes) {
        bytes[0] &= 248;
        bytes[31] &= 127;
        bytes[31] |= 64;
        return bytes;
      }
      var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
      function uvRatio(u, v) {
        const P = ed25519_CURVE_p;
        const v32 = (0, modular_ts_1.mod)(v * v * v, P);
        const v7 = (0, modular_ts_1.mod)(v32 * v32 * v, P);
        const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
        let x = (0, modular_ts_1.mod)(u * v32 * pow, P);
        const vx2 = (0, modular_ts_1.mod)(v * x * x, P);
        const root1 = x;
        const root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P);
        const useRoot1 = vx2 === u;
        const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P);
        const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P);
        if (useRoot1)
          x = root1;
        if (useRoot2 || noRoot)
          x = root2;
        if ((0, modular_ts_1.isNegativeLE)(x, P))
          x = (0, modular_ts_1.mod)(-x, P);
        return { isValid: useRoot1 || useRoot2, value: x };
      }
      var Fp = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.p, { isLE: true }))();
      var Fn = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.n, { isLE: true }))();
      var ed25519Defaults = /* @__PURE__ */ (() => ({
        ...ed25519_CURVE,
        Fp,
        hash: sha2_js_1.sha512,
        adjustScalarBytes,
        // dom2
        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
        // Constant-time, u/√v
        uvRatio
      }))();
      exports.ed25519 = (() => (0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();
      function ed25519_domain(data, ctx, phflag) {
        if (ctx.length > 255)
          throw new Error("Context is too big");
        return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
      }
      exports.ed25519ctx = (() => (0, edwards_ts_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain
      }))();
      exports.ed25519ph = (() => (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
        domain: ed25519_domain,
        prehash: sha2_js_1.sha512
      })))();
      exports.x25519 = (() => {
        const P = Fp.ORDER;
        return (0, montgomery_ts_1.montgomery)({
          P,
          type: "x25519",
          powPminus2: (x) => {
            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
            return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
          },
          adjustScalarBytes
        });
      })();
      var ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n) / _8n)();
      var ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))();
      var ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
      function map_to_curve_elligator2_curve25519(u) {
        const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n;
        const ELL2_J = BigInt(486662);
        let tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, _2n);
        let xd = Fp.add(tv1, Fp.ONE);
        let x1n = Fp.neg(ELL2_J);
        let tv2 = Fp.sqr(xd);
        let gxd = Fp.mul(tv2, xd);
        let gx1 = Fp.mul(tv1, ELL2_J);
        gx1 = Fp.mul(gx1, x1n);
        gx1 = Fp.add(gx1, tv2);
        gx1 = Fp.mul(gx1, x1n);
        let tv3 = Fp.sqr(gxd);
        tv2 = Fp.sqr(tv3);
        tv3 = Fp.mul(tv3, gxd);
        tv3 = Fp.mul(tv3, gx1);
        tv2 = Fp.mul(tv2, tv3);
        let y11 = Fp.pow(tv2, ELL2_C4);
        y11 = Fp.mul(y11, tv3);
        let y12 = Fp.mul(y11, ELL2_C3);
        tv2 = Fp.sqr(y11);
        tv2 = Fp.mul(tv2, gxd);
        let e1 = Fp.eql(tv2, gx1);
        let y1 = Fp.cmov(y12, y11, e1);
        let x2n = Fp.mul(x1n, tv1);
        let y21 = Fp.mul(y11, u);
        y21 = Fp.mul(y21, ELL2_C2);
        let y22 = Fp.mul(y21, ELL2_C3);
        let gx2 = Fp.mul(gx1, tv1);
        tv2 = Fp.sqr(y21);
        tv2 = Fp.mul(tv2, gxd);
        let e2 = Fp.eql(tv2, gx2);
        let y2 = Fp.cmov(y22, y21, e2);
        tv2 = Fp.sqr(y1);
        tv2 = Fp.mul(tv2, gxd);
        let e3 = Fp.eql(tv2, gx1);
        let xn = Fp.cmov(x2n, x1n, e3);
        let y = Fp.cmov(y2, y1, e3);
        let e4 = Fp.isOdd(y);
        y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
        return { xMn: xn, xMd: xd, yMn: y, yMd: _1n };
      }
      var ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))();
      function map_to_curve_elligator2_edwards25519(u) {
        const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
        let xn = Fp.mul(xMn, yMd);
        xn = Fp.mul(xn, ELL2_C1_EDWARDS);
        let xd = Fp.mul(xMd, yMn);
        let yn = Fp.sub(xMn, xMd);
        let yd = Fp.add(xMn, xMd);
        let tv1 = Fp.mul(xd, yd);
        let e = Fp.eql(tv1, Fp.ZERO);
        xn = Fp.cmov(xn, Fp.ZERO, e);
        xd = Fp.cmov(xd, Fp.ONE, e);
        yn = Fp.cmov(yn, Fp.ONE, e);
        yd = Fp.cmov(yd, Fp.ONE, e);
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp, [xd, yd], true);
        return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) };
      }
      exports.ed25519_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
        DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
        encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
        p: ed25519_CURVE_p,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha2_js_1.sha512
      }))();
      var SQRT_M1 = ED25519_SQRT_M1;
      var SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
      var INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
      var ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
      var D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
      var invertSqrt = (number2) => uvRatio(_1n, number2);
      var MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      var bytes255ToNumberLE = (bytes) => exports.ed25519.Point.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes) & MAX_255B);
      function calcElligatorRistrettoMap(r0) {
        const { d } = ed25519_CURVE;
        const P = ed25519_CURVE_p;
        const mod = (n) => Fp.create(n);
        const r = mod(SQRT_M1 * r0 * r0);
        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod((c - d * r) * mod(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod(s * r0);
        if (!(0, modular_ts_1.isNegativeLE)(s_, P))
          s_ = mod(-s_);
        if (!Ns_D_is_sq)
          s = s_;
        if (!Ns_D_is_sq)
          c = r;
        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod((s + s) * D);
        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod(_1n - s2);
        const W3 = mod(_1n + s2);
        return new exports.ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
      }
      function ristretto255_map(bytes) {
        (0, utils_js_1.abytes)(bytes, 64);
        const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
        const R1 = calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
        const R2 = calcElligatorRistrettoMap(r2);
        return new _RistrettoPoint(R1.add(R2));
      }
      var _RistrettoPoint = class __RistrettoPoint extends edwards_ts_1.PrimeEdwardsPoint {
        constructor(ep) {
          super(ep);
        }
        static fromAffine(ap) {
          return new __RistrettoPoint(exports.ed25519.Point.fromAffine(ap));
        }
        assertSame(other) {
          if (!(other instanceof __RistrettoPoint))
            throw new Error("RistrettoPoint expected");
        }
        init(ep) {
          return new __RistrettoPoint(ep);
        }
        /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
        static hashToCurve(hex2) {
          return ristretto255_map((0, utils_ts_1.ensureBytes)("ristrettoHash", hex2, 64));
        }
        static fromBytes(bytes) {
          (0, utils_js_1.abytes)(bytes, 32);
          const { a, d } = ed25519_CURVE;
          const P = ed25519_CURVE_p;
          const mod = (n) => Fp.create(n);
          const s = bytes255ToNumberLE(bytes);
          if (!(0, utils_ts_1.equalBytes)(Fp.toBytes(s), bytes) || (0, modular_ts_1.isNegativeLE)(s, P))
            throw new Error("invalid ristretto255 encoding 1");
          const s2 = mod(s * s);
          const u1 = mod(_1n + a * s2);
          const u2 = mod(_1n - a * s2);
          const u1_2 = mod(u1 * u1);
          const u2_2 = mod(u2 * u2);
          const v = mod(a * d * u1_2 - u2_2);
          const { isValid, value: I } = invertSqrt(mod(v * u2_2));
          const Dx = mod(I * u2);
          const Dy = mod(I * Dx * v);
          let x = mod((s + s) * Dx);
          if ((0, modular_ts_1.isNegativeLE)(x, P))
            x = mod(-x);
          const y = mod(u1 * Dy);
          const t = mod(x * y);
          if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n)
            throw new Error("invalid ristretto255 encoding 2");
          return new __RistrettoPoint(new exports.ed25519.Point(x, y, _1n, t));
        }
        /**
         * Converts ristretto-encoded string to ristretto point.
         * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
         * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
         */
        static fromHex(hex2) {
          return __RistrettoPoint.fromBytes((0, utils_ts_1.ensureBytes)("ristrettoHex", hex2, 32));
        }
        static msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(__RistrettoPoint, exports.ed25519.Point.Fn, points, scalars);
        }
        /**
         * Encodes ristretto point to Uint8Array.
         * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
         */
        toBytes() {
          let { X, Y, Z, T } = this.ep;
          const P = ed25519_CURVE_p;
          const mod = (n) => Fp.create(n);
          const u1 = mod(mod(Z + Y) * mod(Z - Y));
          const u2 = mod(X * Y);
          const u2sq = mod(u2 * u2);
          const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
          const D1 = mod(invsqrt * u1);
          const D2 = mod(invsqrt * u2);
          const zInv = mod(D1 * D2 * T);
          let D;
          if ((0, modular_ts_1.isNegativeLE)(T * zInv, P)) {
            let _x = mod(Y * SQRT_M1);
            let _y = mod(X * SQRT_M1);
            X = _x;
            Y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
          } else {
            D = D2;
          }
          if ((0, modular_ts_1.isNegativeLE)(X * zInv, P))
            Y = mod(-Y);
          let s = mod((Z - Y) * D);
          if ((0, modular_ts_1.isNegativeLE)(s, P))
            s = mod(-s);
          return Fp.toBytes(s);
        }
        /**
         * Compares two Ristretto points.
         * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
         */
        equals(other) {
          this.assertSame(other);
          const { X: X1, Y: Y1 } = this.ep;
          const { X: X2, Y: Y2 } = other.ep;
          const mod = (n) => Fp.create(n);
          const one = mod(X1 * Y2) === mod(Y1 * X2);
          const two = mod(Y1 * Y2) === mod(X1 * X2);
          return one || two;
        }
        is0() {
          return this.equals(__RistrettoPoint.ZERO);
        }
      };
      _RistrettoPoint.BASE = /* @__PURE__ */ (() => new _RistrettoPoint(exports.ed25519.Point.BASE))();
      _RistrettoPoint.ZERO = /* @__PURE__ */ (() => new _RistrettoPoint(exports.ed25519.Point.ZERO))();
      _RistrettoPoint.Fp = /* @__PURE__ */ (() => Fp)();
      _RistrettoPoint.Fn = /* @__PURE__ */ (() => Fn)();
      exports.ristretto255 = { Point: _RistrettoPoint };
      exports.ristretto255_hasher = {
        hashToCurve(msg, options) {
          const DST = options?.DST || "ristretto255_XMD:SHA-512_R255MAP_RO_";
          const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
          return ristretto255_map(xmd);
        },
        hashToScalar(msg, options = { DST: hash_to_curve_ts_1._DST_scalar }) {
          const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, options.DST, 64, sha2_js_1.sha512);
          return Fn.create((0, utils_ts_1.bytesToNumberLE)(xmd));
        }
      };
      exports.ED25519_TORSION_SUBGROUP = [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
      ];
      function edwardsToMontgomeryPub(edwardsPub) {
        return exports.ed25519.utils.toMontgomery((0, utils_ts_1.ensureBytes)("pub", edwardsPub));
      }
      exports.edwardsToMontgomery = edwardsToMontgomeryPub;
      function edwardsToMontgomeryPriv(edwardsPriv) {
        return exports.ed25519.utils.toMontgomerySecret((0, utils_ts_1.ensureBytes)("pub", edwardsPriv));
      }
      exports.RistrettoPoint = _RistrettoPoint;
      exports.hashToCurve = (() => exports.ed25519_hasher.hashToCurve)();
      exports.encodeToCurve = (() => exports.ed25519_hasher.encodeToCurve)();
      exports.hashToRistretto255 = (() => exports.ristretto255_hasher.hashToCurve)();
      exports.hash_to_ristretto255 = (() => exports.ristretto255_hasher.hashToCurve)();
    }
  });

  // (disabled):node_modules/buffer/index.js
  var require_buffer2 = __commonJS({
    "(disabled):node_modules/buffer/index.js"() {
    }
  });

  // node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert2(val, msg) {
          if (!val) throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number2, base, endian) {
          if (BN2.isBN(number2)) {
            return number2;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number2 !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number2 || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = require_buffer2().Buffer;
          }
        } catch (e) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0) return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0) return left;
          return right;
        };
        BN2.prototype._init = function init(number2, base, endian) {
          if (typeof number2 === "number") {
            return this._initNumber(number2, base, endian);
          }
          if (typeof number2 === "object") {
            return this._initArray(number2, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert2(base === (base | 0) && base >= 2 && base <= 36);
          number2 = number2.toString().replace(/\s+/g, "");
          var start = 0;
          if (number2[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number2.length) {
            if (base === 16) {
              this._parseHex(number2, start, endian);
            } else {
              this._parseBase(number2, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number2, base, endian) {
          if (number2 < 0) {
            this.negative = 1;
            number2 = -number2;
          }
          if (number2 < 67108864) {
            this.words = [number2 & 67108863];
            this.length = 1;
          } else if (number2 < 4503599627370496) {
            this.words = [
              number2 & 67108863,
              number2 / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert2(number2 < 9007199254740992);
            this.words = [
              number2 & 67108863,
              number2 / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le") return;
          this._initArray(this.toArray(), base, endian);
        };
        BN2.prototype._initArray = function _initArray(number2, base, endian) {
          assert2(typeof number2.length === "number");
          if (number2.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number2.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
              w = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number2.length; i += 3) {
              w = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string2, index2) {
          var c = string2.charCodeAt(index2);
          if (c >= 48 && c <= 57) {
            return c - 48;
          } else if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            assert2(false, "Invalid character in " + string2);
          }
        }
        function parseHexByte(string2, lowerBound, index2) {
          var r = parseHex4Bits(string2, index2);
          if (index2 - 1 >= lowerBound) {
            r |= parseHex4Bits(string2, index2 - 1) << 4;
          }
          return r;
        }
        BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
          this.length = Math.ceil((number2.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number2.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number2, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number2.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
              w = parseHexByte(number2, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str2, start, end, mul) {
          var r = 0;
          var b = 0;
          var len = Math.min(str2.length, end);
          for (var i = start; i < len; i++) {
            var c = str2.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              b = c - 49 + 10;
            } else if (c >= 17) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            assert2(c >= 0 && b < mul, "Invalid character");
            r += b;
          }
          return r;
        }
        BN2.prototype._parseBase = function _parseBase(number2, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number2.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number2, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number2, i, number2.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN2.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN2.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN2.prototype.clone = function clone() {
          var r = new BN2(null);
          this.copy(r);
          return r;
        };
        BN2.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
          } catch (e) {
            BN2.prototype.inspect = inspect;
          }
        } else {
          BN2.prototype.inspect = inspect;
        }
        function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString2(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modrn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert2(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert2(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        };
        if (Buffer2) {
          BN2.prototype.toBuffer = function toBuffer(endian, length) {
            return this.toArrayLike(Buffer2, endian, length);
          };
        }
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType, size) {
          if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size);
          }
          return new ArrayType(size);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          this._strip();
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert2(byteLength <= reqLength, "byte array longer than desired length");
          assert2(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength);
          return res;
        };
        BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
          var position = 0;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
          var position = res.length - 1;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0) return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 1;
          }
          return w;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero()) return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
          }
          return r;
        };
        BN2.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this._strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length) return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length) return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this._strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length) return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length) return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor(num) {
          if (this.length > num.length) return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length) return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert2(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert2(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length) return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN2.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1) return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1) return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert2(carry === 0);
          assert2((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out._strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum) num = -num;
          assert2(typeof num === "number");
          assert2(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          this.length = num === 0 ? 1 : this.length;
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0) return new BN2(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0) break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0) continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert2(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert2(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert2(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask2 = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask2;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert2(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert2(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert2(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert2(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask2 = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask2;
          }
          return this._strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          if (num < 0) return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          if (num < 0) return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0) return this._strip();
          assert2(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert2(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero()) return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN2.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum) num = -num;
          assert2(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN2.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN2.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum) num = -num;
          assert2(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert2(p.negative === 0);
          assert2(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert2(p.negative === 0);
          assert2(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN2(1);
          var x2 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero()) return num.abs();
          if (num.isZero()) return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert2(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative) return -1;
          if (this.negative === 0 && negative) return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert2(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0) return -1;
          if (this.negative === 0 && num.negative !== 0) return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length) return 1;
          if (this.length < num.length) return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert2(!this.red, "Already a number in reduction context");
          assert2(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert2(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert2(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert2(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert2(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert2(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert2(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert2(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert2(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert2(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert2(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert2(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert2(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert2(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert2(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert2(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask2 = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask2;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name) {
          if (primes[name]) return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert2(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert2(a.negative === 0, "red works only with positives");
          assert2(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert2((a.negative | b.negative) === 0, "red works only with positives");
          assert2(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime) return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero()) return a.clone();
          var mod3 = this.m.andln(3);
          assert2(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert2(!q.isZero());
          var one = new BN2(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert2(i < m);
            var b = this.pow(c, new BN2(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero()) return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0) return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero()) return new BN2(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "node_modules/safe-buffer/index.js"(exports, module) {
      var buffer = require_buffer();
      var Buffer2 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer2(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer2.prototype);
      copyProps(Buffer2, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer2(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer2(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer2(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }
  });

  // node_modules/base-x/src/index.js
  var require_src = __commonJS({
    "node_modules/base-x/src/index.js"(exports, module) {
      "use strict";
      var _Buffer = require_safe_buffer().Buffer;
      function base(ALPHABET) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        var BASE_MAP = new Uint8Array(256);
        for (var j = 0; j < BASE_MAP.length; j++) {
          BASE_MAP[j] = 255;
        }
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i);
          var xc = x.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        var FACTOR = Math.log(BASE) / Math.log(256);
        var iFACTOR = Math.log(256) / Math.log(BASE);
        function encode2(source) {
          if (Array.isArray(source) || source instanceof Uint8Array) {
            source = _Buffer.from(source);
          }
          if (!_Buffer.isBuffer(source)) {
            throw new TypeError("Expected Buffer");
          }
          if (source.length === 0) {
            return "";
          }
          var zeroes = 0;
          var length = 0;
          var pbegin = 0;
          var pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
          var b58 = new Uint8Array(size);
          while (pbegin !== pend) {
            var carry = source[pbegin];
            var i2 = 0;
            for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
              carry += 256 * b58[it1] >>> 0;
              b58[it1] = carry % BASE >>> 0;
              carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            pbegin++;
          }
          var it2 = size - length;
          while (it2 !== size && b58[it2] === 0) {
            it2++;
          }
          var str2 = LEADER.repeat(zeroes);
          for (; it2 < size; ++it2) {
            str2 += ALPHABET.charAt(b58[it2]);
          }
          return str2;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return _Buffer.alloc(0);
          }
          var psz = 0;
          var zeroes = 0;
          var length = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          var size = (source.length - psz) * FACTOR + 1 >>> 0;
          var b256 = new Uint8Array(size);
          while (psz < source.length) {
            var charCode = source.charCodeAt(psz);
            if (charCode > 255) {
              return;
            }
            var carry = BASE_MAP[charCode];
            if (carry === 255) {
              return;
            }
            var i2 = 0;
            for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
              carry += BASE * b256[it3] >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            psz++;
          }
          var it4 = size - length;
          while (it4 !== size && b256[it4] === 0) {
            it4++;
          }
          var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
          vch.fill(0, 0, zeroes);
          var j2 = zeroes;
          while (it4 !== size) {
            vch[j2++] = b256[it4++];
          }
          return vch;
        }
        function decode2(string2) {
          var buffer = decodeUnsafe(string2);
          if (buffer) {
            return buffer;
          }
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode: encode2,
          decodeUnsafe,
          decode: decode2
        };
      }
      module.exports = base;
    }
  });

  // node_modules/bs58/index.js
  var require_bs58 = __commonJS({
    "node_modules/bs58/index.js"(exports, module) {
      var basex = require_src();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module.exports = basex(ALPHABET);
    }
  });

  // node_modules/@noble/hashes/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/@noble/hashes/sha256.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;
      var sha2_ts_1 = require_sha2();
      exports.SHA256 = sha2_ts_1.SHA256;
      exports.sha256 = sha2_ts_1.sha256;
      exports.SHA224 = sha2_ts_1.SHA224;
      exports.sha224 = sha2_ts_1.sha224;
    }
  });

  // node_modules/text-encoding-utf-8/lib/encoding.lib.js
  var require_encoding_lib = __commonJS({
    "node_modules/text-encoding-utf-8/lib/encoding.lib.js"(exports) {
      "use strict";
      function inRange(a, min, max) {
        return min <= a && a <= max;
      }
      function ToDictionary(o) {
        if (o === void 0) return {};
        if (o === Object(o)) return o;
        throw TypeError("Could not convert argument to dictionary");
      }
      function stringToCodePoints(string2) {
        var s = String(string2);
        var n = s.length;
        var i = 0;
        var u = [];
        while (i < n) {
          var c = s.charCodeAt(i);
          if (c < 55296 || c > 57343) {
            u.push(c);
          } else if (56320 <= c && c <= 57343) {
            u.push(65533);
          } else if (55296 <= c && c <= 56319) {
            if (i === n - 1) {
              u.push(65533);
            } else {
              var d = string2.charCodeAt(i + 1);
              if (56320 <= d && d <= 57343) {
                var a = c & 1023;
                var b = d & 1023;
                u.push(65536 + (a << 10) + b);
                i += 1;
              } else {
                u.push(65533);
              }
            }
          }
          i += 1;
        }
        return u;
      }
      function codePointsToString(code_points) {
        var s = "";
        for (var i = 0; i < code_points.length; ++i) {
          var cp = code_points[i];
          if (cp <= 65535) {
            s += String.fromCharCode(cp);
          } else {
            cp -= 65536;
            s += String.fromCharCode(
              (cp >> 10) + 55296,
              (cp & 1023) + 56320
            );
          }
        }
        return s;
      }
      var end_of_stream = -1;
      function Stream(tokens) {
        this.tokens = [].slice.call(tokens);
      }
      Stream.prototype = {
        /**
         * @return {boolean} True if end-of-stream has been hit.
         */
        endOfStream: function() {
          return !this.tokens.length;
        },
        /**
         * When a token is read from a stream, the first token in the
         * stream must be returned and subsequently removed, and
         * end-of-stream must be returned otherwise.
         *
         * @return {number} Get the next token from the stream, or
         * end_of_stream.
         */
        read: function() {
          if (!this.tokens.length)
            return end_of_stream;
          return this.tokens.shift();
        },
        /**
         * When one or more tokens are prepended to a stream, those tokens
         * must be inserted, in given order, before the first token in the
         * stream.
         *
         * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
         */
        prepend: function(token2) {
          if (Array.isArray(token2)) {
            var tokens = (
              /**@type {!Array.<number>}*/
              token2
            );
            while (tokens.length)
              this.tokens.unshift(tokens.pop());
          } else {
            this.tokens.unshift(token2);
          }
        },
        /**
         * When one or more tokens are pushed to a stream, those tokens
         * must be inserted, in given order, after the last token in the
         * stream.
         *
         * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
         */
        push: function(token2) {
          if (Array.isArray(token2)) {
            var tokens = (
              /**@type {!Array.<number>}*/
              token2
            );
            while (tokens.length)
              this.tokens.push(tokens.shift());
          } else {
            this.tokens.push(token2);
          }
        }
      };
      var finished = -1;
      function decoderError(fatal, opt_code_point) {
        if (fatal)
          throw TypeError("Decoder error");
        return opt_code_point || 65533;
      }
      var DEFAULT_ENCODING = "utf-8";
      function TextDecoder2(encoding, options) {
        if (!(this instanceof TextDecoder2)) {
          return new TextDecoder2(encoding, options);
        }
        encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
        if (encoding !== DEFAULT_ENCODING) {
          throw new Error("Encoding not supported. Only utf-8 is supported");
        }
        options = ToDictionary(options);
        this._streaming = false;
        this._BOMseen = false;
        this._decoder = null;
        this._fatal = Boolean(options["fatal"]);
        this._ignoreBOM = Boolean(options["ignoreBOM"]);
        Object.defineProperty(this, "encoding", { value: "utf-8" });
        Object.defineProperty(this, "fatal", { value: this._fatal });
        Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
      }
      TextDecoder2.prototype = {
        /**
         * @param {ArrayBufferView=} input The buffer of bytes to decode.
         * @param {Object=} options
         * @return {string} The decoded string.
         */
        decode: function decode2(input, options) {
          var bytes;
          if (typeof input === "object" && input instanceof ArrayBuffer) {
            bytes = new Uint8Array(input);
          } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
            bytes = new Uint8Array(
              input.buffer,
              input.byteOffset,
              input.byteLength
            );
          } else {
            bytes = new Uint8Array(0);
          }
          options = ToDictionary(options);
          if (!this._streaming) {
            this._decoder = new UTF8Decoder({ fatal: this._fatal });
            this._BOMseen = false;
          }
          this._streaming = Boolean(options["stream"]);
          var input_stream = new Stream(bytes);
          var code_points = [];
          var result;
          while (!input_stream.endOfStream()) {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (result === null)
              continue;
            if (Array.isArray(result))
              code_points.push.apply(
                code_points,
                /**@type {!Array.<number>}*/
                result
              );
            else
              code_points.push(result);
          }
          if (!this._streaming) {
            do {
              result = this._decoder.handler(input_stream, input_stream.read());
              if (result === finished)
                break;
              if (result === null)
                continue;
              if (Array.isArray(result))
                code_points.push.apply(
                  code_points,
                  /**@type {!Array.<number>}*/
                  result
                );
              else
                code_points.push(result);
            } while (!input_stream.endOfStream());
            this._decoder = null;
          }
          if (code_points.length) {
            if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
              if (code_points[0] === 65279) {
                this._BOMseen = true;
                code_points.shift();
              } else {
                this._BOMseen = true;
              }
            }
          }
          return codePointsToString(code_points);
        }
      };
      function TextEncoder2(encoding, options) {
        if (!(this instanceof TextEncoder2))
          return new TextEncoder2(encoding, options);
        encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
        if (encoding !== DEFAULT_ENCODING) {
          throw new Error("Encoding not supported. Only utf-8 is supported");
        }
        options = ToDictionary(options);
        this._streaming = false;
        this._encoder = null;
        this._options = { fatal: Boolean(options["fatal"]) };
        Object.defineProperty(this, "encoding", { value: "utf-8" });
      }
      TextEncoder2.prototype = {
        /**
         * @param {string=} opt_string The string to encode.
         * @param {Object=} options
         * @return {Uint8Array} Encoded bytes, as a Uint8Array.
         */
        encode: function encode2(opt_string, options) {
          opt_string = opt_string ? String(opt_string) : "";
          options = ToDictionary(options);
          if (!this._streaming)
            this._encoder = new UTF8Encoder(this._options);
          this._streaming = Boolean(options["stream"]);
          var bytes = [];
          var input_stream = new Stream(stringToCodePoints(opt_string));
          var result;
          while (!input_stream.endOfStream()) {
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (Array.isArray(result))
              bytes.push.apply(
                bytes,
                /**@type {!Array.<number>}*/
                result
              );
            else
              bytes.push(result);
          }
          if (!this._streaming) {
            while (true) {
              result = this._encoder.handler(input_stream, input_stream.read());
              if (result === finished)
                break;
              if (Array.isArray(result))
                bytes.push.apply(
                  bytes,
                  /**@type {!Array.<number>}*/
                  result
                );
              else
                bytes.push(result);
            }
            this._encoder = null;
          }
          return new Uint8Array(bytes);
        }
      };
      function UTF8Decoder(options) {
        var fatal = options.fatal;
        var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && utf8_bytes_needed !== 0) {
            utf8_bytes_needed = 0;
            return decoderError(fatal);
          }
          if (bite === end_of_stream)
            return finished;
          if (utf8_bytes_needed === 0) {
            if (inRange(bite, 0, 127)) {
              return bite;
            }
            if (inRange(bite, 194, 223)) {
              utf8_bytes_needed = 1;
              utf8_code_point = bite - 192;
            } else if (inRange(bite, 224, 239)) {
              if (bite === 224)
                utf8_lower_boundary = 160;
              if (bite === 237)
                utf8_upper_boundary = 159;
              utf8_bytes_needed = 2;
              utf8_code_point = bite - 224;
            } else if (inRange(bite, 240, 244)) {
              if (bite === 240)
                utf8_lower_boundary = 144;
              if (bite === 244)
                utf8_upper_boundary = 143;
              utf8_bytes_needed = 3;
              utf8_code_point = bite - 240;
            } else {
              return decoderError(fatal);
            }
            utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
            return null;
          }
          if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
            utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
            utf8_lower_boundary = 128;
            utf8_upper_boundary = 191;
            stream.prepend(bite);
            return decoderError(fatal);
          }
          utf8_lower_boundary = 128;
          utf8_upper_boundary = 191;
          utf8_bytes_seen += 1;
          utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
          if (utf8_bytes_seen !== utf8_bytes_needed)
            return null;
          var code_point = utf8_code_point;
          utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
          return code_point;
        };
      }
      function UTF8Encoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished;
          if (inRange(code_point, 0, 127))
            return code_point;
          var count, offset2;
          if (inRange(code_point, 128, 2047)) {
            count = 1;
            offset2 = 192;
          } else if (inRange(code_point, 2048, 65535)) {
            count = 2;
            offset2 = 224;
          } else if (inRange(code_point, 65536, 1114111)) {
            count = 3;
            offset2 = 240;
          }
          var bytes = [(code_point >> 6 * count) + offset2];
          while (count > 0) {
            var temp = code_point >> 6 * (count - 1);
            bytes.push(128 | temp & 63);
            count -= 1;
          }
          return bytes;
        };
      }
      exports.TextEncoder = TextEncoder2;
      exports.TextDecoder = TextDecoder2;
    }
  });

  // node_modules/borsh/lib/index.js
  var require_lib = __commonJS({
    "node_modules/borsh/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var bs58_1 = __importDefault(require_bs58());
      var encoding = __importStar(require_encoding_lib());
      var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
      var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
      function baseEncode(value) {
        if (typeof value === "string") {
          value = Buffer.from(value, "utf8");
        }
        return bs58_1.default.encode(Buffer.from(value));
      }
      exports.baseEncode = baseEncode;
      function baseDecode(value) {
        return Buffer.from(bs58_1.default.decode(value));
      }
      exports.baseDecode = baseDecode;
      var INITIAL_LENGTH = 1024;
      var BorshError = class extends Error {
        constructor(message) {
          super(message);
          this.fieldPath = [];
          this.originalMessage = message;
        }
        addToFieldPath(fieldName) {
          this.fieldPath.splice(0, 0, fieldName);
          this.message = this.originalMessage + ": " + this.fieldPath.join(".");
        }
      };
      exports.BorshError = BorshError;
      var BinaryWriter = class {
        constructor() {
          this.buf = Buffer.alloc(INITIAL_LENGTH);
          this.length = 0;
        }
        maybeResize() {
          if (this.buf.length < 16 + this.length) {
            this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
          }
        }
        writeU8(value) {
          this.maybeResize();
          this.buf.writeUInt8(value, this.length);
          this.length += 1;
        }
        writeU16(value) {
          this.maybeResize();
          this.buf.writeUInt16LE(value, this.length);
          this.length += 2;
        }
        writeU32(value) {
          this.maybeResize();
          this.buf.writeUInt32LE(value, this.length);
          this.length += 4;
        }
        writeU64(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
        }
        writeU128(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
        }
        writeU256(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
        }
        writeU512(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
        }
        writeBuffer(buffer) {
          this.buf = Buffer.concat([
            Buffer.from(this.buf.subarray(0, this.length)),
            buffer,
            Buffer.alloc(INITIAL_LENGTH)
          ]);
          this.length += buffer.length;
        }
        writeString(str2) {
          this.maybeResize();
          const b = Buffer.from(str2, "utf8");
          this.writeU32(b.length);
          this.writeBuffer(b);
        }
        writeFixedArray(array3) {
          this.writeBuffer(Buffer.from(array3));
        }
        writeArray(array3, fn) {
          this.maybeResize();
          this.writeU32(array3.length);
          for (const elem of array3) {
            this.maybeResize();
            fn(elem);
          }
        }
        toArray() {
          return this.buf.subarray(0, this.length);
        }
      };
      exports.BinaryWriter = BinaryWriter;
      function handlingRangeError(target, propertyKey, propertyDescriptor) {
        const originalMethod = propertyDescriptor.value;
        propertyDescriptor.value = function(...args) {
          try {
            return originalMethod.apply(this, args);
          } catch (e) {
            if (e instanceof RangeError) {
              const code = e.code;
              if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
                throw new BorshError("Reached the end of buffer when deserializing");
              }
            }
            throw e;
          }
        };
      }
      var BinaryReader = class {
        constructor(buf) {
          this.buf = buf;
          this.offset = 0;
        }
        readU8() {
          const value = this.buf.readUInt8(this.offset);
          this.offset += 1;
          return value;
        }
        readU16() {
          const value = this.buf.readUInt16LE(this.offset);
          this.offset += 2;
          return value;
        }
        readU32() {
          const value = this.buf.readUInt32LE(this.offset);
          this.offset += 4;
          return value;
        }
        readU64() {
          const buf = this.readBuffer(8);
          return new bn_js_1.default(buf, "le");
        }
        readU128() {
          const buf = this.readBuffer(16);
          return new bn_js_1.default(buf, "le");
        }
        readU256() {
          const buf = this.readBuffer(32);
          return new bn_js_1.default(buf, "le");
        }
        readU512() {
          const buf = this.readBuffer(64);
          return new bn_js_1.default(buf, "le");
        }
        readBuffer(len) {
          if (this.offset + len > this.buf.length) {
            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
          }
          const result = this.buf.slice(this.offset, this.offset + len);
          this.offset += len;
          return result;
        }
        readString() {
          const len = this.readU32();
          const buf = this.readBuffer(len);
          try {
            return textDecoder.decode(buf);
          } catch (e) {
            throw new BorshError(`Error decoding UTF-8 string: ${e}`);
          }
        }
        readFixedArray(len) {
          return new Uint8Array(this.readBuffer(len));
        }
        readArray(fn) {
          const len = this.readU32();
          const result = Array();
          for (let i = 0; i < len; ++i) {
            result.push(fn());
          }
          return result;
        }
      };
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU8", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU16", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU32", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU64", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU128", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU256", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU512", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readString", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readFixedArray", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readArray", null);
      exports.BinaryReader = BinaryReader;
      function capitalizeFirstLetter(string2) {
        return string2.charAt(0).toUpperCase() + string2.slice(1);
      }
      function serializeField(schema, fieldName, value, fieldType, writer) {
        try {
          if (typeof fieldType === "string") {
            writer[`write${capitalizeFirstLetter(fieldType)}`](value);
          } else if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
              if (value.length !== fieldType[0]) {
                throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
              }
              writer.writeFixedArray(value);
            } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
              if (value.length !== fieldType[1]) {
                throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
              }
              for (let i = 0; i < fieldType[1]; i++) {
                serializeField(schema, null, value[i], fieldType[0], writer);
              }
            } else {
              writer.writeArray(value, (item) => {
                serializeField(schema, fieldName, item, fieldType[0], writer);
              });
            }
          } else if (fieldType.kind !== void 0) {
            switch (fieldType.kind) {
              case "option": {
                if (value === null || value === void 0) {
                  writer.writeU8(0);
                } else {
                  writer.writeU8(1);
                  serializeField(schema, fieldName, value, fieldType.type, writer);
                }
                break;
              }
              case "map": {
                writer.writeU32(value.size);
                value.forEach((val, key) => {
                  serializeField(schema, fieldName, key, fieldType.key, writer);
                  serializeField(schema, fieldName, val, fieldType.value, writer);
                });
                break;
              }
              default:
                throw new BorshError(`FieldType ${fieldType} unrecognized`);
            }
          } else {
            serializeStruct(schema, value, writer);
          }
        } catch (error) {
          if (error instanceof BorshError) {
            error.addToFieldPath(fieldName);
          }
          throw error;
        }
      }
      function serializeStruct(schema, obj, writer) {
        if (typeof obj.borshSerialize === "function") {
          obj.borshSerialize(writer);
          return;
        }
        const structSchema = schema.get(obj.constructor);
        if (!structSchema) {
          throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
          structSchema.fields.map(([fieldName, fieldType]) => {
            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
          });
        } else if (structSchema.kind === "enum") {
          const name = obj[structSchema.field];
          for (let idx = 0; idx < structSchema.values.length; ++idx) {
            const [fieldName, fieldType] = structSchema.values[idx];
            if (fieldName === name) {
              writer.writeU8(idx);
              serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
              break;
            }
          }
        } else {
          throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
        }
      }
      function serialize(schema, obj, Writer = BinaryWriter) {
        const writer = new Writer();
        serializeStruct(schema, obj, writer);
        return writer.toArray();
      }
      exports.serialize = serialize;
      function deserializeField(schema, fieldName, fieldType, reader) {
        try {
          if (typeof fieldType === "string") {
            return reader[`read${capitalizeFirstLetter(fieldType)}`]();
          }
          if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
              return reader.readFixedArray(fieldType[0]);
            } else if (typeof fieldType[1] === "number") {
              const arr = [];
              for (let i = 0; i < fieldType[1]; i++) {
                arr.push(deserializeField(schema, null, fieldType[0], reader));
              }
              return arr;
            } else {
              return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
            }
          }
          if (fieldType.kind === "option") {
            const option2 = reader.readU8();
            if (option2) {
              return deserializeField(schema, fieldName, fieldType.type, reader);
            }
            return void 0;
          }
          if (fieldType.kind === "map") {
            let map = /* @__PURE__ */ new Map();
            const length = reader.readU32();
            for (let i = 0; i < length; i++) {
              const key = deserializeField(schema, fieldName, fieldType.key, reader);
              const val = deserializeField(schema, fieldName, fieldType.value, reader);
              map.set(key, val);
            }
            return map;
          }
          return deserializeStruct(schema, fieldType, reader);
        } catch (error) {
          if (error instanceof BorshError) {
            error.addToFieldPath(fieldName);
          }
          throw error;
        }
      }
      function deserializeStruct(schema, classType, reader) {
        if (typeof classType.borshDeserialize === "function") {
          return classType.borshDeserialize(reader);
        }
        const structSchema = schema.get(classType);
        if (!structSchema) {
          throw new BorshError(`Class ${classType.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
          const result = {};
          for (const [fieldName, fieldType] of schema.get(classType).fields) {
            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
          }
          return new classType(result);
        }
        if (structSchema.kind === "enum") {
          const idx = reader.readU8();
          if (idx >= structSchema.values.length) {
            throw new BorshError(`Enum index: ${idx} is out of range`);
          }
          const [fieldName, fieldType] = structSchema.values[idx];
          const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
          return new classType({ [fieldName]: fieldValue });
        }
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
      }
      function deserialize(schema, classType, buffer, Reader = BinaryReader) {
        const reader = new Reader(buffer);
        const result = deserializeStruct(schema, classType, reader);
        if (reader.offset < buffer.length) {
          throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
        }
        return result;
      }
      exports.deserialize = deserialize;
      function deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {
        const reader = new Reader(buffer);
        return deserializeStruct(schema, classType, reader);
      }
      exports.deserializeUnchecked = deserializeUnchecked;
    }
  });

  // node_modules/@solana/buffer-layout/lib/Layout.js
  var require_Layout = __commonJS({
    "node_modules/@solana/buffer-layout/lib/Layout.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;
      exports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;
      var buffer_1 = require_buffer();
      function checkUint8Array(b) {
        if (!(b instanceof Uint8Array)) {
          throw new TypeError("b must be a Uint8Array");
        }
      }
      exports.checkUint8Array = checkUint8Array;
      function uint8ArrayToBuffer(b) {
        checkUint8Array(b);
        return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
      }
      exports.uint8ArrayToBuffer = uint8ArrayToBuffer;
      var Layout2 = class {
        constructor(span, property) {
          if (!Number.isInteger(span)) {
            throw new TypeError("span must be an integer");
          }
          this.span = span;
          this.property = property;
        }
        /** Function to create an Object into which decoded properties will
         * be written.
         *
         * Used only for layouts that {@link Layout#decode|decode} to Object
         * instances, which means:
         * * {@link Structure}
         * * {@link Union}
         * * {@link VariantLayout}
         * * {@link BitStructure}
         *
         * If left undefined the JavaScript representation of these layouts
         * will be Object instances.
         *
         * See {@link bindConstructorLayout}.
         */
        makeDestinationObject() {
          return {};
        }
        /**
         * Calculate the span of a specific instance of a layout.
         *
         * @param {Uint8Array} b - the buffer that contains an encoded instance.
         *
         * @param {Number} [offset] - the offset at which the encoded instance
         * starts.  If absent a zero offset is inferred.
         *
         * @return {Number} - the number of bytes covered by the layout
         * instance.  If this method is not overridden in a subclass the
         * definition-time constant {@link Layout#span|span} will be
         * returned.
         *
         * @throws {RangeError} - if the length of the value cannot be
         * determined.
         */
        getSpan(b, offset2) {
          if (0 > this.span) {
            throw new RangeError("indeterminate span");
          }
          return this.span;
        }
        /**
         * Replicate the layout using a new property.
         *
         * This function must be used to get a structurally-equivalent layout
         * with a different name since all {@link Layout} instances are
         * immutable.
         *
         * **NOTE** This is a shallow copy.  All fields except {@link
         * Layout#property|property} are strictly equal to the origin layout.
         *
         * @param {String} property - the value for {@link
         * Layout#property|property} in the replica.
         *
         * @returns {Layout} - the copy with {@link Layout#property|property}
         * set to `property`.
         */
        replicate(property) {
          const rv = Object.create(this.constructor.prototype);
          Object.assign(rv, this);
          rv.property = property;
          return rv;
        }
        /**
         * Create an object from layout properties and an array of values.
         *
         * **NOTE** This function returns `undefined` if invoked on a layout
         * that does not return its value as an Object.  Objects are
         * returned for things that are a {@link Structure}, which includes
         * {@link VariantLayout|variant layouts} if they are structures, and
         * excludes {@link Union}s.  If you want this feature for a union
         * you must use {@link Union.getVariant|getVariant} to select the
         * desired layout.
         *
         * @param {Array} values - an array of values that correspond to the
         * default order for properties.  As with {@link Layout#decode|decode}
         * layout elements that have no property name are skipped when
         * iterating over the array values.  Only the top-level properties are
         * assigned; arguments are not assigned to properties of contained
         * layouts.  Any unused values are ignored.
         *
         * @return {(Object|undefined)}
         */
        fromArray(values) {
          return void 0;
        }
      };
      exports.Layout = Layout2;
      function nameWithProperty2(name, lo) {
        if (lo.property) {
          return name + "[" + lo.property + "]";
        }
        return name;
      }
      exports.nameWithProperty = nameWithProperty2;
      function bindConstructorLayout(Class, layout) {
        if ("function" !== typeof Class) {
          throw new TypeError("Class must be constructor");
        }
        if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
          throw new Error("Class is already bound to a layout");
        }
        if (!(layout && layout instanceof Layout2)) {
          throw new TypeError("layout must be a Layout");
        }
        if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
          throw new Error("layout is already bound to a constructor");
        }
        Class.layout_ = layout;
        layout.boundConstructor_ = Class;
        layout.makeDestinationObject = (() => new Class());
        Object.defineProperty(Class.prototype, "encode", {
          value(b, offset2) {
            return layout.encode(this, b, offset2);
          },
          writable: true
        });
        Object.defineProperty(Class, "decode", {
          value(b, offset2) {
            return layout.decode(b, offset2);
          },
          writable: true
        });
      }
      exports.bindConstructorLayout = bindConstructorLayout;
      var ExternalLayout2 = class extends Layout2 {
        /**
         * Return `true` iff the external layout decodes to an unsigned
         * integer layout.
         *
         * In that case it can be used as the source of {@link
         * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
         * or as {@link UnionLayoutDiscriminator#layout|external union
         * discriminators}.
         *
         * @abstract
         */
        isCount() {
          throw new Error("ExternalLayout is abstract");
        }
      };
      exports.ExternalLayout = ExternalLayout2;
      var GreedyCount = class extends ExternalLayout2 {
        constructor(elementSpan = 1, property) {
          if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
            throw new TypeError("elementSpan must be a (positive) integer");
          }
          super(-1, property);
          this.elementSpan = elementSpan;
        }
        /** @override */
        isCount() {
          return true;
        }
        /** @override */
        decode(b, offset2 = 0) {
          checkUint8Array(b);
          const rem = b.length - offset2;
          return Math.floor(rem / this.elementSpan);
        }
        /** @override */
        encode(src, b, offset2) {
          return 0;
        }
      };
      exports.GreedyCount = GreedyCount;
      var OffsetLayout2 = class extends ExternalLayout2 {
        constructor(layout, offset2 = 0, property) {
          if (!(layout instanceof Layout2)) {
            throw new TypeError("layout must be a Layout");
          }
          if (!Number.isInteger(offset2)) {
            throw new TypeError("offset must be integer or undefined");
          }
          super(layout.span, property || layout.property);
          this.layout = layout;
          this.offset = offset2;
        }
        /** @override */
        isCount() {
          return this.layout instanceof UInt2 || this.layout instanceof UIntBE2;
        }
        /** @override */
        decode(b, offset2 = 0) {
          return this.layout.decode(b, offset2 + this.offset);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          return this.layout.encode(src, b, offset2 + this.offset);
        }
      };
      exports.OffsetLayout = OffsetLayout2;
      var UInt2 = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readUIntLE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeUIntLE(src, offset2, this.span);
          return this.span;
        }
      };
      exports.UInt = UInt2;
      var UIntBE2 = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readUIntBE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeUIntBE(src, offset2, this.span);
          return this.span;
        }
      };
      exports.UIntBE = UIntBE2;
      var Int = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readIntLE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeIntLE(src, offset2, this.span);
          return this.span;
        }
      };
      exports.Int = Int;
      var IntBE = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readIntBE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeIntBE(src, offset2, this.span);
          return this.span;
        }
      };
      exports.IntBE = IntBE;
      var V2E322 = Math.pow(2, 32);
      function divmodInt642(src) {
        const hi32 = Math.floor(src / V2E322);
        const lo32 = src - hi32 * V2E322;
        return { hi32, lo32 };
      }
      function roundedInt642(hi32, lo32) {
        return hi32 * V2E322 + lo32;
      }
      var NearUInt642 = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          const buffer = uint8ArrayToBuffer(b);
          const lo32 = buffer.readUInt32LE(offset2);
          const hi32 = buffer.readUInt32LE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          const split = divmodInt642(src);
          const buffer = uint8ArrayToBuffer(b);
          buffer.writeUInt32LE(split.lo32, offset2);
          buffer.writeUInt32LE(split.hi32, offset2 + 4);
          return 8;
        }
      };
      exports.NearUInt64 = NearUInt642;
      var NearUInt64BE = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          const buffer = uint8ArrayToBuffer(b);
          const hi32 = buffer.readUInt32BE(offset2);
          const lo32 = buffer.readUInt32BE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          const split = divmodInt642(src);
          const buffer = uint8ArrayToBuffer(b);
          buffer.writeUInt32BE(split.hi32, offset2);
          buffer.writeUInt32BE(split.lo32, offset2 + 4);
          return 8;
        }
      };
      exports.NearUInt64BE = NearUInt64BE;
      var NearInt642 = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          const buffer = uint8ArrayToBuffer(b);
          const lo32 = buffer.readUInt32LE(offset2);
          const hi32 = buffer.readInt32LE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          const split = divmodInt642(src);
          const buffer = uint8ArrayToBuffer(b);
          buffer.writeUInt32LE(split.lo32, offset2);
          buffer.writeInt32LE(split.hi32, offset2 + 4);
          return 8;
        }
      };
      exports.NearInt64 = NearInt642;
      var NearInt64BE = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          const buffer = uint8ArrayToBuffer(b);
          const hi32 = buffer.readInt32BE(offset2);
          const lo32 = buffer.readUInt32BE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          const split = divmodInt642(src);
          const buffer = uint8ArrayToBuffer(b);
          buffer.writeInt32BE(split.hi32, offset2);
          buffer.writeUInt32BE(split.lo32, offset2 + 4);
          return 8;
        }
      };
      exports.NearInt64BE = NearInt64BE;
      var Float = class extends Layout2 {
        constructor(property) {
          super(4, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readFloatLE(offset2);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeFloatLE(src, offset2);
          return 4;
        }
      };
      exports.Float = Float;
      var FloatBE = class extends Layout2 {
        constructor(property) {
          super(4, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readFloatBE(offset2);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeFloatBE(src, offset2);
          return 4;
        }
      };
      exports.FloatBE = FloatBE;
      var Double = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readDoubleLE(offset2);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeDoubleLE(src, offset2);
          return 8;
        }
      };
      exports.Double = Double;
      var DoubleBE = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readDoubleBE(offset2);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeDoubleBE(src, offset2);
          return 8;
        }
      };
      exports.DoubleBE = DoubleBE;
      var Sequence = class extends Layout2 {
        constructor(elementLayout, count, property) {
          if (!(elementLayout instanceof Layout2)) {
            throw new TypeError("elementLayout must be a Layout");
          }
          if (!(count instanceof ExternalLayout2 && count.isCount() || Number.isInteger(count) && 0 <= count)) {
            throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(count instanceof ExternalLayout2) && 0 < elementLayout.span) {
            span = count * elementLayout.span;
          }
          super(span, property);
          this.elementLayout = elementLayout;
          this.count = count;
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          let span = 0;
          let count = this.count;
          if (count instanceof ExternalLayout2) {
            count = count.decode(b, offset2);
          }
          if (0 < this.elementLayout.span) {
            span = count * this.elementLayout.span;
          } else {
            let idx = 0;
            while (idx < count) {
              span += this.elementLayout.getSpan(b, offset2 + span);
              ++idx;
            }
          }
          return span;
        }
        /** @override */
        decode(b, offset2 = 0) {
          const rv = [];
          let i = 0;
          let count = this.count;
          if (count instanceof ExternalLayout2) {
            count = count.decode(b, offset2);
          }
          while (i < count) {
            rv.push(this.elementLayout.decode(b, offset2));
            offset2 += this.elementLayout.getSpan(b, offset2);
            i += 1;
          }
          return rv;
        }
        /** Implement {@link Layout#encode|encode} for {@link Sequence}.
         *
         * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
         * the unused space in the buffer is left unchanged.  If `src` is
         * longer than {@link Sequence#count|count} the unneeded elements are
         * ignored.
         *
         * **NOTE** If {@link Layout#count|count} is an instance of {@link
         * ExternalLayout} then the length of `src` will be encoded as the
         * count after `src` is encoded. */
        encode(src, b, offset2 = 0) {
          const elo = this.elementLayout;
          const span = src.reduce((span2, v) => {
            return span2 + elo.encode(v, b, offset2 + span2);
          }, 0);
          if (this.count instanceof ExternalLayout2) {
            this.count.encode(src.length, b, offset2);
          }
          return span;
        }
      };
      exports.Sequence = Sequence;
      var Structure2 = class extends Layout2 {
        constructor(fields, property, decodePrefixes) {
          if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout2, true))) {
            throw new TypeError("fields must be array of Layout instances");
          }
          if ("boolean" === typeof property && void 0 === decodePrefixes) {
            decodePrefixes = property;
            property = void 0;
          }
          for (const fd of fields) {
            if (0 > fd.span && void 0 === fd.property) {
              throw new Error("fields cannot contain unnamed variable-length layout");
            }
          }
          let span = -1;
          try {
            span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
          } catch (e) {
          }
          super(span, property);
          this.fields = fields;
          this.decodePrefixes = !!decodePrefixes;
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          let span = 0;
          try {
            span = this.fields.reduce((span2, fd) => {
              const fsp = fd.getSpan(b, offset2);
              offset2 += fsp;
              return span2 + fsp;
            }, 0);
          } catch (e) {
            throw new RangeError("indeterminate span");
          }
          return span;
        }
        /** @override */
        decode(b, offset2 = 0) {
          checkUint8Array(b);
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(b, offset2);
            }
            offset2 += fd.getSpan(b, offset2);
            if (this.decodePrefixes && b.length === offset2) {
              break;
            }
          }
          return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link Structure}.
         *
         * If `src` is missing a property for a member with a defined {@link
         * Layout#property|property} the corresponding region of the buffer is
         * left unmodified. */
        encode(src, b, offset2 = 0) {
          const firstOffset = offset2;
          let lastOffset = 0;
          let lastWrote = 0;
          for (const fd of this.fields) {
            let span = fd.span;
            lastWrote = 0 < span ? span : 0;
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                lastWrote = fd.encode(fv, b, offset2);
                if (0 > span) {
                  span = fd.getSpan(b, offset2);
                }
              }
            }
            lastOffset = offset2;
            offset2 += span;
          }
          return lastOffset + lastWrote - firstOffset;
        }
        /** @override */
        fromArray(values) {
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property && 0 < values.length) {
              dest[fd.property] = values.shift();
            }
          }
          return dest;
        }
        /**
         * Get access to the layout of a given property.
         *
         * @param {String} property - the structure member of interest.
         *
         * @return {Layout} - the layout associated with `property`, or
         * undefined if there is no such property.
         */
        layoutFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
          return void 0;
        }
        /**
         * Get the offset of a structure member.
         *
         * @param {String} property - the structure member of interest.
         *
         * @return {Number} - the offset in bytes to the start of `property`
         * within the structure, or undefined if `property` is not a field
         * within the structure.  If the property is a member but follows a
         * variable-length structure member a negative number will be
         * returned.
         */
        offsetOf(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          let offset2 = 0;
          for (const fd of this.fields) {
            if (fd.property === property) {
              return offset2;
            }
            if (0 > fd.span) {
              offset2 = -1;
            } else if (0 <= offset2) {
              offset2 += fd.span;
            }
          }
          return void 0;
        }
      };
      exports.Structure = Structure2;
      var UnionDiscriminator2 = class {
        constructor(property) {
          this.property = property;
        }
        /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
         *
         * The implementation of this method need not reference the buffer if
         * variant information is available through other means. */
        decode(b, offset2) {
          throw new Error("UnionDiscriminator is abstract");
        }
        /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
         *
         * The implementation of this method need not store the value if
         * variant information is maintained through other means. */
        encode(src, b, offset2) {
          throw new Error("UnionDiscriminator is abstract");
        }
      };
      exports.UnionDiscriminator = UnionDiscriminator2;
      var UnionLayoutDiscriminator2 = class extends UnionDiscriminator2 {
        constructor(layout, property) {
          if (!(layout instanceof ExternalLayout2 && layout.isCount())) {
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
          }
          super(property || layout.property || "variant");
          this.layout = layout;
        }
        /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
        decode(b, offset2) {
          return this.layout.decode(b, offset2);
        }
        /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
        encode(src, b, offset2) {
          return this.layout.encode(src, b, offset2);
        }
      };
      exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator2;
      var Union2 = class extends Layout2 {
        constructor(discr, defaultLayout, property) {
          let discriminator;
          if (discr instanceof UInt2 || discr instanceof UIntBE2) {
            discriminator = new UnionLayoutDiscriminator2(new OffsetLayout2(discr));
          } else if (discr instanceof ExternalLayout2 && discr.isCount()) {
            discriminator = new UnionLayoutDiscriminator2(discr);
          } else if (!(discr instanceof UnionDiscriminator2)) {
            throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
          } else {
            discriminator = discr;
          }
          if (void 0 === defaultLayout) {
            defaultLayout = null;
          }
          if (!(null === defaultLayout || defaultLayout instanceof Layout2)) {
            throw new TypeError("defaultLayout must be null or a Layout");
          }
          if (null !== defaultLayout) {
            if (0 > defaultLayout.span) {
              throw new Error("defaultLayout must have constant span");
            }
            if (void 0 === defaultLayout.property) {
              defaultLayout = defaultLayout.replicate("content");
            }
          }
          let span = -1;
          if (defaultLayout) {
            span = defaultLayout.span;
            if (0 <= span && (discr instanceof UInt2 || discr instanceof UIntBE2)) {
              span += discriminator.layout.span;
            }
          }
          super(span, property);
          this.discriminator = discriminator;
          this.usesPrefixDiscriminator = discr instanceof UInt2 || discr instanceof UIntBE2;
          this.defaultLayout = defaultLayout;
          this.registry = {};
          let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
          this.getSourceVariant = function(src) {
            return boundGetSourceVariant(src);
          };
          this.configGetSourceVariant = function(gsv) {
            boundGetSourceVariant = gsv.bind(this);
          };
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          const vlo = this.getVariant(b, offset2);
          if (!vlo) {
            throw new Error("unable to determine span for unrecognized variant");
          }
          return vlo.getSpan(b, offset2);
        }
        /**
         * Method to infer a registered Union variant compatible with `src`.
         *
         * The first satisfied rule in the following sequence defines the
         * return value:
         * * If `src` has properties matching the Union discriminator and
         *   the default layout, `undefined` is returned regardless of the
         *   value of the discriminator property (this ensures the default
         *   layout will be used);
         * * If `src` has a property matching the Union discriminator, the
         *   value of the discriminator identifies a registered variant, and
         *   either (a) the variant has no layout, or (b) `src` has the
         *   variant's property, then the variant is returned (because the
         *   source satisfies the constraints of the variant it identifies);
         * * If `src` does not have a property matching the Union
         *   discriminator, but does have a property matching a registered
         *   variant, then the variant is returned (because the source
         *   matches a variant without an explicit conflict);
         * * An error is thrown (because we either can't identify a variant,
         *   or we were explicitly told the variant but can't satisfy it).
         *
         * @param {Object} src - an object presumed to be compatible with
         * the content of the Union.
         *
         * @return {(undefined|VariantLayout)} - as described above.
         *
         * @throws {Error} - if `src` cannot be associated with a default or
         * registered variant.
         */
        defaultGetSourceVariant(src) {
          if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
              return void 0;
            }
            const vlo = this.registry[src[this.discriminator.property]];
            if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {
              return vlo;
            }
          } else {
            for (const tag in this.registry) {
              const vlo = this.registry[tag];
              if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
                return vlo;
              }
            }
          }
          throw new Error("unable to infer src variant");
        }
        /** Implement {@link Layout#decode|decode} for {@link Union}.
         *
         * If the variant is {@link Union#addVariant|registered} the return
         * value is an instance of that variant, with no explicit
         * discriminator.  Otherwise the {@link Union#defaultLayout|default
         * layout} is used to decode the content. */
        decode(b, offset2 = 0) {
          let dest;
          const dlo = this.discriminator;
          const discr = dlo.decode(b, offset2);
          const clo = this.registry[discr];
          if (void 0 === clo) {
            const defaultLayout = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dest = this.makeDestinationObject();
            dest[dlo.property] = discr;
            dest[defaultLayout.property] = defaultLayout.decode(b, offset2 + contentOffset);
          } else {
            dest = clo.decode(b, offset2);
          }
          return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link Union}.
         *
         * This API assumes the `src` object is consistent with the union's
         * {@link Union#defaultLayout|default layout}.  To encode variants
         * use the appropriate variant-specific {@link VariantLayout#encode}
         * method. */
        encode(src, b, offset2 = 0) {
          const vlo = this.getSourceVariant(src);
          if (void 0 === vlo) {
            const dlo = this.discriminator;
            const clo = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dlo.encode(src[dlo.property], b, offset2);
            return contentOffset + clo.encode(src[clo.property], b, offset2 + contentOffset);
          }
          return vlo.encode(src, b, offset2);
        }
        /** Register a new variant structure within a union.  The newly
         * created variant is returned.
         *
         * @param {Number} variant - initializer for {@link
         * VariantLayout#variant|variant}.
         *
         * @param {Layout} layout - initializer for {@link
         * VariantLayout#layout|layout}.
         *
         * @param {String} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {VariantLayout} */
        addVariant(variant, layout, property) {
          const rv = new VariantLayout2(this, variant, layout, property);
          this.registry[variant] = rv;
          return rv;
        }
        /**
         * Get the layout associated with a registered variant.
         *
         * If `vb` does not produce a registered variant the function returns
         * `undefined`.
         *
         * @param {(Number|Uint8Array)} vb - either the variant number, or a
         * buffer from which the discriminator is to be read.
         *
         * @param {Number} offset - offset into `vb` for the start of the
         * union.  Used only when `vb` is an instance of {Uint8Array}.
         *
         * @return {({VariantLayout}|undefined)}
         */
        getVariant(vb, offset2 = 0) {
          let variant;
          if (vb instanceof Uint8Array) {
            variant = this.discriminator.decode(vb, offset2);
          } else {
            variant = vb;
          }
          return this.registry[variant];
        }
      };
      exports.Union = Union2;
      var VariantLayout2 = class extends Layout2 {
        constructor(union2, variant, layout, property) {
          if (!(union2 instanceof Union2)) {
            throw new TypeError("union must be a Union");
          }
          if (!Number.isInteger(variant) || 0 > variant) {
            throw new TypeError("variant must be a (non-negative) integer");
          }
          if ("string" === typeof layout && void 0 === property) {
            property = layout;
            layout = null;
          }
          if (layout) {
            if (!(layout instanceof Layout2)) {
              throw new TypeError("layout must be a Layout");
            }
            if (null !== union2.defaultLayout && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
              throw new Error("variant span exceeds span of containing union");
            }
            if ("string" !== typeof property) {
              throw new TypeError("variant must have a String property");
            }
          }
          let span = union2.span;
          if (0 > union2.span) {
            span = layout ? layout.span : 0;
            if (0 <= span && union2.usesPrefixDiscriminator) {
              span += union2.discriminator.layout.span;
            }
          }
          super(span, property);
          this.union = union2;
          this.variant = variant;
          this.layout = layout || null;
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          let span = 0;
          if (this.layout) {
            span = this.layout.getSpan(b, offset2 + contentOffset);
          }
          return contentOffset + span;
        }
        /** @override */
        decode(b, offset2 = 0) {
          const dest = this.makeDestinationObject();
          if (this !== this.union.getVariant(b, offset2)) {
            throw new Error("variant mismatch");
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout) {
            dest[this.property] = this.layout.decode(b, offset2 + contentOffset);
          } else if (this.property) {
            dest[this.property] = true;
          } else if (this.union.usesPrefixDiscriminator) {
            dest[this.union.discriminator.property] = this.variant;
          }
          return dest;
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {
            throw new TypeError("variant lacks property " + this.property);
          }
          this.union.discriminator.encode(this.variant, b, offset2);
          let span = contentOffset;
          if (this.layout) {
            this.layout.encode(src[this.property], b, offset2 + contentOffset);
            span += this.layout.getSpan(b, offset2 + contentOffset);
            if (0 <= this.union.span && span > this.union.span) {
              throw new Error("encoded variant overruns containing union");
            }
          }
          return span;
        }
        /** Delegate {@link Layout#fromArray|fromArray} to {@link
         * VariantLayout#layout|layout}. */
        fromArray(values) {
          if (this.layout) {
            return this.layout.fromArray(values);
          }
          return void 0;
        }
      };
      exports.VariantLayout = VariantLayout2;
      function fixBitwiseResult(v) {
        if (0 > v) {
          v += 4294967296;
        }
        return v;
      }
      var BitStructure = class extends Layout2 {
        constructor(word, msb, property) {
          if (!(word instanceof UInt2 || word instanceof UIntBE2)) {
            throw new TypeError("word must be a UInt or UIntBE layout");
          }
          if ("string" === typeof msb && void 0 === property) {
            property = msb;
            msb = false;
          }
          if (4 < word.span) {
            throw new RangeError("word cannot exceed 32 bits");
          }
          super(word.span, property);
          this.word = word;
          this.msb = !!msb;
          this.fields = [];
          let value = 0;
          this._packedSetValue = function(v) {
            value = fixBitwiseResult(v);
            return this;
          };
          this._packedGetValue = function() {
            return value;
          };
        }
        /** @override */
        decode(b, offset2 = 0) {
          const dest = this.makeDestinationObject();
          const value = this.word.decode(b, offset2);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(b);
            }
          }
          return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
         *
         * If `src` is missing a property for a member with a defined {@link
         * Layout#property|property} the corresponding region of the packed
         * value is left unmodified.  Unused bits are also left unmodified. */
        encode(src, b, offset2 = 0) {
          const value = this.word.decode(b, offset2);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                fd.encode(fv);
              }
            }
          }
          return this.word.encode(this._packedGetValue(), b, offset2);
        }
        /** Register a new bitfield with a containing bit structure.  The
         * resulting bitfield is returned.
         *
         * @param {Number} bits - initializer for {@link BitField#bits|bits}.
         *
         * @param {string} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {BitField} */
        addField(bits, property) {
          const bf = new BitField(this, bits, property);
          this.fields.push(bf);
          return bf;
        }
        /** As with {@link BitStructure#addField|addField} for single-bit
         * fields with `boolean` value representation.
         *
         * @param {string} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {Boolean} */
        // `Boolean` conflicts with the native primitive type
        // eslint-disable-next-line @typescript-eslint/ban-types
        addBoolean(property) {
          const bf = new Boolean2(this, property);
          this.fields.push(bf);
          return bf;
        }
        /**
         * Get access to the bit field for a given property.
         *
         * @param {String} property - the bit field of interest.
         *
         * @return {BitField} - the field associated with `property`, or
         * undefined if there is no such property.
         */
        fieldFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
          return void 0;
        }
      };
      exports.BitStructure = BitStructure;
      var BitField = class {
        constructor(container, bits, property) {
          if (!(container instanceof BitStructure)) {
            throw new TypeError("container must be a BitStructure");
          }
          if (!Number.isInteger(bits) || 0 >= bits) {
            throw new TypeError("bits must be positive integer");
          }
          const totalBits = 8 * container.span;
          const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
          if (bits + usedBits > totalBits) {
            throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
          }
          this.container = container;
          this.bits = bits;
          this.valueMask = (1 << bits) - 1;
          if (32 === bits) {
            this.valueMask = 4294967295;
          }
          this.start = usedBits;
          if (this.container.msb) {
            this.start = totalBits - usedBits - bits;
          }
          this.wordMask = fixBitwiseResult(this.valueMask << this.start);
          this.property = property;
        }
        /** Store a value into the corresponding subsequence of the containing
         * bit field. */
        decode(b, offset2) {
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult(word & this.wordMask);
          const value = wordValue >>> this.start;
          return value;
        }
        /** Store a value into the corresponding subsequence of the containing
         * bit field.
         *
         * **NOTE** This is not a specialization of {@link
         * Layout#encode|Layout.encode} and there is no return value. */
        encode(value) {
          if ("number" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
            throw new TypeError(nameWithProperty2("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
          }
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult(value << this.start);
          this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
        }
      };
      exports.BitField = BitField;
      var Boolean2 = class extends BitField {
        constructor(container, property) {
          super(container, 1, property);
        }
        /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
         *
         * @returns {boolean} */
        decode(b, offset2) {
          return !!super.decode(b, offset2);
        }
        /** @override */
        encode(value) {
          if ("boolean" === typeof value) {
            value = +value;
          }
          super.encode(value);
        }
      };
      exports.Boolean = Boolean2;
      var Blob2 = class extends Layout2 {
        constructor(length, property) {
          if (!(length instanceof ExternalLayout2 && length.isCount() || Number.isInteger(length) && 0 <= length)) {
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(length instanceof ExternalLayout2)) {
            span = length;
          }
          super(span, property);
          this.length = length;
        }
        /** @override */
        getSpan(b, offset2) {
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b, offset2);
          }
          return span;
        }
        /** @override */
        decode(b, offset2 = 0) {
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b, offset2);
          }
          return uint8ArrayToBuffer(b).slice(offset2, offset2 + span);
        }
        /** Implement {@link Layout#encode|encode} for {@link Blob}.
         *
         * **NOTE** If {@link Layout#count|count} is an instance of {@link
         * ExternalLayout} then the length of `src` will be encoded as the
         * count after `src` is encoded. */
        encode(src, b, offset2) {
          let span = this.length;
          if (this.length instanceof ExternalLayout2) {
            span = src.length;
          }
          if (!(src instanceof Uint8Array && span === src.length)) {
            throw new TypeError(nameWithProperty2("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
          }
          if (offset2 + span > b.length) {
            throw new RangeError("encoding overruns Uint8Array");
          }
          const srcBuffer = uint8ArrayToBuffer(src);
          uint8ArrayToBuffer(b).write(srcBuffer.toString("hex"), offset2, span, "hex");
          if (this.length instanceof ExternalLayout2) {
            this.length.encode(span, b, offset2);
          }
          return span;
        }
      };
      exports.Blob = Blob2;
      var CString = class extends Layout2 {
        constructor(property) {
          super(-1, property);
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          checkUint8Array(b);
          let idx = offset2;
          while (idx < b.length && 0 !== b[idx]) {
            idx += 1;
          }
          return 1 + idx - offset2;
        }
        /** @override */
        decode(b, offset2 = 0) {
          const span = this.getSpan(b, offset2);
          return uint8ArrayToBuffer(b).slice(offset2, offset2 + span - 1).toString("utf-8");
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          if ("string" !== typeof src) {
            src = String(src);
          }
          const srcb = buffer_1.Buffer.from(src, "utf8");
          const span = srcb.length;
          if (offset2 + span > b.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          const buffer = uint8ArrayToBuffer(b);
          srcb.copy(buffer, offset2);
          buffer[offset2 + span] = 0;
          return span + 1;
        }
      };
      exports.CString = CString;
      var UTF8 = class extends Layout2 {
        constructor(maxSpan, property) {
          if ("string" === typeof maxSpan && void 0 === property) {
            property = maxSpan;
            maxSpan = void 0;
          }
          if (void 0 === maxSpan) {
            maxSpan = -1;
          } else if (!Number.isInteger(maxSpan)) {
            throw new TypeError("maxSpan must be an integer");
          }
          super(-1, property);
          this.maxSpan = maxSpan;
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          checkUint8Array(b);
          return b.length - offset2;
        }
        /** @override */
        decode(b, offset2 = 0) {
          const span = this.getSpan(b, offset2);
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          return uint8ArrayToBuffer(b).slice(offset2, offset2 + span).toString("utf-8");
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          if ("string" !== typeof src) {
            src = String(src);
          }
          const srcb = buffer_1.Buffer.from(src, "utf8");
          const span = srcb.length;
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          if (offset2 + span > b.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          srcb.copy(uint8ArrayToBuffer(b), offset2);
          return span;
        }
      };
      exports.UTF8 = UTF8;
      var Constant = class extends Layout2 {
        constructor(value, property) {
          super(0, property);
          this.value = value;
        }
        /** @override */
        decode(b, offset2) {
          return this.value;
        }
        /** @override */
        encode(src, b, offset2) {
          return 0;
        }
      };
      exports.Constant = Constant;
      exports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));
      exports.offset = ((layout, offset2, property) => new OffsetLayout2(layout, offset2, property));
      exports.u8 = ((property) => new UInt2(1, property));
      exports.u16 = ((property) => new UInt2(2, property));
      exports.u24 = ((property) => new UInt2(3, property));
      exports.u32 = ((property) => new UInt2(4, property));
      exports.u40 = ((property) => new UInt2(5, property));
      exports.u48 = ((property) => new UInt2(6, property));
      exports.nu64 = ((property) => new NearUInt642(property));
      exports.u16be = ((property) => new UIntBE2(2, property));
      exports.u24be = ((property) => new UIntBE2(3, property));
      exports.u32be = ((property) => new UIntBE2(4, property));
      exports.u40be = ((property) => new UIntBE2(5, property));
      exports.u48be = ((property) => new UIntBE2(6, property));
      exports.nu64be = ((property) => new NearUInt64BE(property));
      exports.s8 = ((property) => new Int(1, property));
      exports.s16 = ((property) => new Int(2, property));
      exports.s24 = ((property) => new Int(3, property));
      exports.s32 = ((property) => new Int(4, property));
      exports.s40 = ((property) => new Int(5, property));
      exports.s48 = ((property) => new Int(6, property));
      exports.ns64 = ((property) => new NearInt642(property));
      exports.s16be = ((property) => new IntBE(2, property));
      exports.s24be = ((property) => new IntBE(3, property));
      exports.s32be = ((property) => new IntBE(4, property));
      exports.s40be = ((property) => new IntBE(5, property));
      exports.s48be = ((property) => new IntBE(6, property));
      exports.ns64be = ((property) => new NearInt64BE(property));
      exports.f32 = ((property) => new Float(property));
      exports.f32be = ((property) => new FloatBE(property));
      exports.f64 = ((property) => new Double(property));
      exports.f64be = ((property) => new DoubleBE(property));
      exports.struct = ((fields, property, decodePrefixes) => new Structure2(fields, property, decodePrefixes));
      exports.bits = ((word, msb, property) => new BitStructure(word, msb, property));
      exports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));
      exports.union = ((discr, defaultLayout, property) => new Union2(discr, defaultLayout, property));
      exports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator2(layout, property));
      exports.blob = ((length, property) => new Blob2(length, property));
      exports.cstr = ((property) => new CString(property));
      exports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));
      exports.constant = ((value, property) => new Constant(value, property));
    }
  });

  // node_modules/bigint-buffer/dist/browser.js
  var require_browser = __commonJS({
    "node_modules/bigint-buffer/dist/browser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var converter;
      function toBigIntLE(buf) {
        {
          const reversed = Buffer.from(buf);
          reversed.reverse();
          const hex2 = reversed.toString("hex");
          if (hex2.length === 0) {
            return BigInt(0);
          }
          return BigInt(`0x${hex2}`);
        }
        return converter.toBigInt(buf, false);
      }
      exports.toBigIntLE = toBigIntLE;
      function toBigIntBE(buf) {
        {
          const hex2 = buf.toString("hex");
          if (hex2.length === 0) {
            return BigInt(0);
          }
          return BigInt(`0x${hex2}`);
        }
        return converter.toBigInt(buf, true);
      }
      exports.toBigIntBE = toBigIntBE;
      function toBufferLE(num, width) {
        {
          const hex2 = num.toString(16);
          const buffer = Buffer.from(hex2.padStart(width * 2, "0").slice(0, width * 2), "hex");
          buffer.reverse();
          return buffer;
        }
        return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
      }
      exports.toBufferLE = toBufferLE;
      function toBufferBE(num, width) {
        {
          const hex2 = num.toString(16);
          return Buffer.from(hex2.padStart(width * 2, "0").slice(0, width * 2), "hex");
        }
        return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
      }
      exports.toBufferBE = toBufferBE;
    }
  });

  // node_modules/@solana/web3.js/node_modules/superstruct/dist/index.cjs
  var require_dist = __commonJS({
    "node_modules/@solana/web3.js/node_modules/superstruct/dist/index.cjs"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.Superstruct = {}));
      })(exports, (function(exports2) {
        "use strict";
        class StructError2 extends TypeError {
          constructor(failure, failures) {
            let cached;
            const { message, explanation, ...rest } = failure;
            const { path } = failure;
            const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
            super(explanation ?? msg);
            if (explanation != null)
              this.cause = msg;
            Object.assign(this, rest);
            this.name = this.constructor.name;
            this.failures = () => {
              return cached ?? (cached = [failure, ...failures()]);
            };
          }
        }
        function isIterable2(x) {
          return isObject2(x) && typeof x[Symbol.iterator] === "function";
        }
        function isObject2(x) {
          return typeof x === "object" && x != null;
        }
        function isNonArrayObject(x) {
          return isObject2(x) && !Array.isArray(x);
        }
        function isPlainObject(x) {
          if (Object.prototype.toString.call(x) !== "[object Object]") {
            return false;
          }
          const prototype = Object.getPrototypeOf(x);
          return prototype === null || prototype === Object.prototype;
        }
        function print2(value) {
          if (typeof value === "symbol") {
            return value.toString();
          }
          return typeof value === "string" ? JSON.stringify(value) : `${value}`;
        }
        function shiftIterator2(input) {
          const { done, value } = input.next();
          return done ? void 0 : value;
        }
        function toFailure2(result, context, struct4, value) {
          if (result === true) {
            return;
          } else if (result === false) {
            result = {};
          } else if (typeof result === "string") {
            result = { message: result };
          }
          const { path, branch } = context;
          const { type: type3 } = struct4;
          const { refinement, message = `Expected a value of type \`${type3}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print2(value)}\`` } = result;
          return {
            value,
            type: type3,
            refinement,
            key: path[path.length - 1],
            path,
            branch,
            ...result,
            message
          };
        }
        function* toFailures2(result, context, struct4, value) {
          if (!isIterable2(result)) {
            result = [result];
          }
          for (const r of result) {
            const failure = toFailure2(r, context, struct4, value);
            if (failure) {
              yield failure;
            }
          }
        }
        function* run2(value, struct4, options = {}) {
          const { path = [], branch = [value], coerce: coerce3 = false, mask: mask3 = false } = options;
          const ctx = { path, branch, mask: mask3 };
          if (coerce3) {
            value = struct4.coercer(value, ctx);
          }
          let status = "valid";
          for (const failure of struct4.validator(value, ctx)) {
            failure.explanation = options.message;
            status = "not_valid";
            yield [failure, void 0];
          }
          for (let [k, v, s] of struct4.entries(value, ctx)) {
            const ts = run2(v, s, {
              path: k === void 0 ? path : [...path, k],
              branch: k === void 0 ? branch : [...branch, v],
              coerce: coerce3,
              mask: mask3,
              message: options.message
            });
            for (const t of ts) {
              if (t[0]) {
                status = t[0].refinement != null ? "not_refined" : "not_valid";
                yield [t[0], void 0];
              } else if (coerce3) {
                v = t[1];
                if (k === void 0) {
                  value = v;
                } else if (value instanceof Map) {
                  value.set(k, v);
                } else if (value instanceof Set) {
                  value.add(v);
                } else if (isObject2(value)) {
                  if (v !== void 0 || k in value)
                    value[k] = v;
                }
              }
            }
          }
          if (status !== "not_valid") {
            for (const failure of struct4.refiner(value, ctx)) {
              failure.explanation = options.message;
              status = "not_refined";
              yield [failure, void 0];
            }
          }
          if (status === "valid") {
            yield [void 0, value];
          }
        }
        class Struct2 {
          constructor(props) {
            const { type: type3, schema, validator, refiner, coercer = (value) => value, entries = function* () {
            } } = props;
            this.type = type3;
            this.schema = schema;
            this.entries = entries;
            this.coercer = coercer;
            if (validator) {
              this.validator = (value, context) => {
                const result = validator(value, context);
                return toFailures2(result, context, this, value);
              };
            } else {
              this.validator = () => [];
            }
            if (refiner) {
              this.refiner = (value, context) => {
                const result = refiner(value, context);
                return toFailures2(result, context, this, value);
              };
            } else {
              this.refiner = () => [];
            }
          }
          /**
           * Assert that a value passes the struct's validation, throwing if it doesn't.
           */
          assert(value, message) {
            return assert2(value, this, message);
          }
          /**
           * Create a value with the struct's coercion logic, then validate it.
           */
          create(value, message) {
            return create2(value, this, message);
          }
          /**
           * Check if a value passes the struct's validation.
           */
          is(value) {
            return is2(value, this);
          }
          /**
           * Mask a value, coercing and validating it, but returning only the subset of
           * properties defined by the struct's schema. Masking applies recursively to
           * props of `object` structs only.
           */
          mask(value, message) {
            return mask2(value, this, message);
          }
          /**
           * Validate a value with the struct's validation logic, returning a tuple
           * representing the result.
           *
           * You may optionally pass `true` for the `coerce` argument to coerce
           * the value before attempting to validate it. If you do, the result will
           * contain the coerced result when successful. Also, `mask` will turn on
           * masking of the unknown `object` props recursively if passed.
           */
          validate(value, options = {}) {
            return validate3(value, this, options);
          }
        }
        function assert2(value, struct4, message) {
          const result = validate3(value, struct4, { message });
          if (result[0]) {
            throw result[0];
          }
        }
        function create2(value, struct4, message) {
          const result = validate3(value, struct4, { coerce: true, message });
          if (result[0]) {
            throw result[0];
          } else {
            return result[1];
          }
        }
        function mask2(value, struct4, message) {
          const result = validate3(value, struct4, { coerce: true, mask: true, message });
          if (result[0]) {
            throw result[0];
          } else {
            return result[1];
          }
        }
        function is2(value, struct4) {
          const result = validate3(value, struct4);
          return !result[0];
        }
        function validate3(value, struct4, options = {}) {
          const tuples = run2(value, struct4, options);
          const tuple2 = shiftIterator2(tuples);
          if (tuple2[0]) {
            const error = new StructError2(tuple2[0], function* () {
              for (const t of tuples) {
                if (t[0]) {
                  yield t[0];
                }
              }
            });
            return [error, void 0];
          } else {
            const v = tuple2[1];
            return [void 0, v];
          }
        }
        function assign2(...Structs) {
          const isType = Structs[0].type === "type";
          const schemas = Structs.map((s) => s.schema);
          const schema = Object.assign({}, ...schemas);
          return isType ? type2(schema) : object(schema);
        }
        function define3(name, validator) {
          return new Struct2({ type: name, schema: null, validator });
        }
        function deprecated(struct4, log) {
          return new Struct2({
            ...struct4,
            refiner: (value, ctx) => value === void 0 || struct4.refiner(value, ctx),
            validator(value, ctx) {
              if (value === void 0) {
                return true;
              } else {
                log(value, ctx);
                return struct4.validator(value, ctx);
              }
            }
          });
        }
        function dynamic(fn) {
          return new Struct2({
            type: "dynamic",
            schema: null,
            *entries(value, ctx) {
              const struct4 = fn(value, ctx);
              yield* struct4.entries(value, ctx);
            },
            validator(value, ctx) {
              const struct4 = fn(value, ctx);
              return struct4.validator(value, ctx);
            },
            coercer(value, ctx) {
              const struct4 = fn(value, ctx);
              return struct4.coercer(value, ctx);
            },
            refiner(value, ctx) {
              const struct4 = fn(value, ctx);
              return struct4.refiner(value, ctx);
            }
          });
        }
        function lazy(fn) {
          let struct4;
          return new Struct2({
            type: "lazy",
            schema: null,
            *entries(value, ctx) {
              struct4 ?? (struct4 = fn());
              yield* struct4.entries(value, ctx);
            },
            validator(value, ctx) {
              struct4 ?? (struct4 = fn());
              return struct4.validator(value, ctx);
            },
            coercer(value, ctx) {
              struct4 ?? (struct4 = fn());
              return struct4.coercer(value, ctx);
            },
            refiner(value, ctx) {
              struct4 ?? (struct4 = fn());
              return struct4.refiner(value, ctx);
            }
          });
        }
        function omit(struct4, keys) {
          const { schema } = struct4;
          const subschema = { ...schema };
          for (const key of keys) {
            delete subschema[key];
          }
          switch (struct4.type) {
            case "type":
              return type2(subschema);
            default:
              return object(subschema);
          }
        }
        function partial(struct4) {
          const isStruct = struct4 instanceof Struct2;
          const schema = isStruct ? { ...struct4.schema } : { ...struct4 };
          for (const key in schema) {
            schema[key] = optional2(schema[key]);
          }
          if (isStruct && struct4.type === "type") {
            return type2(schema);
          }
          return object(schema);
        }
        function pick(struct4, keys) {
          const { schema } = struct4;
          const subschema = {};
          for (const key of keys) {
            subschema[key] = schema[key];
          }
          switch (struct4.type) {
            case "type":
              return type2(subschema);
            default:
              return object(subschema);
          }
        }
        function struct3(name, validator) {
          console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`.");
          return define3(name, validator);
        }
        function any2() {
          return define3("any", () => true);
        }
        function array3(Element) {
          return new Struct2({
            type: "array",
            schema: Element,
            *entries(value) {
              if (Element && Array.isArray(value)) {
                for (const [i, v] of value.entries()) {
                  yield [i, v, Element];
                }
              }
            },
            coercer(value) {
              return Array.isArray(value) ? value.slice() : value;
            },
            validator(value) {
              return Array.isArray(value) || `Expected an array value, but received: ${print2(value)}`;
            }
          });
        }
        function bigint() {
          return define3("bigint", (value) => {
            return typeof value === "bigint";
          });
        }
        function boolean2() {
          return define3("boolean", (value) => {
            return typeof value === "boolean";
          });
        }
        function date() {
          return define3("date", (value) => {
            return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \`Date\` object, but received: ${print2(value)}`;
          });
        }
        function enums(values) {
          const schema = {};
          const description = values.map((v) => print2(v)).join();
          for (const key of values) {
            schema[key] = key;
          }
          return new Struct2({
            type: "enums",
            schema,
            validator(value) {
              return values.includes(value) || `Expected one of \`${description}\`, but received: ${print2(value)}`;
            }
          });
        }
        function func() {
          return define3("func", (value) => {
            return typeof value === "function" || `Expected a function, but received: ${print2(value)}`;
          });
        }
        function instance(Class) {
          return define3("instance", (value) => {
            return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print2(value)}`;
          });
        }
        function integer() {
          return define3("integer", (value) => {
            return typeof value === "number" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print2(value)}`;
          });
        }
        function intersection(Structs) {
          return new Struct2({
            type: "intersection",
            schema: null,
            *entries(value, ctx) {
              for (const S of Structs) {
                yield* S.entries(value, ctx);
              }
            },
            *validator(value, ctx) {
              for (const S of Structs) {
                yield* S.validator(value, ctx);
              }
            },
            *refiner(value, ctx) {
              for (const S of Structs) {
                yield* S.refiner(value, ctx);
              }
            }
          });
        }
        function literal2(constant) {
          const description = print2(constant);
          const t = typeof constant;
          return new Struct2({
            type: "literal",
            schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
            validator(value) {
              return value === constant || `Expected the literal \`${description}\`, but received: ${print2(value)}`;
            }
          });
        }
        function map(Key, Value) {
          return new Struct2({
            type: "map",
            schema: null,
            *entries(value) {
              if (Key && Value && value instanceof Map) {
                for (const [k, v] of value.entries()) {
                  yield [k, k, Key];
                  yield [k, v, Value];
                }
              }
            },
            coercer(value) {
              return value instanceof Map ? new Map(value) : value;
            },
            validator(value) {
              return value instanceof Map || `Expected a \`Map\` object, but received: ${print2(value)}`;
            }
          });
        }
        function never() {
          return define3("never", () => false);
        }
        function nullable2(struct4) {
          return new Struct2({
            ...struct4,
            validator: (value, ctx) => value === null || struct4.validator(value, ctx),
            refiner: (value, ctx) => value === null || struct4.refiner(value, ctx)
          });
        }
        function number2() {
          return define3("number", (value) => {
            return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print2(value)}`;
          });
        }
        function object(schema) {
          const knowns = schema ? Object.keys(schema) : [];
          const Never = never();
          return new Struct2({
            type: "object",
            schema: schema ? schema : null,
            *entries(value) {
              if (schema && isObject2(value)) {
                const unknowns = new Set(Object.keys(value));
                for (const key of knowns) {
                  unknowns.delete(key);
                  yield [key, value[key], schema[key]];
                }
                for (const key of unknowns) {
                  yield [key, value[key], Never];
                }
              }
            },
            validator(value) {
              return isNonArrayObject(value) || `Expected an object, but received: ${print2(value)}`;
            },
            coercer(value, ctx) {
              if (!isNonArrayObject(value)) {
                return value;
              }
              const coerced = { ...value };
              if (ctx.mask && schema) {
                for (const key in coerced) {
                  if (schema[key] === void 0) {
                    delete coerced[key];
                  }
                }
              }
              return coerced;
            }
          });
        }
        function optional2(struct4) {
          return new Struct2({
            ...struct4,
            validator: (value, ctx) => value === void 0 || struct4.validator(value, ctx),
            refiner: (value, ctx) => value === void 0 || struct4.refiner(value, ctx)
          });
        }
        function record(Key, Value) {
          return new Struct2({
            type: "record",
            schema: null,
            *entries(value) {
              if (isObject2(value)) {
                for (const k in value) {
                  const v = value[k];
                  yield [k, k, Key];
                  yield [k, v, Value];
                }
              }
            },
            validator(value) {
              return isNonArrayObject(value) || `Expected an object, but received: ${print2(value)}`;
            },
            coercer(value) {
              return isNonArrayObject(value) ? { ...value } : value;
            }
          });
        }
        function regexp() {
          return define3("regexp", (value) => {
            return value instanceof RegExp;
          });
        }
        function set2(Element) {
          return new Struct2({
            type: "set",
            schema: null,
            *entries(value) {
              if (Element && value instanceof Set) {
                for (const v of value) {
                  yield [v, v, Element];
                }
              }
            },
            coercer(value) {
              return value instanceof Set ? new Set(value) : value;
            },
            validator(value) {
              return value instanceof Set || `Expected a \`Set\` object, but received: ${print2(value)}`;
            }
          });
        }
        function string2() {
          return define3("string", (value) => {
            return typeof value === "string" || `Expected a string, but received: ${print2(value)}`;
          });
        }
        function tuple(Structs) {
          const Never = never();
          return new Struct2({
            type: "tuple",
            schema: null,
            *entries(value) {
              if (Array.isArray(value)) {
                const length = Math.max(Structs.length, value.length);
                for (let i = 0; i < length; i++) {
                  yield [i, value[i], Structs[i] || Never];
                }
              }
            },
            validator(value) {
              return Array.isArray(value) || `Expected an array, but received: ${print2(value)}`;
            },
            coercer(value) {
              return Array.isArray(value) ? value.slice() : value;
            }
          });
        }
        function type2(schema) {
          const keys = Object.keys(schema);
          return new Struct2({
            type: "type",
            schema,
            *entries(value) {
              if (isObject2(value)) {
                for (const k of keys) {
                  yield [k, value[k], schema[k]];
                }
              }
            },
            validator(value) {
              return isNonArrayObject(value) || `Expected an object, but received: ${print2(value)}`;
            },
            coercer(value) {
              return isNonArrayObject(value) ? { ...value } : value;
            }
          });
        }
        function union2(Structs) {
          const description = Structs.map((s) => s.type).join(" | ");
          return new Struct2({
            type: "union",
            schema: null,
            coercer(value, ctx) {
              for (const S of Structs) {
                const [error, coerced] = S.validate(value, {
                  coerce: true,
                  mask: ctx.mask
                });
                if (!error) {
                  return coerced;
                }
              }
              return value;
            },
            validator(value, ctx) {
              const failures = [];
              for (const S of Structs) {
                const [...tuples] = run2(value, S, ctx);
                const [first] = tuples;
                if (!first[0]) {
                  return [];
                } else {
                  for (const [failure] of tuples) {
                    if (failure) {
                      failures.push(failure);
                    }
                  }
                }
              }
              return [
                `Expected the value to satisfy a union of \`${description}\`, but received: ${print2(value)}`,
                ...failures
              ];
            }
          });
        }
        function unknown2() {
          return define3("unknown", () => true);
        }
        function coerce2(struct4, condition, coercer) {
          return new Struct2({
            ...struct4,
            coercer: (value, ctx) => {
              return is2(value, condition) ? struct4.coercer(coercer(value, ctx), ctx) : struct4.coercer(value, ctx);
            }
          });
        }
        function defaulted(struct4, fallback, options = {}) {
          return coerce2(struct4, unknown2(), (x) => {
            const f2 = typeof fallback === "function" ? fallback() : fallback;
            if (x === void 0) {
              return f2;
            }
            if (!options.strict && isPlainObject(x) && isPlainObject(f2)) {
              const ret = { ...x };
              let changed = false;
              for (const key in f2) {
                if (ret[key] === void 0) {
                  ret[key] = f2[key];
                  changed = true;
                }
              }
              if (changed) {
                return ret;
              }
            }
            return x;
          });
        }
        function trimmed(struct4) {
          return coerce2(struct4, string2(), (x) => x.trim());
        }
        function empty(struct4) {
          return refine(struct4, "empty", (value) => {
            const size2 = getSize(value);
            return size2 === 0 || `Expected an empty ${struct4.type} but received one with a size of \`${size2}\``;
          });
        }
        function getSize(value) {
          if (value instanceof Map || value instanceof Set) {
            return value.size;
          } else {
            return value.length;
          }
        }
        function max(struct4, threshold, options = {}) {
          const { exclusive } = options;
          return refine(struct4, "max", (value) => {
            return exclusive ? value < threshold : value <= threshold || `Expected a ${struct4.type} less than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
          });
        }
        function min(struct4, threshold, options = {}) {
          const { exclusive } = options;
          return refine(struct4, "min", (value) => {
            return exclusive ? value > threshold : value >= threshold || `Expected a ${struct4.type} greater than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
          });
        }
        function nonempty(struct4) {
          return refine(struct4, "nonempty", (value) => {
            const size2 = getSize(value);
            return size2 > 0 || `Expected a nonempty ${struct4.type} but received an empty one`;
          });
        }
        function pattern(struct4, regexp2) {
          return refine(struct4, "pattern", (value) => {
            return regexp2.test(value) || `Expected a ${struct4.type} matching \`/${regexp2.source}/\` but received "${value}"`;
          });
        }
        function size(struct4, min2, max2 = min2) {
          const expected = `Expected a ${struct4.type}`;
          const of = min2 === max2 ? `of \`${min2}\`` : `between \`${min2}\` and \`${max2}\``;
          return refine(struct4, "size", (value) => {
            if (typeof value === "number" || value instanceof Date) {
              return min2 <= value && value <= max2 || `${expected} ${of} but received \`${value}\``;
            } else if (value instanceof Map || value instanceof Set) {
              const { size: size2 } = value;
              return min2 <= size2 && size2 <= max2 || `${expected} with a size ${of} but received one with a size of \`${size2}\``;
            } else {
              const { length } = value;
              return min2 <= length && length <= max2 || `${expected} with a length ${of} but received one with a length of \`${length}\``;
            }
          });
        }
        function refine(struct4, name, refiner) {
          return new Struct2({
            ...struct4,
            *refiner(value, ctx) {
              yield* struct4.refiner(value, ctx);
              const result = refiner(value, ctx);
              const failures = toFailures2(result, ctx, struct4, value);
              for (const failure of failures) {
                yield { ...failure, refinement: name };
              }
            }
          });
        }
        exports2.Struct = Struct2;
        exports2.StructError = StructError2;
        exports2.any = any2;
        exports2.array = array3;
        exports2.assert = assert2;
        exports2.assign = assign2;
        exports2.bigint = bigint;
        exports2.boolean = boolean2;
        exports2.coerce = coerce2;
        exports2.create = create2;
        exports2.date = date;
        exports2.defaulted = defaulted;
        exports2.define = define3;
        exports2.deprecated = deprecated;
        exports2.dynamic = dynamic;
        exports2.empty = empty;
        exports2.enums = enums;
        exports2.func = func;
        exports2.instance = instance;
        exports2.integer = integer;
        exports2.intersection = intersection;
        exports2.is = is2;
        exports2.lazy = lazy;
        exports2.literal = literal2;
        exports2.map = map;
        exports2.mask = mask2;
        exports2.max = max;
        exports2.min = min;
        exports2.never = never;
        exports2.nonempty = nonempty;
        exports2.nullable = nullable2;
        exports2.number = number2;
        exports2.object = object;
        exports2.omit = omit;
        exports2.optional = optional2;
        exports2.partial = partial;
        exports2.pattern = pattern;
        exports2.pick = pick;
        exports2.record = record;
        exports2.refine = refine;
        exports2.regexp = regexp;
        exports2.set = set2;
        exports2.size = size;
        exports2.string = string2;
        exports2.struct = struct3;
        exports2.trimmed = trimmed;
        exports2.tuple = tuple;
        exports2.type = type2;
        exports2.union = union2;
        exports2.unknown = unknown2;
        exports2.validate = validate3;
      }));
    }
  });

  // node_modules/uuid/dist/esm-browser/rng.js
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  var getRandomValues, rnds8;
  var init_rng = __esm({
    "node_modules/uuid/dist/esm-browser/rng.js"() {
      rnds8 = new Uint8Array(16);
    }
  });

  // node_modules/uuid/dist/esm-browser/regex.js
  var regex_default;
  var init_regex = __esm({
    "node_modules/uuid/dist/esm-browser/regex.js"() {
      regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    }
  });

  // node_modules/uuid/dist/esm-browser/validate.js
  function validate(uuid) {
    return typeof uuid === "string" && regex_default.test(uuid);
  }
  var validate_default;
  var init_validate = __esm({
    "node_modules/uuid/dist/esm-browser/validate.js"() {
      init_regex();
      validate_default = validate;
    }
  });

  // node_modules/uuid/dist/esm-browser/stringify.js
  function stringify(arr) {
    var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
    if (!validate_default(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var byteToHex, i, stringify_default;
  var init_stringify = __esm({
    "node_modules/uuid/dist/esm-browser/stringify.js"() {
      init_validate();
      byteToHex = [];
      for (i = 0; i < 256; ++i) {
        byteToHex.push((i + 256).toString(16).substr(1));
      }
      stringify_default = stringify;
    }
  });

  // node_modules/uuid/dist/esm-browser/v1.js
  function v1(options, buf, offset2) {
    var i = buf && offset2 || 0;
    var b = buf || new Array(16);
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      var seedBytes = options.random || (options.rng || rng)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
    var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === void 0) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 122192928e5;
    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    var tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (var n = 0; n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || stringify_default(b);
  }
  var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
  var init_v1 = __esm({
    "node_modules/uuid/dist/esm-browser/v1.js"() {
      init_rng();
      init_stringify();
      _lastMSecs = 0;
      _lastNSecs = 0;
      v1_default = v1;
    }
  });

  // node_modules/uuid/dist/esm-browser/parse.js
  function parse(uuid) {
    if (!validate_default(uuid)) {
      throw TypeError("Invalid UUID");
    }
    var v;
    var arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  }
  var parse_default;
  var init_parse = __esm({
    "node_modules/uuid/dist/esm-browser/parse.js"() {
      init_validate();
      parse_default = parse;
    }
  });

  // node_modules/uuid/dist/esm-browser/v35.js
  function stringToBytes(str2) {
    str2 = unescape(encodeURIComponent(str2));
    var bytes = [];
    for (var i = 0; i < str2.length; ++i) {
      bytes.push(str2.charCodeAt(i));
    }
    return bytes;
  }
  function v35_default(name, version2, hashfunc) {
    function generateUUID(value, namespace, buf, offset2) {
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = parse_default(namespace);
      }
      if (namespace.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      var bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version2;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset2 = offset2 || 0;
        for (var i = 0; i < 16; ++i) {
          buf[offset2 + i] = bytes[i];
        }
        return buf;
      }
      return stringify_default(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err2) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
  }
  var DNS, URL;
  var init_v35 = __esm({
    "node_modules/uuid/dist/esm-browser/v35.js"() {
      init_stringify();
      init_parse();
      DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
      URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    }
  });

  // node_modules/uuid/dist/esm-browser/md5.js
  function md5(bytes) {
    if (typeof bytes === "string") {
      var msg = unescape(encodeURIComponent(bytes));
      bytes = new Uint8Array(msg.length);
      for (var i = 0; i < msg.length; ++i) {
        bytes[i] = msg.charCodeAt(i);
      }
    }
    return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
  }
  function md5ToHexEncodedArray(input) {
    var output = [];
    var length32 = input.length * 32;
    var hexTab = "0123456789abcdef";
    for (var i = 0; i < length32; i += 8) {
      var x = input[i >> 5] >>> i % 32 & 255;
      var hex2 = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
      output.push(hex2);
    }
    return output;
  }
  function getOutputLength(inputLength8) {
    return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
  }
  function wordsToMd5(x, len) {
    x[len >> 5] |= 128 << len % 32;
    x[getOutputLength(len) - 1] = len;
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;
    for (var i = 0; i < x.length; i += 16) {
      var olda = a;
      var oldb = b;
      var oldc = c;
      var oldd = d;
      a = md5ff(a, b, c, d, x[i], 7, -680876936);
      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
      c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
      b = md5gg(b, c, d, a, x[i], 20, -373897302);
      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
      a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
      d = md5hh(d, a, b, c, x[i], 11, -358537222);
      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
      a = md5ii(a, b, c, d, x[i], 6, -198630844);
      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
      a = safeAdd(a, olda);
      b = safeAdd(b, oldb);
      c = safeAdd(c, oldc);
      d = safeAdd(d, oldd);
    }
    return [a, b, c, d];
  }
  function bytesToWords(input) {
    if (input.length === 0) {
      return [];
    }
    var length8 = input.length * 8;
    var output = new Uint32Array(getOutputLength(length8));
    for (var i = 0; i < length8; i += 8) {
      output[i >> 5] |= (input[i / 8] & 255) << i % 32;
    }
    return output;
  }
  function safeAdd(x, y) {
    var lsw = (x & 65535) + (y & 65535);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }
  function bitRotateLeft(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
  }
  function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
  }
  function md5ff(a, b, c, d, x, s, t) {
    return md5cmn(b & c | ~b & d, a, b, x, s, t);
  }
  function md5gg(a, b, c, d, x, s, t) {
    return md5cmn(b & d | c & ~d, a, b, x, s, t);
  }
  function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
  }
  function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
  }
  var md5_default;
  var init_md5 = __esm({
    "node_modules/uuid/dist/esm-browser/md5.js"() {
      md5_default = md5;
    }
  });

  // node_modules/uuid/dist/esm-browser/v3.js
  var v3, v3_default;
  var init_v3 = __esm({
    "node_modules/uuid/dist/esm-browser/v3.js"() {
      init_v35();
      init_md5();
      v3 = v35_default("v3", 48, md5_default);
      v3_default = v3;
    }
  });

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset2) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset2 = offset2 || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset2 + i] = rnds[i];
      }
      return buf;
    }
    return stringify_default(rnds);
  }
  var v4_default;
  var init_v4 = __esm({
    "node_modules/uuid/dist/esm-browser/v4.js"() {
      init_rng();
      init_stringify();
      v4_default = v4;
    }
  });

  // node_modules/uuid/dist/esm-browser/sha1.js
  function f(s, x, y, z) {
    switch (s) {
      case 0:
        return x & y ^ ~x & z;
      case 1:
        return x ^ y ^ z;
      case 2:
        return x & y ^ x & z ^ y & z;
      case 3:
        return x ^ y ^ z;
    }
  }
  function ROTL(x, n) {
    return x << n | x >>> 32 - n;
  }
  function sha1(bytes) {
    var K = [1518500249, 1859775393, 2400959708, 3395469782];
    var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof bytes === "string") {
      var msg = unescape(encodeURIComponent(bytes));
      bytes = [];
      for (var i = 0; i < msg.length; ++i) {
        bytes.push(msg.charCodeAt(i));
      }
    } else if (!Array.isArray(bytes)) {
      bytes = Array.prototype.slice.call(bytes);
    }
    bytes.push(128);
    var l = bytes.length / 4 + 2;
    var N = Math.ceil(l / 16);
    var M = new Array(N);
    for (var _i = 0; _i < N; ++_i) {
      var arr = new Uint32Array(16);
      for (var j = 0; j < 16; ++j) {
        arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
      }
      M[_i] = arr;
    }
    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
    for (var _i2 = 0; _i2 < N; ++_i2) {
      var W = new Uint32Array(80);
      for (var t = 0; t < 16; ++t) {
        W[t] = M[_i2][t];
      }
      for (var _t = 16; _t < 80; ++_t) {
        W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
      }
      var a = H[0];
      var b = H[1];
      var c = H[2];
      var d = H[3];
      var e = H[4];
      for (var _t2 = 0; _t2 < 80; ++_t2) {
        var s = Math.floor(_t2 / 20);
        var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
        e = d;
        d = c;
        c = ROTL(b, 30) >>> 0;
        b = a;
        a = T;
      }
      H[0] = H[0] + a >>> 0;
      H[1] = H[1] + b >>> 0;
      H[2] = H[2] + c >>> 0;
      H[3] = H[3] + d >>> 0;
      H[4] = H[4] + e >>> 0;
    }
    return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
  }
  var sha1_default;
  var init_sha1 = __esm({
    "node_modules/uuid/dist/esm-browser/sha1.js"() {
      sha1_default = sha1;
    }
  });

  // node_modules/uuid/dist/esm-browser/v5.js
  var v5, v5_default;
  var init_v5 = __esm({
    "node_modules/uuid/dist/esm-browser/v5.js"() {
      init_v35();
      init_sha1();
      v5 = v35_default("v5", 80, sha1_default);
      v5_default = v5;
    }
  });

  // node_modules/uuid/dist/esm-browser/nil.js
  var nil_default;
  var init_nil = __esm({
    "node_modules/uuid/dist/esm-browser/nil.js"() {
      nil_default = "00000000-0000-0000-0000-000000000000";
    }
  });

  // node_modules/uuid/dist/esm-browser/version.js
  function version(uuid) {
    if (!validate_default(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.substr(14, 1), 16);
  }
  var version_default;
  var init_version = __esm({
    "node_modules/uuid/dist/esm-browser/version.js"() {
      init_validate();
      version_default = version;
    }
  });

  // node_modules/uuid/dist/esm-browser/index.js
  var esm_browser_exports = {};
  __export(esm_browser_exports, {
    NIL: () => nil_default,
    parse: () => parse_default,
    stringify: () => stringify_default,
    v1: () => v1_default,
    v3: () => v3_default,
    v4: () => v4_default,
    v5: () => v5_default,
    validate: () => validate_default,
    version: () => version_default
  });
  var init_esm_browser = __esm({
    "node_modules/uuid/dist/esm-browser/index.js"() {
      init_v1();
      init_v3();
      init_v4();
      init_v5();
      init_nil();
      init_version();
      init_validate();
      init_stringify();
      init_parse();
    }
  });

  // node_modules/jayson/lib/generateRequest.js
  var require_generateRequest = __commonJS({
    "node_modules/jayson/lib/generateRequest.js"(exports, module) {
      "use strict";
      var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
      var generateRequest = function(method, params, id, options) {
        if (typeof method !== "string") {
          throw new TypeError(method + " must be a string");
        }
        options = options || {};
        const version2 = typeof options.version === "number" ? options.version : 2;
        if (version2 !== 1 && version2 !== 2) {
          throw new TypeError(version2 + " must be 1 or 2");
        }
        const request = {
          method
        };
        if (version2 === 2) {
          request.jsonrpc = "2.0";
        }
        if (params) {
          if (typeof params !== "object" && !Array.isArray(params)) {
            throw new TypeError(params + " must be an object, array or omitted");
          }
          request.params = params;
        }
        if (typeof id === "undefined") {
          const generator = typeof options.generator === "function" ? options.generator : function() {
            return uuid();
          };
          request.id = generator(request, options);
        } else if (version2 === 2 && id === null) {
          if (options.notificationIdNull) {
            request.id = null;
          }
        } else {
          request.id = id;
        }
        return request;
      };
      module.exports = generateRequest;
    }
  });

  // node_modules/jayson/lib/client/browser/index.js
  var require_browser2 = __commonJS({
    "node_modules/jayson/lib/client/browser/index.js"(exports, module) {
      "use strict";
      var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
      var generateRequest = require_generateRequest();
      var ClientBrowser = function(callServer, options) {
        if (!(this instanceof ClientBrowser)) {
          return new ClientBrowser(callServer, options);
        }
        if (!options) {
          options = {};
        }
        this.options = {
          reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
          replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
          generator: typeof options.generator !== "undefined" ? options.generator : function() {
            return uuid();
          },
          version: typeof options.version !== "undefined" ? options.version : 2,
          notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
        };
        this.callServer = callServer;
      };
      module.exports = ClientBrowser;
      ClientBrowser.prototype.request = function(method, params, id, callback) {
        const self2 = this;
        let request = null;
        const isBatch = Array.isArray(method) && typeof params === "function";
        if (this.options.version === 1 && isBatch) {
          throw new TypeError("JSON-RPC 1.0 does not support batching");
        }
        const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
        if (isBatch || isRaw) {
          callback = params;
          request = method;
        } else {
          if (typeof id === "function") {
            callback = id;
            id = void 0;
          }
          const hasCallback = typeof callback === "function";
          try {
            request = generateRequest(method, params, id, {
              generator: this.options.generator,
              version: this.options.version,
              notificationIdNull: this.options.notificationIdNull
            });
          } catch (err2) {
            if (hasCallback) {
              return callback(err2);
            }
            throw err2;
          }
          if (!hasCallback) {
            return request;
          }
        }
        let message;
        try {
          message = JSON.stringify(request, this.options.replacer);
        } catch (err2) {
          return callback(err2);
        }
        this.callServer(message, function(err2, response) {
          self2._parseResponse(err2, response, callback);
        });
        return request;
      };
      ClientBrowser.prototype._parseResponse = function(err2, responseText, callback) {
        if (err2) {
          callback(err2);
          return;
        }
        if (!responseText) {
          return callback();
        }
        let response;
        try {
          response = JSON.parse(responseText, this.options.reviver);
        } catch (err3) {
          return callback(err3);
        }
        if (callback.length === 3) {
          if (Array.isArray(response)) {
            const isError = function(res) {
              return typeof res.error !== "undefined";
            };
            const isNotError = function(res) {
              return !isError(res);
            };
            return callback(null, response.filter(isError), response.filter(isNotError));
          } else {
            return callback(null, response.error, response.result);
          }
        }
        callback(null, response);
      };
    }
  });

  // node_modules/rpc-websockets/node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/rpc-websockets/node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0) return names;
        for (name in events = this._events) {
          if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // node_modules/rpc-websockets/dist/index.browser.cjs
  var require_index_browser = __commonJS({
    "node_modules/rpc-websockets/dist/index.browser.cjs"(exports) {
      "use strict";
      var buffer = require_buffer();
      var eventemitter3 = require_eventemitter3();
      var WebSocketBrowserImpl = class extends eventemitter3.EventEmitter {
        socket;
        /** Instantiate a WebSocket class
        * @constructor
        * @param {String} address - url to a websocket server
        * @param {(Object)} options - websocket options
        * @param {(String|Array)} protocols - a list of protocols
        * @return {WebSocketBrowserImpl} - returns a WebSocket instance
        */
        constructor(address, options, protocols) {
          super();
          this.socket = new window.WebSocket(address, protocols);
          this.socket.onopen = () => this.emit("open");
          this.socket.onmessage = (event) => this.emit("message", event.data);
          this.socket.onerror = (error) => this.emit("error", error);
          this.socket.onclose = (event) => {
            this.emit("close", event.code, event.reason);
          };
        }
        /**
        * Sends data through a websocket connection
        * @method
        * @param {(String|Object)} data - data to be sent via websocket
        * @param {Object} optionsOrCallback - ws options
        * @param {Function} callback - a callback called once the data is sent
        * @return {Undefined}
        */
        send(data, optionsOrCallback, callback) {
          const cb = callback || optionsOrCallback;
          try {
            this.socket.send(data);
            cb();
          } catch (error) {
            cb(error);
          }
        }
        /**
        * Closes an underlying socket
        * @method
        * @param {Number} code - status code explaining why the connection is being closed
        * @param {String} reason - a description why the connection is closing
        * @return {Undefined}
        * @throws {Error}
        */
        close(code, reason) {
          this.socket.close(code, reason);
        }
        addEventListener(type2, listener, options) {
          this.socket.addEventListener(type2, listener, options);
        }
      };
      function WebSocket(address, options) {
        return new WebSocketBrowserImpl(address, options);
      }
      var DefaultDataPack = class {
        encode(value) {
          return JSON.stringify(value);
        }
        decode(value) {
          return JSON.parse(value);
        }
      };
      var CommonClient = class extends eventemitter3.EventEmitter {
        address;
        rpc_id;
        queue;
        options;
        autoconnect;
        ready;
        reconnect;
        reconnect_timer_id;
        reconnect_interval;
        max_reconnects;
        rest_options;
        current_reconnects;
        generate_request_id;
        socket;
        webSocketFactory;
        dataPack;
        /**
        * Instantiate a Client class.
        * @constructor
        * @param {webSocketFactory} webSocketFactory - factory method for WebSocket
        * @param {String} address - url to a websocket server
        * @param {Object} options - ws options object with reconnect parameters
        * @param {Function} generate_request_id - custom generation request Id
        * @param {DataPack} dataPack - data pack contains encoder and decoder
        * @return {CommonClient}
        */
        constructor(webSocketFactory, address = "ws://localhost:8080", {
          autoconnect = true,
          reconnect = true,
          reconnect_interval = 1e3,
          max_reconnects = 5,
          ...rest_options
        } = {}, generate_request_id, dataPack) {
          super();
          this.webSocketFactory = webSocketFactory;
          this.queue = {};
          this.rpc_id = 0;
          this.address = address;
          this.autoconnect = autoconnect;
          this.ready = false;
          this.reconnect = reconnect;
          this.reconnect_timer_id = void 0;
          this.reconnect_interval = reconnect_interval;
          this.max_reconnects = max_reconnects;
          this.rest_options = rest_options;
          this.current_reconnects = 0;
          this.generate_request_id = generate_request_id || (() => typeof this.rpc_id === "number" ? ++this.rpc_id : Number(this.rpc_id) + 1);
          if (!dataPack) this.dataPack = new DefaultDataPack();
          else this.dataPack = dataPack;
          if (this.autoconnect)
            this._connect(this.address, {
              autoconnect: this.autoconnect,
              reconnect: this.reconnect,
              reconnect_interval: this.reconnect_interval,
              max_reconnects: this.max_reconnects,
              ...this.rest_options
            });
        }
        /**
        * Connects to a defined server if not connected already.
        * @method
        * @return {Undefined}
        */
        connect() {
          if (this.socket) return;
          this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
          });
        }
        /**
        * Calls a registered RPC method on server.
        * @method
        * @param {String} method - RPC method name
        * @param {Object|Array} params - optional method parameters
        * @param {Number} timeout - RPC reply timeout value
        * @param {Object} ws_opts - options passed to ws
        * @return {Promise}
        */
        call(method, params, timeout, ws_opts) {
          if (!ws_opts && "object" === typeof timeout) {
            ws_opts = timeout;
            timeout = null;
          }
          return new Promise((resolve, reject) => {
            if (!this.ready) return reject(new Error("socket not ready"));
            const rpc_id = this.generate_request_id(method, params);
            const message = {
              jsonrpc: "2.0",
              method,
              params: params || void 0,
              id: rpc_id
            };
            this.socket.send(this.dataPack.encode(message), ws_opts, (error) => {
              if (error) return reject(error);
              this.queue[rpc_id] = { promise: [resolve, reject] };
              if (timeout) {
                this.queue[rpc_id].timeout = setTimeout(() => {
                  delete this.queue[rpc_id];
                  reject(new Error("reply timeout"));
                }, timeout);
              }
            });
          });
        }
        /**
        * Logins with the other side of the connection.
        * @method
        * @param {Object} params - Login credentials object
        * @return {Promise}
        */
        async login(params) {
          const resp = await this.call("rpc.login", params);
          if (!resp) throw new Error("authentication failed");
          return resp;
        }
        /**
        * Fetches a list of client's methods registered on server.
        * @method
        * @return {Array}
        */
        async listMethods() {
          return await this.call("__listMethods");
        }
        /**
        * Sends a JSON-RPC 2.0 notification to server.
        * @method
        * @param {String} method - RPC method name
        * @param {Object} params - optional method parameters
        * @return {Promise}
        */
        notify(method, params) {
          return new Promise((resolve, reject) => {
            if (!this.ready) return reject(new Error("socket not ready"));
            const message = {
              jsonrpc: "2.0",
              method,
              params
            };
            this.socket.send(this.dataPack.encode(message), (error) => {
              if (error) return reject(error);
              resolve();
            });
          });
        }
        /**
        * Subscribes for a defined event.
        * @method
        * @param {String|Array} event - event name
        * @return {Undefined}
        * @throws {Error}
        */
        async subscribe(event) {
          if (typeof event === "string") event = [event];
          const result = await this.call("rpc.on", event);
          if (typeof event === "string" && result[event] !== "ok")
            throw new Error(
              "Failed subscribing to an event '" + event + "' with: " + result[event]
            );
          return result;
        }
        /**
        * Unsubscribes from a defined event.
        * @method
        * @param {String|Array} event - event name
        * @return {Undefined}
        * @throws {Error}
        */
        async unsubscribe(event) {
          if (typeof event === "string") event = [event];
          const result = await this.call("rpc.off", event);
          if (typeof event === "string" && result[event] !== "ok")
            throw new Error("Failed unsubscribing from an event with: " + result);
          return result;
        }
        /**
        * Closes a WebSocket connection gracefully.
        * @method
        * @param {Number} code - socket close code
        * @param {String} data - optional data to be sent before closing
        * @return {Undefined}
        */
        close(code, data) {
          if (this.socket) this.socket.close(code || 1e3, data);
        }
        /**
        * Enable / disable automatic reconnection.
        * @method
        * @param {Boolean} reconnect - enable / disable reconnection
        * @return {Undefined}
        */
        setAutoReconnect(reconnect) {
          this.reconnect = reconnect;
        }
        /**
        * Set the interval between reconnection attempts.
        * @method
        * @param {Number} interval - reconnection interval in milliseconds
        * @return {Undefined}
        */
        setReconnectInterval(interval) {
          this.reconnect_interval = interval;
        }
        /**
        * Set the maximum number of reconnection attempts.
        * @method
        * @param {Number} max_reconnects - maximum reconnection attempts
        * @return {Undefined}
        */
        setMaxReconnects(max_reconnects) {
          this.max_reconnects = max_reconnects;
        }
        /**
        * Get the current number of reconnection attempts made.
        * @method
        * @return {Number} current reconnection attempts
        */
        getCurrentReconnects() {
          return this.current_reconnects;
        }
        /**
        * Get the maximum number of reconnection attempts.
        * @method
        * @return {Number} maximum reconnection attempts
        */
        getMaxReconnects() {
          return this.max_reconnects;
        }
        /**
        * Check if the client is currently attempting to reconnect.
        * @method
        * @return {Boolean} true if reconnection is in progress
        */
        isReconnecting() {
          return this.reconnect_timer_id !== void 0;
        }
        /**
        * Check if the client will attempt to reconnect on the next close event.
        * @method
        * @return {Boolean} true if reconnection will be attempted
        */
        willReconnect() {
          return this.reconnect && (this.max_reconnects === 0 || this.current_reconnects < this.max_reconnects);
        }
        /**
        * Connection/Message handler.
        * @method
        * @private
        * @param {String} address - WebSocket API address
        * @param {Object} options - ws options object
        * @return {Undefined}
        */
        _connect(address, options) {
          clearTimeout(this.reconnect_timer_id);
          this.socket = this.webSocketFactory(address, options);
          this.socket.addEventListener("open", () => {
            this.ready = true;
            this.emit("open");
            this.current_reconnects = 0;
          });
          this.socket.addEventListener("message", ({ data: message }) => {
            if (message instanceof ArrayBuffer)
              message = buffer.Buffer.from(message).toString();
            try {
              message = this.dataPack.decode(message);
            } catch (error) {
              return;
            }
            if (message.notification && this.listeners(message.notification).length) {
              if (!Object.keys(message.params).length)
                return this.emit(message.notification);
              const args = [message.notification];
              if (message.params.constructor === Object) args.push(message.params);
              else
                for (let i = 0; i < message.params.length; i++)
                  args.push(message.params[i]);
              return Promise.resolve().then(() => {
                this.emit.apply(this, args);
              });
            }
            if (!this.queue[message.id]) {
              if (message.method) {
                return Promise.resolve().then(() => {
                  this.emit(message.method, message?.params);
                });
              }
              return;
            }
            if ("error" in message === "result" in message)
              this.queue[message.id].promise[1](
                new Error(
                  'Server response malformed. Response must include either "result" or "error", but not both.'
                )
              );
            if (this.queue[message.id].timeout)
              clearTimeout(this.queue[message.id].timeout);
            if (message.error) this.queue[message.id].promise[1](message.error);
            else this.queue[message.id].promise[0](message.result);
            delete this.queue[message.id];
          });
          this.socket.addEventListener("error", (error) => this.emit("error", error));
          this.socket.addEventListener("close", ({ code, reason }) => {
            if (this.ready)
              setTimeout(() => this.emit("close", code, reason), 0);
            this.ready = false;
            this.socket = void 0;
            if (code === 1e3) return;
            this.current_reconnects++;
            if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0))
              this.reconnect_timer_id = setTimeout(
                () => this._connect(address, options),
                this.reconnect_interval
              );
            else if (this.reconnect && this.max_reconnects > 0 && this.current_reconnects >= this.max_reconnects) {
              setTimeout(() => this.emit("max_reconnects_reached", code, reason), 1);
            }
          });
        }
      };
      var Client = class extends CommonClient {
        constructor(address = "ws://localhost:8080", {
          autoconnect = true,
          reconnect = true,
          reconnect_interval = 1e3,
          max_reconnects = 5
        } = {}, generate_request_id) {
          super(
            WebSocket,
            address,
            {
              autoconnect,
              reconnect,
              reconnect_interval,
              max_reconnects
            },
            generate_request_id
          );
        }
      };
      exports.Client = Client;
      exports.CommonClient = CommonClient;
      exports.DefaultDataPack = DefaultDataPack;
      exports.WebSocket = WebSocket;
    }
  });

  // node_modules/@noble/hashes/sha3.js
  var require_sha3 = __commonJS({
    "node_modules/@noble/hashes/sha3.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
      exports.keccakP = keccakP;
      var _u64_ts_1 = require_u64();
      var utils_ts_1 = require_utils();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _7n = BigInt(7);
      var _256n = BigInt(256);
      var _0x71n = BigInt(113);
      var SHA3_PI = [];
      var SHA3_ROTL = [];
      var _SHA3_IOTA = [];
      for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
        [x, y] = [y, (2 * x + 3 * y) % 5];
        SHA3_PI.push(2 * (5 * y + x));
        SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
        let t = _0n;
        for (let j = 0; j < 7; j++) {
          R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
          if (R & _2n)
            t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
        }
        _SHA3_IOTA.push(t);
      }
      var IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
      var SHA3_IOTA_H = IOTAS[0];
      var SHA3_IOTA_L = IOTAS[1];
      var rotlH = (h, l, s) => s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s);
      var rotlL = (h, l, s) => s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s);
      function keccakP(s, rounds = 24) {
        const B = new Uint32Array(5 * 2);
        for (let round = 24 - rounds; round < 24; round++) {
          for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
          for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
              s[x + y] ^= Th;
              s[x + y + 1] ^= Tl;
            }
          }
          let curH = s[2];
          let curL = s[3];
          for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
          }
          for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
              B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
              s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
          }
          s[0] ^= SHA3_IOTA_H[round];
          s[1] ^= SHA3_IOTA_L[round];
        }
        (0, utils_ts_1.clean)(B);
      }
      var Keccak = class _Keccak extends utils_ts_1.Hash {
        // NOTE: we accept arguments in bytes instead of bits here.
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
          super();
          this.pos = 0;
          this.posOut = 0;
          this.finished = false;
          this.destroyed = false;
          this.enableXOF = false;
          this.blockLen = blockLen;
          this.suffix = suffix;
          this.outputLen = outputLen;
          this.enableXOF = enableXOF;
          this.rounds = rounds;
          (0, utils_ts_1.anumber)(outputLen);
          if (!(0 < blockLen && blockLen < 200))
            throw new Error("only keccak-f1600 function is supported");
          this.state = new Uint8Array(200);
          this.state32 = (0, utils_ts_1.u32)(this.state);
        }
        clone() {
          return this._cloneInto();
        }
        keccak() {
          (0, utils_ts_1.swap32IfBE)(this.state32);
          keccakP(this.state32, this.rounds);
          (0, utils_ts_1.swap32IfBE)(this.state32);
          this.posOut = 0;
          this.pos = 0;
        }
        update(data) {
          (0, utils_ts_1.aexists)(this);
          data = (0, utils_ts_1.toBytes)(data);
          (0, utils_ts_1.abytes)(data);
          const { blockLen, state } = this;
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
              state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
              this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished)
            return;
          this.finished = true;
          const { state, suffix, pos, blockLen } = this;
          state[pos] ^= suffix;
          if ((suffix & 128) !== 0 && pos === blockLen - 1)
            this.keccak();
          state[blockLen - 1] ^= 128;
          this.keccak();
        }
        writeInto(out) {
          (0, utils_ts_1.aexists)(this, false);
          (0, utils_ts_1.abytes)(out);
          this.finish();
          const bufferOut = this.state;
          const { blockLen } = this;
          for (let pos = 0, len = out.length; pos < len; ) {
            if (this.posOut >= blockLen)
              this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
          }
          return out;
        }
        xofInto(out) {
          if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
          return this.writeInto(out);
        }
        xof(bytes) {
          (0, utils_ts_1.anumber)(bytes);
          return this.xofInto(new Uint8Array(bytes));
        }
        digestInto(out) {
          (0, utils_ts_1.aoutput)(out, this);
          if (this.finished)
            throw new Error("digest() was already called");
          this.writeInto(out);
          this.destroy();
          return out;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = true;
          (0, utils_ts_1.clean)(this.state);
        }
        _cloneInto(to) {
          const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
          to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
          to.state32.set(this.state32);
          to.pos = this.pos;
          to.posOut = this.posOut;
          to.finished = this.finished;
          to.rounds = rounds;
          to.suffix = suffix;
          to.outputLen = outputLen;
          to.enableXOF = enableXOF;
          to.destroyed = this.destroyed;
          return to;
        }
      };
      exports.Keccak = Keccak;
      var gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak(blockLen, suffix, outputLen));
      exports.sha3_224 = (() => gen(6, 144, 224 / 8))();
      exports.sha3_256 = (() => gen(6, 136, 256 / 8))();
      exports.sha3_384 = (() => gen(6, 104, 384 / 8))();
      exports.sha3_512 = (() => gen(6, 72, 512 / 8))();
      exports.keccak_224 = (() => gen(1, 144, 224 / 8))();
      exports.keccak_256 = (() => gen(1, 136, 256 / 8))();
      exports.keccak_384 = (() => gen(1, 104, 384 / 8))();
      exports.keccak_512 = (() => gen(1, 72, 512 / 8))();
      var genShake = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
      exports.shake128 = (() => genShake(31, 168, 128 / 8))();
      exports.shake256 = (() => genShake(31, 136, 256 / 8))();
    }
  });

  // node_modules/@noble/hashes/hmac.js
  var require_hmac = __commonJS({
    "node_modules/@noble/hashes/hmac.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hmac = exports.HMAC = void 0;
      var utils_ts_1 = require_utils();
      var HMAC = class extends utils_ts_1.Hash {
        constructor(hash2, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          (0, utils_ts_1.ahash)(hash2);
          const key = (0, utils_ts_1.toBytes)(_key);
          this.iHash = hash2.create();
          if (typeof this.iHash.update !== "function")
            throw new Error("Expected instance of class which extends utils.Hash");
          this.blockLen = this.iHash.blockLen;
          this.outputLen = this.iHash.outputLen;
          const blockLen = this.blockLen;
          const pad = new Uint8Array(blockLen);
          pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54;
          this.iHash.update(pad);
          this.oHash = hash2.create();
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54 ^ 92;
          this.oHash.update(pad);
          (0, utils_ts_1.clean)(pad);
        }
        update(buf) {
          (0, utils_ts_1.aexists)(this);
          this.iHash.update(buf);
          return this;
        }
        digestInto(out) {
          (0, utils_ts_1.aexists)(this);
          (0, utils_ts_1.abytes)(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        }
        digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        }
        _cloneInto(to) {
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        }
        clone() {
          return this._cloneInto();
        }
        destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        }
      };
      exports.HMAC = HMAC;
      var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
      exports.hmac = hmac;
      exports.hmac.create = (hash2, key) => new HMAC(hash2, key);
    }
  });

  // node_modules/@noble/curves/abstract/weierstrass.js
  var require_weierstrass = __commonJS({
    "node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DER = exports.DERErr = void 0;
      exports._splitEndoScalar = _splitEndoScalar;
      exports._normFnElement = _normFnElement;
      exports.weierstrassN = weierstrassN;
      exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
      exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
      exports.ecdh = ecdh;
      exports.ecdsa = ecdsa;
      exports.weierstrassPoints = weierstrassPoints;
      exports._legacyHelperEquat = _legacyHelperEquat;
      exports.weierstrass = weierstrass;
      var hmac_js_1 = require_hmac();
      var utils_1 = require_utils();
      var utils_ts_1 = require_utils2();
      var curve_ts_1 = require_curve();
      var modular_ts_1 = require_modular();
      var divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;
      function _splitEndoScalar(k, basis, n) {
        const [[a1, b1], [a2, b2]] = basis;
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = k - c1 * a1 - c2 * a2;
        let k2 = -c1 * b1 - c2 * b2;
        const k1neg = k1 < _0n;
        const k2neg = k2 < _0n;
        if (k1neg)
          k1 = -k1;
        if (k2neg)
          k2 = -k2;
        const MAX_NUM = (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n) / 2)) + _1n;
        if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {
          throw new Error("splitScalar (endomorphism): failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
      function validateSigFormat(format) {
        if (!["compact", "recovered", "der"].includes(format))
          throw new Error('Signature format must be "compact", "recovered", or "der"');
        return format;
      }
      function validateSigOpts(opts, def) {
        const optsn = {};
        for (let optName of Object.keys(def)) {
          optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
        }
        (0, utils_ts_1._abool2)(optsn.lowS, "lowS");
        (0, utils_ts_1._abool2)(optsn.prehash, "prehash");
        if (optsn.format !== void 0)
          validateSigFormat(optsn.format);
        return optsn;
      }
      var DERErr = class extends Error {
        constructor(m = "") {
          super(m);
        }
      };
      exports.DERErr = DERErr;
      exports.DER = {
        // asn.1 DER encoding utils
        Err: DERErr,
        // Basic building block is TLV (Tag-Length-Value)
        _tlv: {
          encode: (tag, data) => {
            const { Err: E } = exports.DER;
            if (tag < 0 || tag > 256)
              throw new E("tlv.encode: wrong tag");
            if (data.length & 1)
              throw new E("tlv.encode: unpadded data");
            const dataLen = data.length / 2;
            const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
            if (len.length / 2 & 128)
              throw new E("tlv.encode: long form length too big");
            const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)(len.length / 2 | 128) : "";
            const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
            return t + lenLen + len + data;
          },
          // v - value, l - left bytes (unparsed)
          decode(tag, data) {
            const { Err: E } = exports.DER;
            let pos = 0;
            if (tag < 0 || tag > 256)
              throw new E("tlv.encode: wrong tag");
            if (data.length < 2 || data[pos++] !== tag)
              throw new E("tlv.decode: wrong tlv");
            const first = data[pos++];
            const isLong = !!(first & 128);
            let length = 0;
            if (!isLong)
              length = first;
            else {
              const lenLen = first & 127;
              if (!lenLen)
                throw new E("tlv.decode(long): indefinite length not supported");
              if (lenLen > 4)
                throw new E("tlv.decode(long): byte length is too big");
              const lengthBytes = data.subarray(pos, pos + lenLen);
              if (lengthBytes.length !== lenLen)
                throw new E("tlv.decode: length bytes not complete");
              if (lengthBytes[0] === 0)
                throw new E("tlv.decode(long): zero leftmost byte");
              for (const b of lengthBytes)
                length = length << 8 | b;
              pos += lenLen;
              if (length < 128)
                throw new E("tlv.decode(long): not minimal encoding");
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length)
              throw new E("tlv.decode: wrong value length");
            return { v, l: data.subarray(pos + length) };
          }
        },
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        _int: {
          encode(num) {
            const { Err: E } = exports.DER;
            if (num < _0n)
              throw new E("integer: negative integers are not allowed");
            let hex2 = (0, utils_ts_1.numberToHexUnpadded)(num);
            if (Number.parseInt(hex2[0], 16) & 8)
              hex2 = "00" + hex2;
            if (hex2.length & 1)
              throw new E("unexpected DER parsing assertion: unpadded hex");
            return hex2;
          },
          decode(data) {
            const { Err: E } = exports.DER;
            if (data[0] & 128)
              throw new E("invalid signature integer: negative");
            if (data[0] === 0 && !(data[1] & 128))
              throw new E("invalid signature integer: unnecessary leading zero");
            return (0, utils_ts_1.bytesToNumberBE)(data);
          }
        },
        toSig(hex2) {
          const { Err: E, _int: int, _tlv: tlv } = exports.DER;
          const data = (0, utils_ts_1.ensureBytes)("signature", hex2);
          const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
          if (seqLeftBytes.length)
            throw new E("invalid signature: left bytes after parsing");
          const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
          const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
          if (sLeftBytes.length)
            throw new E("invalid signature: left bytes after parsing");
          return { r: int.decode(rBytes), s: int.decode(sBytes) };
        },
        hexFromSig(sig) {
          const { _tlv: tlv, _int: int } = exports.DER;
          const rs = tlv.encode(2, int.encode(sig.r));
          const ss = tlv.encode(2, int.encode(sig.s));
          const seq = rs + ss;
          return tlv.encode(48, seq);
        }
      };
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _3n = BigInt(3);
      var _4n = BigInt(4);
      function _normFnElement(Fn, key) {
        const { BYTES: expected } = Fn;
        let num;
        if (typeof key === "bigint") {
          num = key;
        } else {
          let bytes = (0, utils_ts_1.ensureBytes)("private key", key);
          try {
            num = Fn.fromBytes(bytes);
          } catch (error) {
            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
          }
        }
        if (!Fn.isValidNot0(num))
          throw new Error("invalid private key: out of range [1..N-1]");
        return num;
      }
      function weierstrassN(params, extraOpts = {}) {
        const validated = (0, curve_ts_1._createCurveFields)("weierstrass", params, extraOpts);
        const { Fp, Fn } = validated;
        let CURVE = validated.CURVE;
        const { h: cofactor, n: CURVE_ORDER } = CURVE;
        (0, utils_ts_1._validateObject)(extraOpts, {}, {
          allowInfinityPoint: "boolean",
          clearCofactor: "function",
          isTorsionFree: "function",
          fromBytes: "function",
          toBytes: "function",
          endo: "object",
          wrapPrivateKey: "boolean"
        });
        const { endo } = extraOpts;
        if (endo) {
          if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
            throw new Error('invalid endo: expected "beta": bigint and "basises": array');
          }
        }
        const lengths = getWLengths(Fp, Fn);
        function assertCompressionIsSupported() {
          if (!Fp.isOdd)
            throw new Error("compression is not supported: Field does not have .isOdd()");
        }
        function pointToBytes(_c, point, isCompressed) {
          const { x, y } = point.toAffine();
          const bx = Fp.toBytes(x);
          (0, utils_ts_1._abool2)(isCompressed, "isCompressed");
          if (isCompressed) {
            assertCompressionIsSupported();
            const hasEvenY = !Fp.isOdd(y);
            return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
          } else {
            return (0, utils_ts_1.concatBytes)(Uint8Array.of(4), bx, Fp.toBytes(y));
          }
        }
        function pointFromBytes(bytes) {
          (0, utils_ts_1._abytes2)(bytes, void 0, "Point");
          const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
          const length = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (length === comp && (head === 2 || head === 3)) {
            const x = Fp.fromBytes(tail);
            if (!Fp.isValid(x))
              throw new Error("bad point: is not on curve, wrong x");
            const y2 = weierstrassEquation(x);
            let y;
            try {
              y = Fp.sqrt(y2);
            } catch (sqrtError) {
              const err2 = sqrtError instanceof Error ? ": " + sqrtError.message : "";
              throw new Error("bad point: is not on curve, sqrt error" + err2);
            }
            assertCompressionIsSupported();
            const isYOdd = Fp.isOdd(y);
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (length === uncomp && head === 4) {
            const L = Fp.BYTES;
            const x = Fp.fromBytes(tail.subarray(0, L));
            const y = Fp.fromBytes(tail.subarray(L, L * 2));
            if (!isValidXY(x, y))
              throw new Error("bad point: is not on curve");
            return { x, y };
          } else {
            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
          }
        }
        const encodePoint = extraOpts.toBytes || pointToBytes;
        const decodePoint = extraOpts.fromBytes || pointFromBytes;
        function weierstrassEquation(x) {
          const x2 = Fp.sqr(x);
          const x3 = Fp.mul(x2, x);
          return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b);
        }
        function isValidXY(x, y) {
          const left = Fp.sqr(y);
          const right = weierstrassEquation(x);
          return Fp.eql(left, right);
        }
        if (!isValidXY(CURVE.Gx, CURVE.Gy))
          throw new Error("bad curve params: generator point");
        const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
        const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
        if (Fp.is0(Fp.add(_4a3, _27b2)))
          throw new Error("bad curve params: a or b");
        function acoord(title, n, banZero = false) {
          if (!Fp.isValid(n) || banZero && Fp.is0(n))
            throw new Error(`bad point coordinate ${title}`);
          return n;
        }
        function aprjpoint(other) {
          if (!(other instanceof Point))
            throw new Error("ProjectivePoint expected");
        }
        function splitEndoScalarN(k) {
          if (!endo || !endo.basises)
            throw new Error("no endo");
          return _splitEndoScalar(k, endo.basises, Fn.ORDER);
        }
        const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
          const { X, Y, Z } = p;
          if (Fp.eql(Z, Fp.ONE))
            return { x: X, y: Y };
          const is0 = p.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(Z);
          const x = Fp.mul(X, iz);
          const y = Fp.mul(Y, iz);
          const zz = Fp.mul(Z, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x, y };
        });
        const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
          if (p.is0()) {
            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))
              return;
            throw new Error("bad point: ZERO");
          }
          const { x, y } = p.toAffine();
          if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("bad point: x or y not field elements");
          if (!isValidXY(x, y))
            throw new Error("bad point: equation left != right");
          if (!p.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
          return true;
        });
        function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
          k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
          k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
          k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
          return k1p.add(k2p);
        }
        class Point {
          /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
          constructor(X, Y, Z) {
            this.X = acoord("x", X);
            this.Y = acoord("y", Y, true);
            this.Z = acoord("z", Z);
            Object.freeze(this);
          }
          static CURVE() {
            return CURVE;
          }
          /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
          static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
              throw new Error("invalid affine point");
            if (p instanceof Point)
              throw new Error("projective point not allowed");
            if (Fp.is0(x) && Fp.is0(y))
              return Point.ZERO;
            return new Point(x, y, Fp.ONE);
          }
          static fromBytes(bytes) {
            const P = Point.fromAffine(decodePoint((0, utils_ts_1._abytes2)(bytes, void 0, "point")));
            P.assertValidity();
            return P;
          }
          static fromHex(hex2) {
            return Point.fromBytes((0, utils_ts_1.ensureBytes)("pointHex", hex2));
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          /**
           *
           * @param windowSize
           * @param isLazy true will defer table computation until the first multiplication
           * @returns
           */
          precompute(windowSize = 8, isLazy = true) {
            wnaf.createCache(this, windowSize);
            if (!isLazy)
              this.multiply(_3n);
            return this;
          }
          // TODO: return `this`
          /** A point on curve is valid if it conforms to equation. */
          assertValidity() {
            assertValidMemo(this);
          }
          hasEvenY() {
            const { y } = this.toAffine();
            if (!Fp.isOdd)
              throw new Error("Field doesn't support isOdd");
            return !Fp.isOdd(y);
          }
          /** Compare one point to another. */
          equals(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
          }
          /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
          negate() {
            return new Point(this.X, Fp.neg(this.Y), this.Z);
          }
          // Renes-Costello-Batina exception-free doubling formula.
          // There is 30% faster Jacobian formula, but it is not complete.
          // https://eprint.iacr.org/2015/1060, algorithm 3
          // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
          double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
            let t0 = Fp.mul(X1, X1);
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3);
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3);
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3);
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0);
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1);
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3);
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
          }
          // Renes-Costello-Batina exception-free addition formula.
          // There is 30% faster Jacobian formula, but it is not complete.
          // https://eprint.iacr.org/2015/1060, algorithm 1
          // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
          add(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2);
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2);
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2);
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2);
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2);
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0);
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2);
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4);
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0);
            return new Point(X3, Y3, Z3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          /**
           * Constant time multiplication.
           * Uses wNAF method. Windowed method may be 10% faster,
           * but takes 2x longer to generate and consumes 2x memory.
           * Uses precomputes when available.
           * Uses endomorphism for Koblitz curves.
           * @param scalar by which the point would be multiplied
           * @returns New point
           */
          multiply(scalar) {
            const { endo: endo2 } = extraOpts;
            if (!Fn.isValidNot0(scalar))
              throw new Error("invalid scalar: out of range");
            let point, fake;
            const mul = (n) => wnaf.cached(this, n, (p) => (0, curve_ts_1.normalizeZ)(Point, p));
            if (endo2) {
              const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
              const { p: k1p, f: k1f } = mul(k1);
              const { p: k2p, f: k2f } = mul(k2);
              fake = k1f.add(k2f);
              point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
            } else {
              const { p, f: f2 } = mul(scalar);
              point = p;
              fake = f2;
            }
            return (0, curve_ts_1.normalizeZ)(Point, [point, fake])[0];
          }
          /**
           * Non-constant-time multiplication. Uses double-and-add algorithm.
           * It's faster, but should only be used when you don't care about
           * an exposed secret key e.g. sig verification, which works over *public* keys.
           */
          multiplyUnsafe(sc) {
            const { endo: endo2 } = extraOpts;
            const p = this;
            if (!Fn.isValid(sc))
              throw new Error("invalid scalar: out of range");
            if (sc === _0n || p.is0())
              return Point.ZERO;
            if (sc === _1n)
              return p;
            if (wnaf.hasCache(this))
              return this.multiply(sc);
            if (endo2) {
              const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
              const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2);
              return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
            } else {
              return wnaf.unsafe(p, sc);
            }
          }
          multiplyAndAddUnsafe(Q, a, b) {
            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
            return sum.is0() ? void 0 : sum;
          }
          /**
           * Converts Projective point to affine (x, y) coordinates.
           * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
           */
          toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
          }
          /**
           * Checks whether Point is free of torsion elements (is in prime subgroup).
           * Always torsion-free for cofactor=1 curves.
           */
          isTorsionFree() {
            const { isTorsionFree } = extraOpts;
            if (cofactor === _1n)
              return true;
            if (isTorsionFree)
              return isTorsionFree(Point, this);
            return wnaf.unsafe(this, CURVE_ORDER).is0();
          }
          clearCofactor() {
            const { clearCofactor } = extraOpts;
            if (cofactor === _1n)
              return this;
            if (clearCofactor)
              return clearCofactor(Point, this);
            return this.multiplyUnsafe(cofactor);
          }
          isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
          }
          toBytes(isCompressed = true) {
            (0, utils_ts_1._abool2)(isCompressed, "isCompressed");
            this.assertValidity();
            return encodePoint(Point, this, isCompressed);
          }
          toHex(isCompressed = true) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
          }
          toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
          }
          // TODO: remove
          get px() {
            return this.X;
          }
          get py() {
            return this.X;
          }
          get pz() {
            return this.Z;
          }
          toRawBytes(isCompressed = true) {
            return this.toBytes(isCompressed);
          }
          _setWindowSize(windowSize) {
            this.precompute(windowSize);
          }
          static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, points);
          }
          static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
          }
          static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(_normFnElement(Fn, privateKey));
          }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
        Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
        Point.Fp = Fp;
        Point.Fn = Fn;
        const bits = Fn.BITS;
        const wnaf = new curve_ts_1.wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
        Point.BASE.precompute(8);
        return Point;
      }
      function pprefix(hasEvenY) {
        return Uint8Array.of(hasEvenY ? 2 : 3);
      }
      function SWUFpSqrtRatio(Fp, Z) {
        const q = Fp.ORDER;
        let l = _0n;
        for (let o = q - _1n; o % _2n === _0n; o /= _2n)
          l += _1n;
        const c1 = l;
        const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
        const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
        const c2 = (q - _1n) / _2n_pow_c1;
        const c3 = (c2 - _1n) / _2n;
        const c4 = _2n_pow_c1 - _1n;
        const c5 = _2n_pow_c1_1;
        const c6 = Fp.pow(Z, c2);
        const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
        let sqrtRatio = (u, v) => {
          let tv1 = c6;
          let tv2 = Fp.pow(v, c4);
          let tv3 = Fp.sqr(tv2);
          tv3 = Fp.mul(tv3, v);
          let tv5 = Fp.mul(u, tv3);
          tv5 = Fp.pow(tv5, c3);
          tv5 = Fp.mul(tv5, tv2);
          tv2 = Fp.mul(tv5, v);
          tv3 = Fp.mul(tv5, u);
          let tv4 = Fp.mul(tv3, tv2);
          tv5 = Fp.pow(tv4, c5);
          let isQR = Fp.eql(tv5, Fp.ONE);
          tv2 = Fp.mul(tv3, c7);
          tv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, isQR);
          tv4 = Fp.cmov(tv5, tv4, isQR);
          for (let i = c1; i > _1n; i--) {
            let tv52 = i - _2n;
            tv52 = _2n << tv52 - _1n;
            let tvv5 = Fp.pow(tv4, tv52);
            const e1 = Fp.eql(tvv5, Fp.ONE);
            tv2 = Fp.mul(tv3, tv1);
            tv1 = Fp.mul(tv1, tv1);
            tvv5 = Fp.mul(tv4, tv1);
            tv3 = Fp.cmov(tv2, tv3, e1);
            tv4 = Fp.cmov(tvv5, tv4, e1);
          }
          return { isValid: isQR, value: tv3 };
        };
        if (Fp.ORDER % _4n === _3n) {
          const c12 = (Fp.ORDER - _3n) / _4n;
          const c22 = Fp.sqrt(Fp.neg(Z));
          sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v);
            const tv2 = Fp.mul(u, v);
            tv1 = Fp.mul(tv1, tv2);
            let y1 = Fp.pow(tv1, c12);
            y1 = Fp.mul(y1, tv2);
            const y2 = Fp.mul(y1, c22);
            const tv3 = Fp.mul(Fp.sqr(y1), v);
            const isQR = Fp.eql(tv3, u);
            let y = Fp.cmov(y2, y1, isQR);
            return { isValid: isQR, value: y };
          };
        }
        return sqrtRatio;
      }
      function mapToCurveSimpleSWU(Fp, opts) {
        (0, modular_ts_1.validateField)(Fp);
        const { A, B, Z } = opts;
        if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
          throw new Error("mapToCurveSimpleSWU: invalid opts");
        const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
        if (!Fp.isOdd)
          throw new Error("Field does not have .isOdd()");
        return (u) => {
          let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
          tv1 = Fp.sqr(u);
          tv1 = Fp.mul(tv1, Z);
          tv2 = Fp.sqr(tv1);
          tv2 = Fp.add(tv2, tv1);
          tv3 = Fp.add(tv2, Fp.ONE);
          tv3 = Fp.mul(tv3, B);
          tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
          tv4 = Fp.mul(tv4, A);
          tv2 = Fp.sqr(tv3);
          tv6 = Fp.sqr(tv4);
          tv5 = Fp.mul(tv6, A);
          tv2 = Fp.add(tv2, tv5);
          tv2 = Fp.mul(tv2, tv3);
          tv6 = Fp.mul(tv6, tv4);
          tv5 = Fp.mul(tv6, B);
          tv2 = Fp.add(tv2, tv5);
          x = Fp.mul(tv1, tv3);
          const { isValid, value } = sqrtRatio(tv2, tv6);
          y = Fp.mul(tv1, u);
          y = Fp.mul(y, value);
          x = Fp.cmov(x, tv3, isValid);
          y = Fp.cmov(y, value, isValid);
          const e1 = Fp.isOdd(u) === Fp.isOdd(y);
          y = Fp.cmov(Fp.neg(y), y, e1);
          const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
          x = Fp.mul(x, tv4_inv);
          return { x, y };
        };
      }
      function getWLengths(Fp, Fn) {
        return {
          secretKey: Fn.BYTES,
          publicKey: 1 + Fp.BYTES,
          publicKeyUncompressed: 1 + 2 * Fp.BYTES,
          publicKeyHasPrefix: true,
          signature: 2 * Fn.BYTES
        };
      }
      function ecdh(Point, ecdhOpts = {}) {
        const { Fn } = Point;
        const randomBytes_ = ecdhOpts.randomBytes || utils_ts_1.randomBytes;
        const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: (0, modular_ts_1.getMinHashLength)(Fn.ORDER) });
        function isValidSecretKey(secretKey) {
          try {
            return !!_normFnElement(Fn, secretKey);
          } catch (error) {
            return false;
          }
        }
        function isValidPublicKey(publicKey3, isCompressed) {
          const { publicKey: comp, publicKeyUncompressed } = lengths;
          try {
            const l = publicKey3.length;
            if (isCompressed === true && l !== comp)
              return false;
            if (isCompressed === false && l !== publicKeyUncompressed)
              return false;
            return !!Point.fromBytes(publicKey3);
          } catch (error) {
            return false;
          }
        }
        function randomSecretKey(seed2 = randomBytes_(lengths.seed)) {
          return (0, modular_ts_1.mapHashToField)((0, utils_ts_1._abytes2)(seed2, lengths.seed, "seed"), Fn.ORDER);
        }
        function getPublicKey(secretKey, isCompressed = true) {
          return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
        }
        function keygen(seed2) {
          const secretKey = randomSecretKey(seed2);
          return { secretKey, publicKey: getPublicKey(secretKey) };
        }
        function isProbPub(item) {
          if (typeof item === "bigint")
            return false;
          if (item instanceof Point)
            return true;
          const { secretKey, publicKey: publicKey3, publicKeyUncompressed } = lengths;
          if (Fn.allowedLengths || secretKey === publicKey3)
            return void 0;
          const l = (0, utils_ts_1.ensureBytes)("key", item).length;
          return l === publicKey3 || l === publicKeyUncompressed;
        }
        function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
          if (isProbPub(secretKeyA) === true)
            throw new Error("first arg must be private key");
          if (isProbPub(publicKeyB) === false)
            throw new Error("second arg must be public key");
          const s = _normFnElement(Fn, secretKeyA);
          const b = Point.fromHex(publicKeyB);
          return b.multiply(s).toBytes(isCompressed);
        }
        const utils = {
          isValidSecretKey,
          isValidPublicKey,
          randomSecretKey,
          // TODO: remove
          isValidPrivateKey: isValidSecretKey,
          randomPrivateKey: randomSecretKey,
          normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
          precompute(windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
          }
        };
        return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });
      }
      function ecdsa(Point, hash2, ecdsaOpts = {}) {
        (0, utils_1.ahash)(hash2);
        (0, utils_ts_1._validateObject)(ecdsaOpts, {}, {
          hmac: "function",
          lowS: "boolean",
          randomBytes: "function",
          bits2int: "function",
          bits2int_modN: "function"
        });
        const randomBytes = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
        const hmac = ecdsaOpts.hmac || ((key, ...msgs) => (0, hmac_js_1.hmac)(hash2, key, (0, utils_ts_1.concatBytes)(...msgs)));
        const { Fp, Fn } = Point;
        const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
        const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
        const defaultSigOpts = {
          prehash: false,
          lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
          format: void 0,
          //'compact' as ECDSASigFormat,
          extraEntropy: false
        };
        const defaultSigOpts_format = "compact";
        function isBiggerThanHalfOrder(number2) {
          const HALF = CURVE_ORDER >> _1n;
          return number2 > HALF;
        }
        function validateRS(title, num) {
          if (!Fn.isValidNot0(num))
            throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
          return num;
        }
        function validateSigLength(bytes, format) {
          validateSigFormat(format);
          const size = lengths.signature;
          const sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
          return (0, utils_ts_1._abytes2)(bytes, sizer, `${format} signature`);
        }
        class Signature {
          constructor(r, s, recovery) {
            this.r = validateRS("r", r);
            this.s = validateRS("s", s);
            if (recovery != null)
              this.recovery = recovery;
            Object.freeze(this);
          }
          static fromBytes(bytes, format = defaultSigOpts_format) {
            validateSigLength(bytes, format);
            let recid;
            if (format === "der") {
              const { r: r2, s: s2 } = exports.DER.toSig((0, utils_ts_1._abytes2)(bytes));
              return new Signature(r2, s2);
            }
            if (format === "recovered") {
              recid = bytes[0];
              format = "compact";
              bytes = bytes.subarray(1);
            }
            const L = Fn.BYTES;
            const r = bytes.subarray(0, L);
            const s = bytes.subarray(L, L * 2);
            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
          }
          static fromHex(hex2, format) {
            return this.fromBytes((0, utils_ts_1.hexToBytes)(hex2), format);
          }
          addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
          }
          recoverPublicKey(messageHash) {
            const FIELD_ORDER = Fp.ORDER;
            const { r, s, recovery: rec } = this;
            if (rec == null || ![0, 1, 2, 3].includes(rec))
              throw new Error("recovery id invalid");
            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
            if (hasCofactor && rec > 1)
              throw new Error("recovery id is ambiguous for h>1 curve");
            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
            if (!Fp.isValid(radj))
              throw new Error("recovery id 2 or 3 invalid");
            const x = Fp.toBytes(radj);
            const R = Point.fromBytes((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));
            const ir = Fn.inv(radj);
            const h = bits2int_modN((0, utils_ts_1.ensureBytes)("msgHash", messageHash));
            const u1 = Fn.create(-h * ir);
            const u2 = Fn.create(s * ir);
            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
            if (Q.is0())
              throw new Error("point at infinify");
            Q.assertValidity();
            return Q;
          }
          // Signatures should be low-s, to prevent malleability.
          hasHighS() {
            return isBiggerThanHalfOrder(this.s);
          }
          toBytes(format = defaultSigOpts_format) {
            validateSigFormat(format);
            if (format === "der")
              return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
            const r = Fn.toBytes(this.r);
            const s = Fn.toBytes(this.s);
            if (format === "recovered") {
              if (this.recovery == null)
                throw new Error("recovery bit must be present");
              return (0, utils_ts_1.concatBytes)(Uint8Array.of(this.recovery), r, s);
            }
            return (0, utils_ts_1.concatBytes)(r, s);
          }
          toHex(format) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(format));
          }
          // TODO: remove
          assertValidity() {
          }
          static fromCompact(hex2) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex2), "compact");
          }
          static fromDER(hex2) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex2), "der");
          }
          normalizeS() {
            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
          }
          toDERRawBytes() {
            return this.toBytes("der");
          }
          toDERHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes("der"));
          }
          toCompactRawBytes() {
            return this.toBytes("compact");
          }
          toCompactHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes("compact"));
          }
        }
        const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
          if (bytes.length > 8192)
            throw new Error("input is too large");
          const num = (0, utils_ts_1.bytesToNumberBE)(bytes);
          const delta = bytes.length * 8 - fnBits;
          return delta > 0 ? num >> BigInt(delta) : num;
        };
        const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
          return Fn.create(bits2int(bytes));
        };
        const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
        function int2octets(num) {
          (0, utils_ts_1.aInRange)("num < 2^" + fnBits, num, _0n, ORDER_MASK);
          return Fn.toBytes(num);
        }
        function validateMsgAndHash(message, prehash) {
          (0, utils_ts_1._abytes2)(message, void 0, "message");
          return prehash ? (0, utils_ts_1._abytes2)(hash2(message), void 0, "prehashed message") : message;
        }
        function prepSig(message, privateKey, opts) {
          if (["recovered", "canonical"].some((k) => k in opts))
            throw new Error("sign() legacy options not supported");
          const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
          message = validateMsgAndHash(message, prehash);
          const h1int = bits2int_modN(message);
          const d = _normFnElement(Fn, privateKey);
          const seedArgs = [int2octets(d), int2octets(h1int)];
          if (extraEntropy != null && extraEntropy !== false) {
            const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;
            seedArgs.push((0, utils_ts_1.ensureBytes)("extraEntropy", e));
          }
          const seed2 = (0, utils_ts_1.concatBytes)(...seedArgs);
          const m = h1int;
          function k2sig(kBytes) {
            const k = bits2int(kBytes);
            if (!Fn.isValidNot0(k))
              return;
            const ik = Fn.inv(k);
            const q = Point.BASE.multiply(k).toAffine();
            const r = Fn.create(q.x);
            if (r === _0n)
              return;
            const s = Fn.create(ik * Fn.create(m + r * d));
            if (s === _0n)
              return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
              normS = Fn.neg(s);
              recovery ^= 1;
            }
            return new Signature(r, normS, recovery);
          }
          return { seed: seed2, k2sig };
        }
        function sign(message, secretKey, opts = {}) {
          message = (0, utils_ts_1.ensureBytes)("message", message);
          const { seed: seed2, k2sig } = prepSig(message, secretKey, opts);
          const drbg = (0, utils_ts_1.createHmacDrbg)(hash2.outputLen, Fn.BYTES, hmac);
          const sig = drbg(seed2, k2sig);
          return sig;
        }
        function tryParsingSig(sg) {
          let sig = void 0;
          const isHex = typeof sg === "string" || (0, utils_ts_1.isBytes)(sg);
          const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
          if (!isHex && !isObj)
            throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
          if (isObj) {
            sig = new Signature(sg.r, sg.s);
          } else if (isHex) {
            try {
              sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", sg), "der");
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
            }
            if (!sig) {
              try {
                sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", sg), "compact");
              } catch (error) {
                return false;
              }
            }
          }
          if (!sig)
            return false;
          return sig;
        }
        function verify(signature, message, publicKey3, opts = {}) {
          const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
          publicKey3 = (0, utils_ts_1.ensureBytes)("publicKey", publicKey3);
          message = validateMsgAndHash((0, utils_ts_1.ensureBytes)("message", message), prehash);
          if ("strict" in opts)
            throw new Error("options.strict was renamed to lowS");
          const sig = format === void 0 ? tryParsingSig(signature) : Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", signature), format);
          if (sig === false)
            return false;
          try {
            const P = Point.fromBytes(publicKey3);
            if (lowS && sig.hasHighS())
              return false;
            const { r, s } = sig;
            const h = bits2int_modN(message);
            const is2 = Fn.inv(s);
            const u1 = Fn.create(h * is2);
            const u2 = Fn.create(r * is2);
            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
            if (R.is0())
              return false;
            const v = Fn.create(R.x);
            return v === r;
          } catch (e) {
            return false;
          }
        }
        function recoverPublicKey(signature, message, opts = {}) {
          const { prehash } = validateSigOpts(opts, defaultSigOpts);
          message = validateMsgAndHash(message, prehash);
          return Signature.fromBytes(signature, "recovered").recoverPublicKey(message).toBytes();
        }
        return Object.freeze({
          keygen,
          getPublicKey,
          getSharedSecret,
          utils,
          lengths,
          Point,
          sign,
          verify,
          recoverPublicKey,
          Signature,
          hash: hash2
        });
      }
      function weierstrassPoints(c) {
        const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
        const Point = weierstrassN(CURVE, curveOpts);
        return _weierstrass_new_output_to_legacy(c, Point);
      }
      function _weierstrass_legacy_opts_to_new(c) {
        const CURVE = {
          a: c.a,
          b: c.b,
          p: c.Fp.ORDER,
          n: c.n,
          h: c.h,
          Gx: c.Gx,
          Gy: c.Gy
        };
        const Fp = c.Fp;
        let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
        const Fn = (0, modular_ts_1.Field)(CURVE.n, {
          BITS: c.nBitLength,
          allowedLengths,
          modFromBytes: c.wrapPrivateKey
        });
        const curveOpts = {
          Fp,
          Fn,
          allowInfinityPoint: c.allowInfinityPoint,
          endo: c.endo,
          isTorsionFree: c.isTorsionFree,
          clearCofactor: c.clearCofactor,
          fromBytes: c.fromBytes,
          toBytes: c.toBytes
        };
        return { CURVE, curveOpts };
      }
      function _ecdsa_legacy_opts_to_new(c) {
        const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
        const ecdsaOpts = {
          hmac: c.hmac,
          randomBytes: c.randomBytes,
          lowS: c.lowS,
          bits2int: c.bits2int,
          bits2int_modN: c.bits2int_modN
        };
        return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
      }
      function _legacyHelperEquat(Fp, a, b) {
        function weierstrassEquation(x) {
          const x2 = Fp.sqr(x);
          const x3 = Fp.mul(x2, x);
          return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
        }
        return weierstrassEquation;
      }
      function _weierstrass_new_output_to_legacy(c, Point) {
        const { Fp, Fn } = Point;
        function isWithinCurveOrder(num) {
          return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);
        }
        const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);
        return Object.assign({}, {
          CURVE: c,
          Point,
          ProjectivePoint: Point,
          normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
          weierstrassEquation,
          isWithinCurveOrder
        });
      }
      function _ecdsa_new_output_to_legacy(c, _ecdsa) {
        const Point = _ecdsa.Point;
        return Object.assign({}, _ecdsa, {
          ProjectivePoint: Point,
          CURVE: Object.assign({}, c, (0, modular_ts_1.nLength)(Point.Fn.ORDER, Point.Fn.BITS))
        });
      }
      function weierstrass(c) {
        const { CURVE, curveOpts, hash: hash2, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
        const Point = weierstrassN(CURVE, curveOpts);
        const signs = ecdsa(Point, hash2, ecdsaOpts);
        return _ecdsa_new_output_to_legacy(c, signs);
      }
    }
  });

  // node_modules/@noble/curves/_shortw_utils.js
  var require_shortw_utils = __commonJS({
    "node_modules/@noble/curves/_shortw_utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getHash = getHash;
      exports.createCurve = createCurve;
      var weierstrass_ts_1 = require_weierstrass();
      function getHash(hash2) {
        return { hash: hash2 };
      }
      function createCurve(curveDef, defHash) {
        const create2 = (hash2) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash: hash2 });
        return { ...create2(defHash), create: create2 };
      }
    }
  });

  // node_modules/@noble/curves/secp256k1.js
  var require_secp256k1 = __commonJS({
    "node_modules/@noble/curves/secp256k1.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;
      var sha2_js_1 = require_sha2();
      var utils_js_1 = require_utils();
      var _shortw_utils_ts_1 = require_shortw_utils();
      var hash_to_curve_ts_1 = require_hash_to_curve();
      var modular_ts_1 = require_modular();
      var weierstrass_ts_1 = require_weierstrass();
      var utils_ts_1 = require_utils2();
      var secp256k1_CURVE = {
        p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
        n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
        h: BigInt(1),
        a: BigInt(0),
        b: BigInt(7),
        Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
      };
      var secp256k1_ENDO = {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        basises: [
          [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
          [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
        ]
      };
      var _0n = /* @__PURE__ */ BigInt(0);
      var _1n = /* @__PURE__ */ BigInt(1);
      var _2n = /* @__PURE__ */ BigInt(2);
      function sqrtMod(y) {
        const P = secp256k1_CURVE.p;
        const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
        const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
        const b2 = y * y * y % P;
        const b3 = b2 * b2 * y % P;
        const b6 = (0, modular_ts_1.pow2)(b3, _3n, P) * b3 % P;
        const b9 = (0, modular_ts_1.pow2)(b6, _3n, P) * b3 % P;
        const b11 = (0, modular_ts_1.pow2)(b9, _2n, P) * b2 % P;
        const b22 = (0, modular_ts_1.pow2)(b11, _11n, P) * b11 % P;
        const b44 = (0, modular_ts_1.pow2)(b22, _22n, P) * b22 % P;
        const b88 = (0, modular_ts_1.pow2)(b44, _44n, P) * b44 % P;
        const b176 = (0, modular_ts_1.pow2)(b88, _88n, P) * b88 % P;
        const b220 = (0, modular_ts_1.pow2)(b176, _44n, P) * b44 % P;
        const b223 = (0, modular_ts_1.pow2)(b220, _3n, P) * b3 % P;
        const t1 = (0, modular_ts_1.pow2)(b223, _23n, P) * b22 % P;
        const t2 = (0, modular_ts_1.pow2)(t1, _6n, P) * b2 % P;
        const root = (0, modular_ts_1.pow2)(t2, _2n, P);
        if (!Fpk1.eql(Fpk1.sqr(root), y))
          throw new Error("Cannot find square root");
        return root;
      }
      var Fpk1 = (0, modular_ts_1.Field)(secp256k1_CURVE.p, { sqrt: sqrtMod });
      exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha2_js_1.sha256);
      var TAGGED_HASH_PREFIXES = {};
      function taggedHash(tag, ...messages2) {
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === void 0) {
          const tagH = (0, sha2_js_1.sha256)((0, utils_ts_1.utf8ToBytes)(tag));
          tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
          TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return (0, sha2_js_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages2));
      }
      var pointToBytes = (point) => point.toBytes(true).slice(1);
      var Pointk1 = /* @__PURE__ */ (() => exports.secp256k1.Point)();
      var hasEven = (y) => y % _2n === _0n;
      function schnorrGetExtPubKey(priv) {
        const { Fn, BASE } = Pointk1;
        const d_ = (0, weierstrass_ts_1._normFnElement)(Fn, priv);
        const p = BASE.multiply(d_);
        const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);
        return { scalar, bytes: pointToBytes(p) };
      }
      function lift_x(x) {
        const Fp = Fpk1;
        if (!Fp.isValidNot0(x))
          throw new Error("invalid x: Fail if x \u2265 p");
        const xx = Fp.create(x * x);
        const c = Fp.create(xx * x + BigInt(7));
        let y = Fp.sqrt(c);
        if (!hasEven(y))
          y = Fp.neg(y);
        const p = Pointk1.fromAffine({ x, y });
        p.assertValidity();
        return p;
      }
      var num = utils_ts_1.bytesToNumberBE;
      function challenge(...args) {
        return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
      }
      function schnorrGetPublicKey(secretKey) {
        return schnorrGetExtPubKey(secretKey).bytes;
      }
      function schnorrSign(message, secretKey, auxRand = (0, utils_js_1.randomBytes)(32)) {
        const { Fn } = Pointk1;
        const m = (0, utils_ts_1.ensureBytes)("message", message);
        const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
        const a = (0, utils_ts_1.ensureBytes)("auxRand", auxRand, 32);
        const t = Fn.toBytes(d ^ num(taggedHash("BIP0340/aux", a)));
        const rand = taggedHash("BIP0340/nonce", t, px, m);
        const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
        const e = challenge(rx, px, m);
        const sig = new Uint8Array(64);
        sig.set(rx, 0);
        sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
        if (!schnorrVerify(sig, m, px))
          throw new Error("sign: Invalid signature produced");
        return sig;
      }
      function schnorrVerify(signature, message, publicKey3) {
        const { Fn, BASE } = Pointk1;
        const sig = (0, utils_ts_1.ensureBytes)("signature", signature, 64);
        const m = (0, utils_ts_1.ensureBytes)("message", message);
        const pub = (0, utils_ts_1.ensureBytes)("publicKey", publicKey3, 32);
        try {
          const P = lift_x(num(pub));
          const r = num(sig.subarray(0, 32));
          if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1_CURVE.p))
            return false;
          const s = num(sig.subarray(32, 64));
          if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1_CURVE.n))
            return false;
          const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
          const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
          const { x, y } = R.toAffine();
          if (R.is0() || !hasEven(y) || x !== r)
            return false;
          return true;
        } catch (error) {
          return false;
        }
      }
      exports.schnorr = (() => {
        const size = 32;
        const seedLength = 48;
        const randomSecretKey = (seed2 = (0, utils_js_1.randomBytes)(seedLength)) => {
          return (0, modular_ts_1.mapHashToField)(seed2, secp256k1_CURVE.n);
        };
        exports.secp256k1.utils.randomSecretKey;
        function keygen(seed2) {
          const secretKey = randomSecretKey(seed2);
          return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
        }
        return {
          keygen,
          getPublicKey: schnorrGetPublicKey,
          sign: schnorrSign,
          verify: schnorrVerify,
          Point: Pointk1,
          utils: {
            randomSecretKey,
            randomPrivateKey: randomSecretKey,
            taggedHash,
            // TODO: remove
            lift_x,
            pointToBytes,
            numberToBytesBE: utils_ts_1.numberToBytesBE,
            bytesToNumberBE: utils_ts_1.bytesToNumberBE,
            mod: modular_ts_1.mod
          },
          lengths: {
            secretKey: size,
            publicKey: size,
            publicKeyHasPrefix: false,
            signature: size * 2,
            seed: seedLength
          }
        };
      })();
      var isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [
        // xNum
        [
          "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
          "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
          "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
          "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
        ],
        // xDen
        [
          "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
          "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
          "0x0000000000000000000000000000000000000000000000000000000000000001"
          // LAST 1
        ],
        // yNum
        [
          "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
          "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
          "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
          "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
        ],
        // yDen
        [
          "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
          "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
          "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
          "0x0000000000000000000000000000000000000000000000000000000000000001"
          // LAST 1
        ]
      ].map((i) => i.map((j) => BigInt(j)))))();
      var mapSWU = /* @__PURE__ */ (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
        A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
        B: BigInt("1771"),
        Z: Fpk1.create(BigInt("-11"))
      }))();
      exports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.Point, (scalars) => {
        const { x, y } = mapSWU(Fpk1.create(scalars[0]));
        return isoMap(x, y);
      }, {
        DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
        encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
        p: Fpk1.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha2_js_1.sha256
      }))();
      exports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();
      exports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();
    }
  });

  // node_modules/@solana/web3.js/lib/index.browser.cjs.js
  var require_index_browser_cjs = __commonJS({
    "node_modules/@solana/web3.js/lib/index.browser.cjs.js"(exports) {
      "use strict";
      var buffer = require_buffer();
      var ed25519 = require_ed25519();
      var BN2 = require_bn();
      var bs582 = require_bs58();
      var sha2564 = require_sha256();
      var borsh2 = require_lib();
      var BufferLayout = require_Layout();
      var bigintBuffer = require_browser();
      var superstruct = require_dist();
      var RpcClient = require_browser2();
      var rpcWebsockets = require_index_browser();
      var sha3 = require_sha3();
      var secp256k1 = require_secp256k1();
      function _interopDefaultCompat(e) {
        return e && typeof e === "object" && "default" in e ? e : { default: e };
      }
      function _interopNamespaceCompat(e) {
        if (e && typeof e === "object" && "default" in e) return e;
        var n = /* @__PURE__ */ Object.create(null);
        if (e) {
          Object.keys(e).forEach(function(k) {
            if (k !== "default") {
              var d = Object.getOwnPropertyDescriptor(e, k);
              Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: function() {
                  return e[k];
                }
              });
            }
          });
        }
        n.default = e;
        return Object.freeze(n);
      }
      var BN__default = /* @__PURE__ */ _interopDefaultCompat(BN2);
      var bs58__default = /* @__PURE__ */ _interopDefaultCompat(bs582);
      var BufferLayout__namespace = /* @__PURE__ */ _interopNamespaceCompat(BufferLayout);
      var RpcClient__default = /* @__PURE__ */ _interopDefaultCompat(RpcClient);
      var generatePrivateKey = ed25519.ed25519.utils.randomPrivateKey;
      var generateKeypair = () => {
        const privateScalar = ed25519.ed25519.utils.randomPrivateKey();
        const publicKey4 = getPublicKey(privateScalar);
        const secretKey = new Uint8Array(64);
        secretKey.set(privateScalar);
        secretKey.set(publicKey4, 32);
        return {
          publicKey: publicKey4,
          secretKey
        };
      };
      var getPublicKey = ed25519.ed25519.getPublicKey;
      function isOnCurve(publicKey4) {
        try {
          ed25519.ed25519.ExtendedPoint.fromHex(publicKey4);
          return true;
        } catch {
          return false;
        }
      }
      var sign = (message, secretKey) => ed25519.ed25519.sign(message, secretKey.slice(0, 32));
      var verify = ed25519.ed25519.verify;
      var toBuffer = (arr) => {
        if (buffer.Buffer.isBuffer(arr)) {
          return arr;
        } else if (arr instanceof Uint8Array) {
          return buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
        } else {
          return buffer.Buffer.from(arr);
        }
      };
      var Struct2 = class {
        constructor(properties) {
          Object.assign(this, properties);
        }
        encode() {
          return buffer.Buffer.from(borsh2.serialize(SOLANA_SCHEMA, this));
        }
        static decode(data) {
          return borsh2.deserialize(SOLANA_SCHEMA, this, data);
        }
        static decodeUnchecked(data) {
          return borsh2.deserializeUnchecked(SOLANA_SCHEMA, this, data);
        }
      };
      var Enum = class extends Struct2 {
        constructor(properties) {
          super(properties);
          this.enum = "";
          if (Object.keys(properties).length !== 1) {
            throw new Error("Enum can only take single value");
          }
          Object.keys(properties).map((key) => {
            this.enum = key;
          });
        }
      };
      var SOLANA_SCHEMA = /* @__PURE__ */ new Map();
      var _PublicKey;
      var MAX_SEED_LENGTH = 32;
      var PUBLIC_KEY_LENGTH = 32;
      function isPublicKeyData(value) {
        return value._bn !== void 0;
      }
      var uniquePublicKeyCounter = 1;
      var PublicKey2 = class _PublicKey2 extends Struct2 {
        /**
         * Create a new PublicKey object
         * @param value ed25519 public key as buffer or base-58 encoded string
         */
        constructor(value) {
          super({});
          this._bn = void 0;
          if (isPublicKeyData(value)) {
            this._bn = value._bn;
          } else {
            if (typeof value === "string") {
              const decoded = bs58__default.default.decode(value);
              if (decoded.length != PUBLIC_KEY_LENGTH) {
                throw new Error(`Invalid public key input`);
              }
              this._bn = new BN__default.default(decoded);
            } else {
              this._bn = new BN__default.default(value);
            }
            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
              throw new Error(`Invalid public key input`);
            }
          }
        }
        /**
         * Returns a unique PublicKey for tests and benchmarks using a counter
         */
        static unique() {
          const key = new _PublicKey2(uniquePublicKeyCounter);
          uniquePublicKeyCounter += 1;
          return new _PublicKey2(key.toBuffer());
        }
        /**
         * Default public key value. The base58-encoded string representation is all ones (as seen below)
         * The underlying BN number is 32 bytes that are all zeros
         */
        /**
         * Checks if two publicKeys are equal
         */
        equals(publicKey4) {
          return this._bn.eq(publicKey4._bn);
        }
        /**
         * Return the base-58 representation of the public key
         */
        toBase58() {
          return bs58__default.default.encode(this.toBytes());
        }
        toJSON() {
          return this.toBase58();
        }
        /**
         * Return the byte array representation of the public key in big endian
         */
        toBytes() {
          const buf = this.toBuffer();
          return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
        }
        /**
         * Return the Buffer representation of the public key in big endian
         */
        toBuffer() {
          const b = this._bn.toArrayLike(buffer.Buffer);
          if (b.length === PUBLIC_KEY_LENGTH) {
            return b;
          }
          const zeroPad = buffer.Buffer.alloc(32);
          b.copy(zeroPad, 32 - b.length);
          return zeroPad;
        }
        get [Symbol.toStringTag]() {
          return `PublicKey(${this.toString()})`;
        }
        /**
         * Return the base-58 representation of the public key
         */
        toString() {
          return this.toBase58();
        }
        /**
         * Derive a public key from another key, a seed, and a program ID.
         * The program ID will also serve as the owner of the public key, giving
         * it permission to write data to the account.
         */
        /* eslint-disable require-await */
        static async createWithSeed(fromPublicKey, seed2, programId) {
          const buffer$1 = buffer.Buffer.concat([fromPublicKey.toBuffer(), buffer.Buffer.from(seed2), programId.toBuffer()]);
          const publicKeyBytes = sha2564.sha256(buffer$1);
          return new _PublicKey2(publicKeyBytes);
        }
        /**
         * Derive a program address from seeds and a program ID.
         */
        /* eslint-disable require-await */
        static createProgramAddressSync(seeds, programId) {
          let buffer$1 = buffer.Buffer.alloc(0);
          seeds.forEach(function(seed2) {
            if (seed2.length > MAX_SEED_LENGTH) {
              throw new TypeError(`Max seed length exceeded`);
            }
            buffer$1 = buffer.Buffer.concat([buffer$1, toBuffer(seed2)]);
          });
          buffer$1 = buffer.Buffer.concat([buffer$1, programId.toBuffer(), buffer.Buffer.from("ProgramDerivedAddress")]);
          const publicKeyBytes = sha2564.sha256(buffer$1);
          if (isOnCurve(publicKeyBytes)) {
            throw new Error(`Invalid seeds, address must fall off the curve`);
          }
          return new _PublicKey2(publicKeyBytes);
        }
        /**
         * Async version of createProgramAddressSync
         * For backwards compatibility
         *
         * @deprecated Use {@link createProgramAddressSync} instead
         */
        /* eslint-disable require-await */
        static async createProgramAddress(seeds, programId) {
          return this.createProgramAddressSync(seeds, programId);
        }
        /**
         * Find a valid program address
         *
         * Valid program addresses must fall off the ed25519 curve.  This function
         * iterates a nonce until it finds one that when combined with the seeds
         * results in a valid program address.
         */
        static findProgramAddressSync(seeds, programId) {
          let nonce = 255;
          let address;
          while (nonce != 0) {
            try {
              const seedsWithNonce = seeds.concat(buffer.Buffer.from([nonce]));
              address = this.createProgramAddressSync(seedsWithNonce, programId);
            } catch (err2) {
              if (err2 instanceof TypeError) {
                throw err2;
              }
              nonce--;
              continue;
            }
            return [address, nonce];
          }
          throw new Error(`Unable to find a viable program address nonce`);
        }
        /**
         * Async version of findProgramAddressSync
         * For backwards compatibility
         *
         * @deprecated Use {@link findProgramAddressSync} instead
         */
        static async findProgramAddress(seeds, programId) {
          return this.findProgramAddressSync(seeds, programId);
        }
        /**
         * Check that a pubkey is on the ed25519 curve.
         */
        static isOnCurve(pubkeyData) {
          const pubkey2 = new _PublicKey2(pubkeyData);
          return isOnCurve(pubkey2.toBytes());
        }
      };
      _PublicKey = PublicKey2;
      PublicKey2.default = new _PublicKey("11111111111111111111111111111111");
      SOLANA_SCHEMA.set(PublicKey2, {
        kind: "struct",
        fields: [["_bn", "u256"]]
      });
      var Account = class {
        /**
         * Create a new Account object
         *
         * If the secretKey parameter is not provided a new key pair is randomly
         * created for the account
         *
         * @param secretKey Secret key for the account
         */
        constructor(secretKey) {
          this._publicKey = void 0;
          this._secretKey = void 0;
          if (secretKey) {
            const secretKeyBuffer = toBuffer(secretKey);
            if (secretKey.length !== 64) {
              throw new Error("bad secret key size");
            }
            this._publicKey = secretKeyBuffer.slice(32, 64);
            this._secretKey = secretKeyBuffer.slice(0, 32);
          } else {
            this._secretKey = toBuffer(generatePrivateKey());
            this._publicKey = toBuffer(getPublicKey(this._secretKey));
          }
        }
        /**
         * The public key for this account
         */
        get publicKey() {
          return new PublicKey2(this._publicKey);
        }
        /**
         * The **unencrypted** secret key for this account. The first 32 bytes
         * is the private scalar and the last 32 bytes is the public key.
         * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
         */
        get secretKey() {
          return buffer.Buffer.concat([this._secretKey, this._publicKey], 64);
        }
      };
      var BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey2("BPFLoader1111111111111111111111111111111111");
      var PACKET_DATA_SIZE = 1280 - 40 - 8;
      var VERSION_PREFIX_MASK = 127;
      var SIGNATURE_LENGTH_IN_BYTES = 64;
      var TransactionExpiredBlockheightExceededError = class extends Error {
        constructor(signature2) {
          super(`Signature ${signature2} has expired: block height exceeded.`);
          this.signature = void 0;
          this.signature = signature2;
        }
      };
      Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
        value: "TransactionExpiredBlockheightExceededError"
      });
      var TransactionExpiredTimeoutError = class extends Error {
        constructor(signature2, timeoutSeconds) {
          super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature2} using the Solana Explorer or CLI tools.`);
          this.signature = void 0;
          this.signature = signature2;
        }
      };
      Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
        value: "TransactionExpiredTimeoutError"
      });
      var TransactionExpiredNonceInvalidError = class extends Error {
        constructor(signature2) {
          super(`Signature ${signature2} has expired: the nonce is no longer valid.`);
          this.signature = void 0;
          this.signature = signature2;
        }
      };
      Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
        value: "TransactionExpiredNonceInvalidError"
      });
      var MessageAccountKeys = class {
        constructor(staticAccountKeys, accountKeysFromLookups) {
          this.staticAccountKeys = void 0;
          this.accountKeysFromLookups = void 0;
          this.staticAccountKeys = staticAccountKeys;
          this.accountKeysFromLookups = accountKeysFromLookups;
        }
        keySegments() {
          const keySegments = [this.staticAccountKeys];
          if (this.accountKeysFromLookups) {
            keySegments.push(this.accountKeysFromLookups.writable);
            keySegments.push(this.accountKeysFromLookups.readonly);
          }
          return keySegments;
        }
        get(index2) {
          for (const keySegment of this.keySegments()) {
            if (index2 < keySegment.length) {
              return keySegment[index2];
            } else {
              index2 -= keySegment.length;
            }
          }
          return;
        }
        get length() {
          return this.keySegments().flat().length;
        }
        compileInstructions(instructions) {
          const U8_MAX = 255;
          if (this.length > U8_MAX + 1) {
            throw new Error("Account index overflow encountered during compilation");
          }
          const keyIndexMap = /* @__PURE__ */ new Map();
          this.keySegments().flat().forEach((key, index2) => {
            keyIndexMap.set(key.toBase58(), index2);
          });
          const findKeyIndex = (key) => {
            const keyIndex = keyIndexMap.get(key.toBase58());
            if (keyIndex === void 0) throw new Error("Encountered an unknown instruction account key during compilation");
            return keyIndex;
          };
          return instructions.map((instruction) => {
            return {
              programIdIndex: findKeyIndex(instruction.programId),
              accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
              data: instruction.data
            };
          });
        }
      };
      var publicKey3 = (property = "publicKey") => {
        return BufferLayout__namespace.blob(32, property);
      };
      var signature = (property = "signature") => {
        return BufferLayout__namespace.blob(64, property);
      };
      var rustString = (property = "string") => {
        const rsl = BufferLayout__namespace.struct([BufferLayout__namespace.u32("length"), BufferLayout__namespace.u32("lengthPadding"), BufferLayout__namespace.blob(BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "chars")], property);
        const _decode = rsl.decode.bind(rsl);
        const _encode = rsl.encode.bind(rsl);
        const rslShim = rsl;
        rslShim.decode = (b, offset2) => {
          const data = _decode(b, offset2);
          return data["chars"].toString();
        };
        rslShim.encode = (str2, b, offset2) => {
          const data = {
            chars: buffer.Buffer.from(str2, "utf8")
          };
          return _encode(data, b, offset2);
        };
        rslShim.alloc = (str2) => {
          return BufferLayout__namespace.u32().span + BufferLayout__namespace.u32().span + buffer.Buffer.from(str2, "utf8").length;
        };
        return rslShim;
      };
      var authorized = (property = "authorized") => {
        return BufferLayout__namespace.struct([publicKey3("staker"), publicKey3("withdrawer")], property);
      };
      var lockup = (property = "lockup") => {
        return BufferLayout__namespace.struct([BufferLayout__namespace.ns64("unixTimestamp"), BufferLayout__namespace.ns64("epoch"), publicKey3("custodian")], property);
      };
      var voteInit = (property = "voteInit") => {
        return BufferLayout__namespace.struct([publicKey3("nodePubkey"), publicKey3("authorizedVoter"), publicKey3("authorizedWithdrawer"), BufferLayout__namespace.u8("commission")], property);
      };
      var voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
        return BufferLayout__namespace.struct([BufferLayout__namespace.u32("voteAuthorizationType"), publicKey3("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey3("newAuthorized")], property);
      };
      function getAlloc(type2, fields) {
        const getItemAlloc = (item) => {
          if (item.span >= 0) {
            return item.span;
          } else if (typeof item.alloc === "function") {
            return item.alloc(fields[item.property]);
          } else if ("count" in item && "elementLayout" in item) {
            const field = fields[item.property];
            if (Array.isArray(field)) {
              return field.length * getItemAlloc(item.elementLayout);
            }
          } else if ("fields" in item) {
            return getAlloc({
              layout: item
            }, fields[item.property]);
          }
          return 0;
        };
        let alloc = 0;
        type2.layout.fields.forEach((item) => {
          alloc += getItemAlloc(item);
        });
        return alloc;
      }
      function decodeLength(bytes) {
        let len = 0;
        let size = 0;
        for (; ; ) {
          let elem = bytes.shift();
          len |= (elem & 127) << size * 7;
          size += 1;
          if ((elem & 128) === 0) {
            break;
          }
        }
        return len;
      }
      function encodeLength(bytes, len) {
        let rem_len = len;
        for (; ; ) {
          let elem = rem_len & 127;
          rem_len >>= 7;
          if (rem_len == 0) {
            bytes.push(elem);
            break;
          } else {
            elem |= 128;
            bytes.push(elem);
          }
        }
      }
      function assert2(condition, message) {
        if (!condition) {
          throw new Error(message || "Assertion failed");
        }
      }
      var CompiledKeys = class _CompiledKeys {
        constructor(payer, keyMetaMap) {
          this.payer = void 0;
          this.keyMetaMap = void 0;
          this.payer = payer;
          this.keyMetaMap = keyMetaMap;
        }
        static compile(instructions, payer) {
          const keyMetaMap = /* @__PURE__ */ new Map();
          const getOrInsertDefault = (pubkey2) => {
            const address = pubkey2.toBase58();
            let keyMeta = keyMetaMap.get(address);
            if (keyMeta === void 0) {
              keyMeta = {
                isSigner: false,
                isWritable: false,
                isInvoked: false
              };
              keyMetaMap.set(address, keyMeta);
            }
            return keyMeta;
          };
          const payerKeyMeta = getOrInsertDefault(payer);
          payerKeyMeta.isSigner = true;
          payerKeyMeta.isWritable = true;
          for (const ix of instructions) {
            getOrInsertDefault(ix.programId).isInvoked = true;
            for (const accountMeta of ix.keys) {
              const keyMeta = getOrInsertDefault(accountMeta.pubkey);
              keyMeta.isSigner ||= accountMeta.isSigner;
              keyMeta.isWritable ||= accountMeta.isWritable;
            }
          }
          return new _CompiledKeys(payer, keyMetaMap);
        }
        getMessageComponents() {
          const mapEntries = [...this.keyMetaMap.entries()];
          assert2(mapEntries.length <= 256, "Max static account keys length exceeded");
          const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
          const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
          const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
          const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
          const header = {
            numRequiredSignatures: writableSigners.length + readonlySigners.length,
            numReadonlySignedAccounts: readonlySigners.length,
            numReadonlyUnsignedAccounts: readonlyNonSigners.length
          };
          {
            assert2(writableSigners.length > 0, "Expected at least one writable signer key");
            const [payerAddress] = writableSigners[0];
            assert2(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
          }
          const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey2(address)), ...readonlySigners.map(([address]) => new PublicKey2(address)), ...writableNonSigners.map(([address]) => new PublicKey2(address)), ...readonlyNonSigners.map(([address]) => new PublicKey2(address))];
          return [header, staticAccountKeys];
        }
        extractTableLookup(lookupTable) {
          const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
          const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
          if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
            return;
          }
          return [{
            accountKey: lookupTable.key,
            writableIndexes,
            readonlyIndexes
          }, {
            writable: drainedWritableKeys,
            readonly: drainedReadonlyKeys
          }];
        }
        /** @internal */
        drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
          const lookupTableIndexes = new Array();
          const drainedKeys = new Array();
          for (const [address, keyMeta] of this.keyMetaMap.entries()) {
            if (keyMetaFilter(keyMeta)) {
              const key = new PublicKey2(address);
              const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
              if (lookupTableIndex >= 0) {
                assert2(lookupTableIndex < 256, "Max lookup table index exceeded");
                lookupTableIndexes.push(lookupTableIndex);
                drainedKeys.push(key);
                this.keyMetaMap.delete(address);
              }
            }
          }
          return [lookupTableIndexes, drainedKeys];
        }
      };
      var END_OF_BUFFER_ERROR_MESSAGE = "Reached end of buffer unexpectedly";
      function guardedShift(byteArray) {
        if (byteArray.length === 0) {
          throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
        }
        return byteArray.shift();
      }
      function guardedSplice(byteArray, ...args) {
        const [start] = args;
        if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
          throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
        }
        return byteArray.splice(...args);
      }
      var Message = class _Message {
        constructor(args) {
          this.header = void 0;
          this.accountKeys = void 0;
          this.recentBlockhash = void 0;
          this.instructions = void 0;
          this.indexToProgramIds = /* @__PURE__ */ new Map();
          this.header = args.header;
          this.accountKeys = args.accountKeys.map((account) => new PublicKey2(account));
          this.recentBlockhash = args.recentBlockhash;
          this.instructions = args.instructions;
          this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
        }
        get version() {
          return "legacy";
        }
        get staticAccountKeys() {
          return this.accountKeys;
        }
        get compiledInstructions() {
          return this.instructions.map((ix) => ({
            programIdIndex: ix.programIdIndex,
            accountKeyIndexes: ix.accounts,
            data: bs58__default.default.decode(ix.data)
          }));
        }
        get addressTableLookups() {
          return [];
        }
        getAccountKeys() {
          return new MessageAccountKeys(this.staticAccountKeys);
        }
        static compile(args) {
          const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
          const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
          const accountKeys = new MessageAccountKeys(staticAccountKeys);
          const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
            programIdIndex: ix.programIdIndex,
            accounts: ix.accountKeyIndexes,
            data: bs58__default.default.encode(ix.data)
          }));
          return new _Message({
            header,
            accountKeys: staticAccountKeys,
            recentBlockhash: args.recentBlockhash,
            instructions
          });
        }
        isAccountSigner(index2) {
          return index2 < this.header.numRequiredSignatures;
        }
        isAccountWritable(index2) {
          const numSignedAccounts = this.header.numRequiredSignatures;
          if (index2 >= this.header.numRequiredSignatures) {
            const unsignedAccountIndex = index2 - numSignedAccounts;
            const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
            return unsignedAccountIndex < numWritableUnsignedAccounts;
          } else {
            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
            return index2 < numWritableSignedAccounts;
          }
        }
        isProgramId(index2) {
          return this.indexToProgramIds.has(index2);
        }
        programIds() {
          return [...this.indexToProgramIds.values()];
        }
        nonProgramIds() {
          return this.accountKeys.filter((_, index2) => !this.isProgramId(index2));
        }
        serialize() {
          const numKeys = this.accountKeys.length;
          let keyCount = [];
          encodeLength(keyCount, numKeys);
          const instructions = this.instructions.map((instruction) => {
            const {
              accounts,
              programIdIndex
            } = instruction;
            const data = Array.from(bs58__default.default.decode(instruction.data));
            let keyIndicesCount = [];
            encodeLength(keyIndicesCount, accounts.length);
            let dataCount = [];
            encodeLength(dataCount, data.length);
            return {
              programIdIndex,
              keyIndicesCount: buffer.Buffer.from(keyIndicesCount),
              keyIndices: accounts,
              dataLength: buffer.Buffer.from(dataCount),
              data
            };
          });
          let instructionCount = [];
          encodeLength(instructionCount, instructions.length);
          let instructionBuffer = buffer.Buffer.alloc(PACKET_DATA_SIZE);
          buffer.Buffer.from(instructionCount).copy(instructionBuffer);
          let instructionBufferLength = instructionCount.length;
          instructions.forEach((instruction) => {
            const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8("programIdIndex"), BufferLayout__namespace.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout__namespace.seq(BufferLayout__namespace.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout__namespace.blob(instruction.dataLength.length, "dataLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8("userdatum"), instruction.data.length, "data")]);
            const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
            instructionBufferLength += length2;
          });
          instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
          const signDataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.blob(1, "numRequiredSignatures"), BufferLayout__namespace.blob(1, "numReadonlySignedAccounts"), BufferLayout__namespace.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout__namespace.blob(keyCount.length, "keyCount"), BufferLayout__namespace.seq(publicKey3("key"), numKeys, "keys"), publicKey3("recentBlockhash")]);
          const transaction = {
            numRequiredSignatures: buffer.Buffer.from([this.header.numRequiredSignatures]),
            numReadonlySignedAccounts: buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
            numReadonlyUnsignedAccounts: buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
            keyCount: buffer.Buffer.from(keyCount),
            keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
            recentBlockhash: bs58__default.default.decode(this.recentBlockhash)
          };
          let signData = buffer.Buffer.alloc(2048);
          const length = signDataLayout.encode(transaction, signData);
          instructionBuffer.copy(signData, length);
          return signData.slice(0, length + instructionBuffer.length);
        }
        /**
         * Decode a compiled message into a Message object.
         */
        static from(buffer$1) {
          let byteArray = [...buffer$1];
          const numRequiredSignatures = guardedShift(byteArray);
          if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
            throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
          }
          const numReadonlySignedAccounts = guardedShift(byteArray);
          const numReadonlyUnsignedAccounts = guardedShift(byteArray);
          const accountCount = decodeLength(byteArray);
          let accountKeys = [];
          for (let i = 0; i < accountCount; i++) {
            const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
            accountKeys.push(new PublicKey2(buffer.Buffer.from(account)));
          }
          const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
          const instructionCount = decodeLength(byteArray);
          let instructions = [];
          for (let i = 0; i < instructionCount; i++) {
            const programIdIndex = guardedShift(byteArray);
            const accountCount2 = decodeLength(byteArray);
            const accounts = guardedSplice(byteArray, 0, accountCount2);
            const dataLength = decodeLength(byteArray);
            const dataSlice = guardedSplice(byteArray, 0, dataLength);
            const data = bs58__default.default.encode(buffer.Buffer.from(dataSlice));
            instructions.push({
              programIdIndex,
              accounts,
              data
            });
          }
          const messageArgs = {
            header: {
              numRequiredSignatures,
              numReadonlySignedAccounts,
              numReadonlyUnsignedAccounts
            },
            recentBlockhash: bs58__default.default.encode(buffer.Buffer.from(recentBlockhash)),
            accountKeys,
            instructions
          };
          return new _Message(messageArgs);
        }
      };
      var MessageV0 = class _MessageV0 {
        constructor(args) {
          this.header = void 0;
          this.staticAccountKeys = void 0;
          this.recentBlockhash = void 0;
          this.compiledInstructions = void 0;
          this.addressTableLookups = void 0;
          this.header = args.header;
          this.staticAccountKeys = args.staticAccountKeys;
          this.recentBlockhash = args.recentBlockhash;
          this.compiledInstructions = args.compiledInstructions;
          this.addressTableLookups = args.addressTableLookups;
        }
        get version() {
          return 0;
        }
        get numAccountKeysFromLookups() {
          let count = 0;
          for (const lookup of this.addressTableLookups) {
            count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
          }
          return count;
        }
        getAccountKeys(args) {
          let accountKeysFromLookups;
          if (args && "accountKeysFromLookups" in args && args.accountKeysFromLookups) {
            if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
              throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
            }
            accountKeysFromLookups = args.accountKeysFromLookups;
          } else if (args && "addressLookupTableAccounts" in args && args.addressLookupTableAccounts) {
            accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
          } else if (this.addressTableLookups.length > 0) {
            throw new Error("Failed to get account keys because address table lookups were not resolved");
          }
          return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
        }
        isAccountSigner(index2) {
          return index2 < this.header.numRequiredSignatures;
        }
        isAccountWritable(index2) {
          const numSignedAccounts = this.header.numRequiredSignatures;
          const numStaticAccountKeys = this.staticAccountKeys.length;
          if (index2 >= numStaticAccountKeys) {
            const lookupAccountKeysIndex = index2 - numStaticAccountKeys;
            const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup) => count + lookup.writableIndexes.length, 0);
            return lookupAccountKeysIndex < numWritableLookupAccountKeys;
          } else if (index2 >= this.header.numRequiredSignatures) {
            const unsignedAccountIndex = index2 - numSignedAccounts;
            const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
            return unsignedAccountIndex < numWritableUnsignedAccounts;
          } else {
            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
            return index2 < numWritableSignedAccounts;
          }
        }
        resolveAddressTableLookups(addressLookupTableAccounts) {
          const accountKeysFromLookups = {
            writable: [],
            readonly: []
          };
          for (const tableLookup of this.addressTableLookups) {
            const tableAccount = addressLookupTableAccounts.find((account) => account.key.equals(tableLookup.accountKey));
            if (!tableAccount) {
              throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
            }
            for (const index2 of tableLookup.writableIndexes) {
              if (index2 < tableAccount.state.addresses.length) {
                accountKeysFromLookups.writable.push(tableAccount.state.addresses[index2]);
              } else {
                throw new Error(`Failed to find address for index ${index2} in address lookup table ${tableLookup.accountKey.toBase58()}`);
              }
            }
            for (const index2 of tableLookup.readonlyIndexes) {
              if (index2 < tableAccount.state.addresses.length) {
                accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index2]);
              } else {
                throw new Error(`Failed to find address for index ${index2} in address lookup table ${tableLookup.accountKey.toBase58()}`);
              }
            }
          }
          return accountKeysFromLookups;
        }
        static compile(args) {
          const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
          const addressTableLookups = new Array();
          const accountKeysFromLookups = {
            writable: new Array(),
            readonly: new Array()
          };
          const lookupTableAccounts = args.addressLookupTableAccounts || [];
          for (const lookupTable of lookupTableAccounts) {
            const extractResult = compiledKeys.extractTableLookup(lookupTable);
            if (extractResult !== void 0) {
              const [addressTableLookup, {
                writable,
                readonly
              }] = extractResult;
              addressTableLookups.push(addressTableLookup);
              accountKeysFromLookups.writable.push(...writable);
              accountKeysFromLookups.readonly.push(...readonly);
            }
          }
          const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
          const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
          const compiledInstructions = accountKeys.compileInstructions(args.instructions);
          return new _MessageV0({
            header,
            staticAccountKeys,
            recentBlockhash: args.recentBlockhash,
            compiledInstructions,
            addressTableLookups
          });
        }
        serialize() {
          const encodedStaticAccountKeysLength = Array();
          encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
          const serializedInstructions = this.serializeInstructions();
          const encodedInstructionsLength = Array();
          encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
          const serializedAddressTableLookups = this.serializeAddressTableLookups();
          const encodedAddressTableLookupsLength = Array();
          encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
          const messageLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8("prefix"), BufferLayout__namespace.struct([BufferLayout__namespace.u8("numRequiredSignatures"), BufferLayout__namespace.u8("numReadonlySignedAccounts"), BufferLayout__namespace.u8("numReadonlyUnsignedAccounts")], "header"), BufferLayout__namespace.blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"), BufferLayout__namespace.seq(publicKey3(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey3("recentBlockhash"), BufferLayout__namespace.blob(encodedInstructionsLength.length, "instructionsLength"), BufferLayout__namespace.blob(serializedInstructions.length, "serializedInstructions"), BufferLayout__namespace.blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"), BufferLayout__namespace.blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")]);
          const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
          const MESSAGE_VERSION_0_PREFIX = 1 << 7;
          const serializedMessageLength = messageLayout.encode({
            prefix: MESSAGE_VERSION_0_PREFIX,
            header: this.header,
            staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
            staticAccountKeys: this.staticAccountKeys.map((key) => key.toBytes()),
            recentBlockhash: bs58__default.default.decode(this.recentBlockhash),
            instructionsLength: new Uint8Array(encodedInstructionsLength),
            serializedInstructions,
            addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
            serializedAddressTableLookups
          }, serializedMessage);
          return serializedMessage.slice(0, serializedMessageLength);
        }
        serializeInstructions() {
          let serializedLength = 0;
          const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
          for (const instruction of this.compiledInstructions) {
            const encodedAccountKeyIndexesLength = Array();
            encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
            const encodedDataLength = Array();
            encodeLength(encodedDataLength, instruction.data.length);
            const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8("programIdIndex"), BufferLayout__namespace.blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"), BufferLayout__namespace.blob(encodedDataLength.length, "encodedDataLength"), BufferLayout__namespace.blob(instruction.data.length, "data")]);
            serializedLength += instructionLayout.encode({
              programIdIndex: instruction.programIdIndex,
              encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
              accountKeyIndexes: instruction.accountKeyIndexes,
              encodedDataLength: new Uint8Array(encodedDataLength),
              data: instruction.data
            }, serializedInstructions, serializedLength);
          }
          return serializedInstructions.slice(0, serializedLength);
        }
        serializeAddressTableLookups() {
          let serializedLength = 0;
          const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
          for (const lookup of this.addressTableLookups) {
            const encodedWritableIndexesLength = Array();
            encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
            const encodedReadonlyIndexesLength = Array();
            encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
            const addressTableLookupLayout = BufferLayout__namespace.struct([publicKey3("accountKey"), BufferLayout__namespace.blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.writableIndexes.length, "writableIndexes"), BufferLayout__namespace.blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.readonlyIndexes.length, "readonlyIndexes")]);
            serializedLength += addressTableLookupLayout.encode({
              accountKey: lookup.accountKey.toBytes(),
              encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
              writableIndexes: lookup.writableIndexes,
              encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
              readonlyIndexes: lookup.readonlyIndexes
            }, serializedAddressTableLookups, serializedLength);
          }
          return serializedAddressTableLookups.slice(0, serializedLength);
        }
        static deserialize(serializedMessage) {
          let byteArray = [...serializedMessage];
          const prefix = guardedShift(byteArray);
          const maskedPrefix = prefix & VERSION_PREFIX_MASK;
          assert2(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
          const version2 = maskedPrefix;
          assert2(version2 === 0, `Expected versioned message with version 0 but found version ${version2}`);
          const header = {
            numRequiredSignatures: guardedShift(byteArray),
            numReadonlySignedAccounts: guardedShift(byteArray),
            numReadonlyUnsignedAccounts: guardedShift(byteArray)
          };
          const staticAccountKeys = [];
          const staticAccountKeysLength = decodeLength(byteArray);
          for (let i = 0; i < staticAccountKeysLength; i++) {
            staticAccountKeys.push(new PublicKey2(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));
          }
          const recentBlockhash = bs58__default.default.encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
          const instructionCount = decodeLength(byteArray);
          const compiledInstructions = [];
          for (let i = 0; i < instructionCount; i++) {
            const programIdIndex = guardedShift(byteArray);
            const accountKeyIndexesLength = decodeLength(byteArray);
            const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);
            const dataLength = decodeLength(byteArray);
            const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));
            compiledInstructions.push({
              programIdIndex,
              accountKeyIndexes,
              data
            });
          }
          const addressTableLookupsCount = decodeLength(byteArray);
          const addressTableLookups = [];
          for (let i = 0; i < addressTableLookupsCount; i++) {
            const accountKey = new PublicKey2(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
            const writableIndexesLength = decodeLength(byteArray);
            const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);
            const readonlyIndexesLength = decodeLength(byteArray);
            const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);
            addressTableLookups.push({
              accountKey,
              writableIndexes,
              readonlyIndexes
            });
          }
          return new _MessageV0({
            header,
            staticAccountKeys,
            recentBlockhash,
            compiledInstructions,
            addressTableLookups
          });
        }
      };
      var VersionedMessage = {
        deserializeMessageVersion(serializedMessage) {
          const prefix = serializedMessage[0];
          const maskedPrefix = prefix & VERSION_PREFIX_MASK;
          if (maskedPrefix === prefix) {
            return "legacy";
          }
          return maskedPrefix;
        },
        deserialize: (serializedMessage) => {
          const version2 = VersionedMessage.deserializeMessageVersion(serializedMessage);
          if (version2 === "legacy") {
            return Message.from(serializedMessage);
          }
          if (version2 === 0) {
            return MessageV0.deserialize(serializedMessage);
          } else {
            throw new Error(`Transaction message version ${version2} deserialization is not supported`);
          }
        }
      };
      var TransactionStatus = /* @__PURE__ */ (function(TransactionStatus2) {
        TransactionStatus2[TransactionStatus2["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
        TransactionStatus2[TransactionStatus2["PROCESSED"] = 1] = "PROCESSED";
        TransactionStatus2[TransactionStatus2["TIMED_OUT"] = 2] = "TIMED_OUT";
        TransactionStatus2[TransactionStatus2["NONCE_INVALID"] = 3] = "NONCE_INVALID";
        return TransactionStatus2;
      })({});
      var DEFAULT_SIGNATURE = buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
      var TransactionInstruction2 = class {
        constructor(opts) {
          this.keys = void 0;
          this.programId = void 0;
          this.data = buffer.Buffer.alloc(0);
          this.programId = opts.programId;
          this.keys = opts.keys;
          if (opts.data) {
            this.data = opts.data;
          }
        }
        /**
         * @internal
         */
        toJSON() {
          return {
            keys: this.keys.map(({
              pubkey: pubkey2,
              isSigner,
              isWritable
            }) => ({
              pubkey: pubkey2.toJSON(),
              isSigner,
              isWritable
            })),
            programId: this.programId.toJSON(),
            data: [...this.data]
          };
        }
      };
      var Transaction2 = class _Transaction {
        /**
         * The first (payer) Transaction signature
         *
         * @returns {Buffer | null} Buffer of payer's signature
         */
        get signature() {
          if (this.signatures.length > 0) {
            return this.signatures[0].signature;
          }
          return null;
        }
        /**
         * The transaction fee payer
         */
        // Construct a transaction with a blockhash and lastValidBlockHeight
        // Construct a transaction using a durable nonce
        /**
         * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
         * Please supply a `TransactionBlockhashCtor` instead.
         */
        /**
         * Construct an empty Transaction
         */
        constructor(opts) {
          this.signatures = [];
          this.feePayer = void 0;
          this.instructions = [];
          this.recentBlockhash = void 0;
          this.lastValidBlockHeight = void 0;
          this.nonceInfo = void 0;
          this.minNonceContextSlot = void 0;
          this._message = void 0;
          this._json = void 0;
          if (!opts) {
            return;
          }
          if (opts.feePayer) {
            this.feePayer = opts.feePayer;
          }
          if (opts.signatures) {
            this.signatures = opts.signatures;
          }
          if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
            const {
              minContextSlot,
              nonceInfo
            } = opts;
            this.minNonceContextSlot = minContextSlot;
            this.nonceInfo = nonceInfo;
          } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
            const {
              blockhash,
              lastValidBlockHeight
            } = opts;
            this.recentBlockhash = blockhash;
            this.lastValidBlockHeight = lastValidBlockHeight;
          } else {
            const {
              recentBlockhash,
              nonceInfo
            } = opts;
            if (nonceInfo) {
              this.nonceInfo = nonceInfo;
            }
            this.recentBlockhash = recentBlockhash;
          }
        }
        /**
         * @internal
         */
        toJSON() {
          return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo ? {
              nonce: this.nonceInfo.nonce,
              nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
            } : null,
            instructions: this.instructions.map((instruction) => instruction.toJSON()),
            signers: this.signatures.map(({
              publicKey: publicKey4
            }) => {
              return publicKey4.toJSON();
            })
          };
        }
        /**
         * Add one or more instructions to this Transaction
         *
         * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
         */
        add(...items) {
          if (items.length === 0) {
            throw new Error("No instructions");
          }
          items.forEach((item) => {
            if ("instructions" in item) {
              this.instructions = this.instructions.concat(item.instructions);
            } else if ("data" in item && "programId" in item && "keys" in item) {
              this.instructions.push(item);
            } else {
              this.instructions.push(new TransactionInstruction2(item));
            }
          });
          return this;
        }
        /**
         * Compile transaction data
         */
        compileMessage() {
          if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
            return this._message;
          }
          let recentBlockhash;
          let instructions;
          if (this.nonceInfo) {
            recentBlockhash = this.nonceInfo.nonce;
            if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
              instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
            } else {
              instructions = this.instructions;
            }
          } else {
            recentBlockhash = this.recentBlockhash;
            instructions = this.instructions;
          }
          if (!recentBlockhash) {
            throw new Error("Transaction recentBlockhash required");
          }
          if (instructions.length < 1) {
            console.warn("No instructions provided");
          }
          let feePayer;
          if (this.feePayer) {
            feePayer = this.feePayer;
          } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
            feePayer = this.signatures[0].publicKey;
          } else {
            throw new Error("Transaction fee payer required");
          }
          for (let i = 0; i < instructions.length; i++) {
            if (instructions[i].programId === void 0) {
              throw new Error(`Transaction instruction index ${i} has undefined program id`);
            }
          }
          const programIds = [];
          const accountMetas = [];
          instructions.forEach((instruction) => {
            instruction.keys.forEach((accountMeta) => {
              accountMetas.push({
                ...accountMeta
              });
            });
            const programId = instruction.programId.toString();
            if (!programIds.includes(programId)) {
              programIds.push(programId);
            }
          });
          programIds.forEach((programId) => {
            accountMetas.push({
              pubkey: new PublicKey2(programId),
              isSigner: false,
              isWritable: false
            });
          });
          const uniqueMetas = [];
          accountMetas.forEach((accountMeta) => {
            const pubkeyString = accountMeta.pubkey.toString();
            const uniqueIndex = uniqueMetas.findIndex((x) => {
              return x.pubkey.toString() === pubkeyString;
            });
            if (uniqueIndex > -1) {
              uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
              uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
            } else {
              uniqueMetas.push(accountMeta);
            }
          });
          uniqueMetas.sort(function(x, y) {
            if (x.isSigner !== y.isSigner) {
              return x.isSigner ? -1 : 1;
            }
            if (x.isWritable !== y.isWritable) {
              return x.isWritable ? -1 : 1;
            }
            const options = {
              localeMatcher: "best fit",
              usage: "sort",
              sensitivity: "variant",
              ignorePunctuation: false,
              numeric: false,
              caseFirst: "lower"
            };
            return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), "en", options);
          });
          const feePayerIndex = uniqueMetas.findIndex((x) => {
            return x.pubkey.equals(feePayer);
          });
          if (feePayerIndex > -1) {
            const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
            payerMeta.isSigner = true;
            payerMeta.isWritable = true;
            uniqueMetas.unshift(payerMeta);
          } else {
            uniqueMetas.unshift({
              pubkey: feePayer,
              isSigner: true,
              isWritable: true
            });
          }
          for (const signature2 of this.signatures) {
            const uniqueIndex = uniqueMetas.findIndex((x) => {
              return x.pubkey.equals(signature2.publicKey);
            });
            if (uniqueIndex > -1) {
              if (!uniqueMetas[uniqueIndex].isSigner) {
                uniqueMetas[uniqueIndex].isSigner = true;
                console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
              }
            } else {
              throw new Error(`unknown signer: ${signature2.publicKey.toString()}`);
            }
          }
          let numRequiredSignatures = 0;
          let numReadonlySignedAccounts = 0;
          let numReadonlyUnsignedAccounts = 0;
          const signedKeys = [];
          const unsignedKeys = [];
          uniqueMetas.forEach(({
            pubkey: pubkey2,
            isSigner,
            isWritable
          }) => {
            if (isSigner) {
              signedKeys.push(pubkey2.toString());
              numRequiredSignatures += 1;
              if (!isWritable) {
                numReadonlySignedAccounts += 1;
              }
            } else {
              unsignedKeys.push(pubkey2.toString());
              if (!isWritable) {
                numReadonlyUnsignedAccounts += 1;
              }
            }
          });
          const accountKeys = signedKeys.concat(unsignedKeys);
          const compiledInstructions = instructions.map((instruction) => {
            const {
              data,
              programId
            } = instruction;
            return {
              programIdIndex: accountKeys.indexOf(programId.toString()),
              accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
              data: bs58__default.default.encode(data)
            };
          });
          compiledInstructions.forEach((instruction) => {
            assert2(instruction.programIdIndex >= 0);
            instruction.accounts.forEach((keyIndex) => assert2(keyIndex >= 0));
          });
          return new Message({
            header: {
              numRequiredSignatures,
              numReadonlySignedAccounts,
              numReadonlyUnsignedAccounts
            },
            accountKeys,
            recentBlockhash,
            instructions: compiledInstructions
          });
        }
        /**
         * @internal
         */
        _compile() {
          const message = this.compileMessage();
          const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
          if (this.signatures.length === signedKeys.length) {
            const valid = this.signatures.every((pair, index2) => {
              return signedKeys[index2].equals(pair.publicKey);
            });
            if (valid) return message;
          }
          this.signatures = signedKeys.map((publicKey4) => ({
            signature: null,
            publicKey: publicKey4
          }));
          return message;
        }
        /**
         * Get a buffer of the Transaction data that need to be covered by signatures
         */
        serializeMessage() {
          return this._compile().serialize();
        }
        /**
         * Get the estimated fee associated with a transaction
         *
         * @param {Connection} connection Connection to RPC Endpoint.
         *
         * @returns {Promise<number | null>} The estimated fee for the transaction
         */
        async getEstimatedFee(connection) {
          return (await connection.getFeeForMessage(this.compileMessage())).value;
        }
        /**
         * Specify the public keys which will be used to sign the Transaction.
         * The first signer will be used as the transaction fee payer account.
         *
         * Signatures can be added with either `partialSign` or `addSignature`
         *
         * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
         * specified and it can be set in the Transaction constructor or with the
         * `feePayer` property.
         */
        setSigners(...signers) {
          if (signers.length === 0) {
            throw new Error("No signers");
          }
          const seen = /* @__PURE__ */ new Set();
          this.signatures = signers.filter((publicKey4) => {
            const key = publicKey4.toString();
            if (seen.has(key)) {
              return false;
            } else {
              seen.add(key);
              return true;
            }
          }).map((publicKey4) => ({
            signature: null,
            publicKey: publicKey4
          }));
        }
        /**
         * Sign the Transaction with the specified signers. Multiple signatures may
         * be applied to a Transaction. The first signature is considered "primary"
         * and is used identify and confirm transactions.
         *
         * If the Transaction `feePayer` is not set, the first signer will be used
         * as the transaction fee payer account.
         *
         * Transaction fields should not be modified after the first call to `sign`,
         * as doing so may invalidate the signature and cause the Transaction to be
         * rejected.
         *
         * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
         *
         * @param {Array<Signer>} signers Array of signers that will sign the transaction
         */
        sign(...signers) {
          if (signers.length === 0) {
            throw new Error("No signers");
          }
          const seen = /* @__PURE__ */ new Set();
          const uniqueSigners = [];
          for (const signer of signers) {
            const key = signer.publicKey.toString();
            if (seen.has(key)) {
              continue;
            } else {
              seen.add(key);
              uniqueSigners.push(signer);
            }
          }
          this.signatures = uniqueSigners.map((signer) => ({
            signature: null,
            publicKey: signer.publicKey
          }));
          const message = this._compile();
          this._partialSign(message, ...uniqueSigners);
        }
        /**
         * Partially sign a transaction with the specified accounts. All accounts must
         * correspond to either the fee payer or a signer account in the transaction
         * instructions.
         *
         * All the caveats from the `sign` method apply to `partialSign`
         *
         * @param {Array<Signer>} signers Array of signers that will sign the transaction
         */
        partialSign(...signers) {
          if (signers.length === 0) {
            throw new Error("No signers");
          }
          const seen = /* @__PURE__ */ new Set();
          const uniqueSigners = [];
          for (const signer of signers) {
            const key = signer.publicKey.toString();
            if (seen.has(key)) {
              continue;
            } else {
              seen.add(key);
              uniqueSigners.push(signer);
            }
          }
          const message = this._compile();
          this._partialSign(message, ...uniqueSigners);
        }
        /**
         * @internal
         */
        _partialSign(message, ...signers) {
          const signData = message.serialize();
          signers.forEach((signer) => {
            const signature2 = sign(signData, signer.secretKey);
            this._addSignature(signer.publicKey, toBuffer(signature2));
          });
        }
        /**
         * Add an externally created signature to a transaction. The public key
         * must correspond to either the fee payer or a signer account in the transaction
         * instructions.
         *
         * @param {PublicKey} pubkey Public key that will be added to the transaction.
         * @param {Buffer} signature An externally created signature to add to the transaction.
         */
        addSignature(pubkey2, signature2) {
          this._compile();
          this._addSignature(pubkey2, signature2);
        }
        /**
         * @internal
         */
        _addSignature(pubkey2, signature2) {
          assert2(signature2.length === 64);
          const index2 = this.signatures.findIndex((sigpair) => pubkey2.equals(sigpair.publicKey));
          if (index2 < 0) {
            throw new Error(`unknown signer: ${pubkey2.toString()}`);
          }
          this.signatures[index2].signature = buffer.Buffer.from(signature2);
        }
        /**
         * Verify signatures of a Transaction
         * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
         * If no boolean is provided, we expect a fully signed Transaction by default.
         *
         * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
         */
        verifySignatures(requireAllSignatures = true) {
          const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
          return !signatureErrors;
        }
        /**
         * @internal
         */
        _getMessageSignednessErrors(message, requireAllSignatures) {
          const errors = {};
          for (const {
            signature: signature2,
            publicKey: publicKey4
          } of this.signatures) {
            if (signature2 === null) {
              if (requireAllSignatures) {
                (errors.missing ||= []).push(publicKey4);
              }
            } else {
              if (!verify(signature2, message, publicKey4.toBytes())) {
                (errors.invalid ||= []).push(publicKey4);
              }
            }
          }
          return errors.invalid || errors.missing ? errors : void 0;
        }
        /**
         * Serialize the Transaction in the wire format.
         *
         * @param {Buffer} [config] Config of transaction.
         *
         * @returns {Buffer} Signature of transaction in wire format.
         */
        serialize(config) {
          const {
            requireAllSignatures,
            verifySignatures
          } = Object.assign({
            requireAllSignatures: true,
            verifySignatures: true
          }, config);
          const signData = this.serializeMessage();
          if (verifySignatures) {
            const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
            if (sigErrors) {
              let errorMessage = "Signature verification failed.";
              if (sigErrors.invalid) {
                errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p) => p.toBase58()).join("`, `")}\`].`;
              }
              if (sigErrors.missing) {
                errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p) => p.toBase58()).join("`, `")}\`].`;
              }
              throw new Error(errorMessage);
            }
          }
          return this._serialize(signData);
        }
        /**
         * @internal
         */
        _serialize(signData) {
          const {
            signatures
          } = this;
          const signatureCount = [];
          encodeLength(signatureCount, signatures.length);
          const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
          const wireTransaction = buffer.Buffer.alloc(transactionLength);
          assert2(signatures.length < 256);
          buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);
          signatures.forEach(({
            signature: signature2
          }, index2) => {
            if (signature2 !== null) {
              assert2(signature2.length === 64, `signature has invalid length`);
              buffer.Buffer.from(signature2).copy(wireTransaction, signatureCount.length + index2 * 64);
            }
          });
          signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
          assert2(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
          return wireTransaction;
        }
        /**
         * Deprecated method
         * @internal
         */
        get keys() {
          assert2(this.instructions.length === 1);
          return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
        }
        /**
         * Deprecated method
         * @internal
         */
        get programId() {
          assert2(this.instructions.length === 1);
          return this.instructions[0].programId;
        }
        /**
         * Deprecated method
         * @internal
         */
        get data() {
          assert2(this.instructions.length === 1);
          return this.instructions[0].data;
        }
        /**
         * Parse a wire transaction into a Transaction object.
         *
         * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
         *
         * @returns {Transaction} Transaction associated with the signature
         */
        static from(buffer$1) {
          let byteArray = [...buffer$1];
          const signatureCount = decodeLength(byteArray);
          let signatures = [];
          for (let i = 0; i < signatureCount; i++) {
            const signature2 = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);
            signatures.push(bs58__default.default.encode(buffer.Buffer.from(signature2)));
          }
          return _Transaction.populate(Message.from(byteArray), signatures);
        }
        /**
         * Populate Transaction object from message and signatures
         *
         * @param {Message} message Message of transaction
         * @param {Array<string>} signatures List of signatures to assign to the transaction
         *
         * @returns {Transaction} The populated Transaction
         */
        static populate(message, signatures = []) {
          const transaction = new _Transaction();
          transaction.recentBlockhash = message.recentBlockhash;
          if (message.header.numRequiredSignatures > 0) {
            transaction.feePayer = message.accountKeys[0];
          }
          signatures.forEach((signature2, index2) => {
            const sigPubkeyPair = {
              signature: signature2 == bs58__default.default.encode(DEFAULT_SIGNATURE) ? null : bs58__default.default.decode(signature2),
              publicKey: message.accountKeys[index2]
            };
            transaction.signatures.push(sigPubkeyPair);
          });
          message.instructions.forEach((instruction) => {
            const keys = instruction.accounts.map((account) => {
              const pubkey2 = message.accountKeys[account];
              return {
                pubkey: pubkey2,
                isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey2.toString()) || message.isAccountSigner(account),
                isWritable: message.isAccountWritable(account)
              };
            });
            transaction.instructions.push(new TransactionInstruction2({
              keys,
              programId: message.accountKeys[instruction.programIdIndex],
              data: bs58__default.default.decode(instruction.data)
            }));
          });
          transaction._message = message;
          transaction._json = transaction.toJSON();
          return transaction;
        }
      };
      var TransactionMessage = class _TransactionMessage {
        constructor(args) {
          this.payerKey = void 0;
          this.instructions = void 0;
          this.recentBlockhash = void 0;
          this.payerKey = args.payerKey;
          this.instructions = args.instructions;
          this.recentBlockhash = args.recentBlockhash;
        }
        static decompile(message, args) {
          const {
            header,
            compiledInstructions,
            recentBlockhash
          } = message;
          const {
            numRequiredSignatures,
            numReadonlySignedAccounts,
            numReadonlyUnsignedAccounts
          } = header;
          const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
          assert2(numWritableSignedAccounts > 0, "Message header is invalid");
          const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
          assert2(numWritableUnsignedAccounts >= 0, "Message header is invalid");
          const accountKeys = message.getAccountKeys(args);
          const payerKey = accountKeys.get(0);
          if (payerKey === void 0) {
            throw new Error("Failed to decompile message because no account keys were found");
          }
          const instructions = [];
          for (const compiledIx of compiledInstructions) {
            const keys = [];
            for (const keyIndex of compiledIx.accountKeyIndexes) {
              const pubkey2 = accountKeys.get(keyIndex);
              if (pubkey2 === void 0) {
                throw new Error(`Failed to find key for account key index ${keyIndex}`);
              }
              const isSigner = keyIndex < numRequiredSignatures;
              let isWritable;
              if (isSigner) {
                isWritable = keyIndex < numWritableSignedAccounts;
              } else if (keyIndex < accountKeys.staticAccountKeys.length) {
                isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
              } else {
                isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above
                accountKeys.accountKeysFromLookups.writable.length;
              }
              keys.push({
                pubkey: pubkey2,
                isSigner: keyIndex < header.numRequiredSignatures,
                isWritable
              });
            }
            const programId = accountKeys.get(compiledIx.programIdIndex);
            if (programId === void 0) {
              throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);
            }
            instructions.push(new TransactionInstruction2({
              programId,
              data: toBuffer(compiledIx.data),
              keys
            }));
          }
          return new _TransactionMessage({
            payerKey,
            instructions,
            recentBlockhash
          });
        }
        compileToLegacyMessage() {
          return Message.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions
          });
        }
        compileToV0Message(addressLookupTableAccounts) {
          return MessageV0.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions,
            addressLookupTableAccounts
          });
        }
      };
      var VersionedTransaction = class _VersionedTransaction {
        get version() {
          return this.message.version;
        }
        constructor(message, signatures) {
          this.signatures = void 0;
          this.message = void 0;
          if (signatures !== void 0) {
            assert2(signatures.length === message.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures");
            this.signatures = signatures;
          } else {
            const defaultSignatures = [];
            for (let i = 0; i < message.header.numRequiredSignatures; i++) {
              defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
            }
            this.signatures = defaultSignatures;
          }
          this.message = message;
        }
        serialize() {
          const serializedMessage = this.message.serialize();
          const encodedSignaturesLength = Array();
          encodeLength(encodedSignaturesLength, this.signatures.length);
          const transactionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.blob(encodedSignaturesLength.length, "encodedSignaturesLength"), BufferLayout__namespace.seq(signature(), this.signatures.length, "signatures"), BufferLayout__namespace.blob(serializedMessage.length, "serializedMessage")]);
          const serializedTransaction = new Uint8Array(2048);
          const serializedTransactionLength = transactionLayout.encode({
            encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
            signatures: this.signatures,
            serializedMessage
          }, serializedTransaction);
          return serializedTransaction.slice(0, serializedTransactionLength);
        }
        static deserialize(serializedTransaction) {
          let byteArray = [...serializedTransaction];
          const signatures = [];
          const signaturesLength = decodeLength(byteArray);
          for (let i = 0; i < signaturesLength; i++) {
            signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));
          }
          const message = VersionedMessage.deserialize(new Uint8Array(byteArray));
          return new _VersionedTransaction(message, signatures);
        }
        sign(signers) {
          const messageData = this.message.serialize();
          const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
          for (const signer of signers) {
            const signerIndex = signerPubkeys.findIndex((pubkey2) => pubkey2.equals(signer.publicKey));
            assert2(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
            this.signatures[signerIndex] = sign(messageData, signer.secretKey);
          }
        }
        addSignature(publicKey4, signature2) {
          assert2(signature2.byteLength === 64, "Signature must be 64 bytes long");
          const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
          const signerIndex = signerPubkeys.findIndex((pubkey2) => pubkey2.equals(publicKey4));
          assert2(signerIndex >= 0, `Can not add signature; \`${publicKey4.toBase58()}\` is not required to sign this transaction`);
          this.signatures[signerIndex] = signature2;
        }
      };
      var NUM_TICKS_PER_SECOND = 160;
      var DEFAULT_TICKS_PER_SLOT = 64;
      var NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
      var MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
      var SYSVAR_CLOCK_PUBKEY = new PublicKey2("SysvarC1ock11111111111111111111111111111111");
      var SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey2("SysvarEpochSchedu1e111111111111111111111111");
      var SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey2("Sysvar1nstructions1111111111111111111111111");
      var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey2("SysvarRecentB1ockHashes11111111111111111111");
      var SYSVAR_RENT_PUBKEY = new PublicKey2("SysvarRent111111111111111111111111111111111");
      var SYSVAR_REWARDS_PUBKEY = new PublicKey2("SysvarRewards111111111111111111111111111111");
      var SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey2("SysvarS1otHashes111111111111111111111111111");
      var SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey2("SysvarS1otHistory11111111111111111111111111");
      var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey2("SysvarStakeHistory1111111111111111111111111");
      var SendTransactionError2 = class extends Error {
        constructor({
          action,
          signature: signature2,
          transactionMessage,
          logs
        }) {
          const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
          const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
          let message;
          switch (action) {
            case "send":
              message = `Transaction ${signature2} resulted in an error. 
${transactionMessage}. ` + maybeLogsOutput + guideText;
              break;
            case "simulate":
              message = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
              break;
            default: {
              message = `Unknown action '${/* @__PURE__ */ ((a) => a)(action)}'`;
            }
          }
          super(message);
          this.signature = void 0;
          this.transactionMessage = void 0;
          this.transactionLogs = void 0;
          this.signature = signature2;
          this.transactionMessage = transactionMessage;
          this.transactionLogs = logs ? logs : void 0;
        }
        get transactionError() {
          return {
            message: this.transactionMessage,
            logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
          };
        }
        /* @deprecated Use `await getLogs()` instead */
        get logs() {
          const cachedLogs = this.transactionLogs;
          if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
            return void 0;
          }
          return cachedLogs;
        }
        async getLogs(connection) {
          if (!Array.isArray(this.transactionLogs)) {
            this.transactionLogs = new Promise((resolve, reject) => {
              connection.getTransaction(this.signature).then((tx) => {
                if (tx && tx.meta && tx.meta.logMessages) {
                  const logs = tx.meta.logMessages;
                  this.transactionLogs = logs;
                  resolve(logs);
                } else {
                  reject(new Error("Log messages not found"));
                }
              }).catch(reject);
            });
          }
          return await this.transactionLogs;
        }
      };
      var SolanaJSONRPCErrorCode = {
        JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
        JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
        JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
        JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
        JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
        JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
        JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
        JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
        JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
        JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
        JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
        JSON_RPC_SCAN_ERROR: -32012,
        JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
        JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
        JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
        JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
      };
      var SolanaJSONRPCError = class extends Error {
        constructor({
          code,
          message,
          data
        }, customMessage) {
          super(customMessage != null ? `${customMessage}: ${message}` : message);
          this.code = void 0;
          this.data = void 0;
          this.code = code;
          this.data = data;
          this.name = "SolanaJSONRPCError";
        }
      };
      async function sendAndConfirmTransaction(connection, transaction, signers, options) {
        const sendOptions = options && {
          skipPreflight: options.skipPreflight,
          preflightCommitment: options.preflightCommitment || options.commitment,
          maxRetries: options.maxRetries,
          minContextSlot: options.minContextSlot
        };
        const signature2 = await connection.sendTransaction(transaction, signers, sendOptions);
        let status;
        if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
          status = (await connection.confirmTransaction({
            abortSignal: options?.abortSignal,
            signature: signature2,
            blockhash: transaction.recentBlockhash,
            lastValidBlockHeight: transaction.lastValidBlockHeight
          }, options && options.commitment)).value;
        } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
          const {
            nonceInstruction
          } = transaction.nonceInfo;
          const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
          status = (await connection.confirmTransaction({
            abortSignal: options?.abortSignal,
            minContextSlot: transaction.minNonceContextSlot,
            nonceAccountPubkey,
            nonceValue: transaction.nonceInfo.nonce,
            signature: signature2
          }, options && options.commitment)).value;
        } else {
          if (options?.abortSignal != null) {
            console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
          }
          status = (await connection.confirmTransaction(signature2, options && options.commitment)).value;
        }
        if (status.err) {
          if (signature2 != null) {
            throw new SendTransactionError2({
              action: "send",
              signature: signature2,
              transactionMessage: `Status: (${JSON.stringify(status)})`
            });
          }
          throw new Error(`Transaction ${signature2} failed (${JSON.stringify(status)})`);
        }
        return signature2;
      }
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      function encodeData2(type2, fields) {
        const allocLength = type2.layout.span >= 0 ? type2.layout.span : getAlloc(type2, fields);
        const data = buffer.Buffer.alloc(allocLength);
        const layoutFields = Object.assign({
          instruction: type2.index
        }, fields);
        type2.layout.encode(layoutFields, data);
        return data;
      }
      function decodeData$1(type2, buffer2) {
        let data;
        try {
          data = type2.layout.decode(buffer2);
        } catch (err2) {
          throw new Error("invalid instruction; " + err2);
        }
        if (data.instruction !== type2.index) {
          throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type2.index}`);
        }
        return data;
      }
      var FeeCalculatorLayout = BufferLayout__namespace.nu64("lamportsPerSignature");
      var NonceAccountLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32("version"), BufferLayout__namespace.u32("state"), publicKey3("authorizedPubkey"), publicKey3("nonce"), BufferLayout__namespace.struct([FeeCalculatorLayout], "feeCalculator")]);
      var NONCE_ACCOUNT_LENGTH2 = NonceAccountLayout.span;
      var NonceAccount = class _NonceAccount {
        /**
         * @internal
         */
        constructor(args) {
          this.authorizedPubkey = void 0;
          this.nonce = void 0;
          this.feeCalculator = void 0;
          this.authorizedPubkey = args.authorizedPubkey;
          this.nonce = args.nonce;
          this.feeCalculator = args.feeCalculator;
        }
        /**
         * Deserialize NonceAccount from the account data.
         *
         * @param buffer account data
         * @return NonceAccount
         */
        static fromAccountData(buffer2) {
          const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer2), 0);
          return new _NonceAccount({
            authorizedPubkey: new PublicKey2(nonceAccount.authorizedPubkey),
            nonce: new PublicKey2(nonceAccount.nonce).toString(),
            feeCalculator: nonceAccount.feeCalculator
          });
        }
      };
      var encodeDecode = (layout) => {
        const decode2 = layout.decode.bind(layout);
        const encode2 = layout.encode.bind(layout);
        return {
          decode: decode2,
          encode: encode2
        };
      };
      var bigInt = (length) => (property) => {
        const layout = BufferLayout.blob(length, property);
        const {
          encode: encode2,
          decode: decode2
        } = encodeDecode(layout);
        const bigIntLayout = layout;
        bigIntLayout.decode = (buffer$1, offset2) => {
          const src = decode2(buffer$1, offset2);
          return bigintBuffer.toBigIntLE(buffer.Buffer.from(src));
        };
        bigIntLayout.encode = (bigInt2, buffer2, offset2) => {
          const src = bigintBuffer.toBufferLE(bigInt2, length);
          return encode2(src, buffer2, offset2);
        };
        return bigIntLayout;
      };
      var u643 = bigInt(8);
      var SystemInstruction = class {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Decode a system instruction and retrieve the instruction type.
         */
        static decodeInstructionType(instruction) {
          this.checkProgramId(instruction.programId);
          const instructionTypeLayout = BufferLayout__namespace.u32("instruction");
          const typeIndex = instructionTypeLayout.decode(instruction.data);
          let type2;
          for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)) {
            if (layout.index == typeIndex) {
              type2 = ixType;
              break;
            }
          }
          if (!type2) {
            throw new Error("Instruction type incorrect; not a SystemInstruction");
          }
          return type2;
        }
        /**
         * Decode a create account system instruction and retrieve the instruction params.
         */
        static decodeCreateAccount(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            lamports,
            space,
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);
          return {
            fromPubkey: instruction.keys[0].pubkey,
            newAccountPubkey: instruction.keys[1].pubkey,
            lamports,
            space,
            programId: new PublicKey2(programId)
          };
        }
        /**
         * Decode a transfer system instruction and retrieve the instruction params.
         */
        static decodeTransfer(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            lamports
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);
          return {
            fromPubkey: instruction.keys[0].pubkey,
            toPubkey: instruction.keys[1].pubkey,
            lamports
          };
        }
        /**
         * Decode a transfer with seed system instruction and retrieve the instruction params.
         */
        static decodeTransferWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            lamports,
            seed: seed2,
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);
          return {
            fromPubkey: instruction.keys[0].pubkey,
            basePubkey: instruction.keys[1].pubkey,
            toPubkey: instruction.keys[2].pubkey,
            lamports,
            seed: seed2,
            programId: new PublicKey2(programId)
          };
        }
        /**
         * Decode an allocate system instruction and retrieve the instruction params.
         */
        static decodeAllocate(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 1);
          const {
            space
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);
          return {
            accountPubkey: instruction.keys[0].pubkey,
            space
          };
        }
        /**
         * Decode an allocate with seed system instruction and retrieve the instruction params.
         */
        static decodeAllocateWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 1);
          const {
            base,
            seed: seed2,
            space,
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);
          return {
            accountPubkey: instruction.keys[0].pubkey,
            basePubkey: new PublicKey2(base),
            seed: seed2,
            space,
            programId: new PublicKey2(programId)
          };
        }
        /**
         * Decode an assign system instruction and retrieve the instruction params.
         */
        static decodeAssign(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 1);
          const {
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);
          return {
            accountPubkey: instruction.keys[0].pubkey,
            programId: new PublicKey2(programId)
          };
        }
        /**
         * Decode an assign with seed system instruction and retrieve the instruction params.
         */
        static decodeAssignWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 1);
          const {
            base,
            seed: seed2,
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);
          return {
            accountPubkey: instruction.keys[0].pubkey,
            basePubkey: new PublicKey2(base),
            seed: seed2,
            programId: new PublicKey2(programId)
          };
        }
        /**
         * Decode a create account with seed system instruction and retrieve the instruction params.
         */
        static decodeCreateWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            base,
            seed: seed2,
            lamports,
            space,
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);
          return {
            fromPubkey: instruction.keys[0].pubkey,
            newAccountPubkey: instruction.keys[1].pubkey,
            basePubkey: new PublicKey2(base),
            seed: seed2,
            lamports,
            space,
            programId: new PublicKey2(programId)
          };
        }
        /**
         * Decode a nonce initialize system instruction and retrieve the instruction params.
         */
        static decodeNonceInitialize(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            authorized: authorized2
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);
          return {
            noncePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: new PublicKey2(authorized2)
          };
        }
        /**
         * Decode a nonce advance system instruction and retrieve the instruction params.
         */
        static decodeNonceAdvance(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
          return {
            noncePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey
          };
        }
        /**
         * Decode a nonce withdraw system instruction and retrieve the instruction params.
         */
        static decodeNonceWithdraw(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 5);
          const {
            lamports
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);
          return {
            noncePubkey: instruction.keys[0].pubkey,
            toPubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[4].pubkey,
            lamports
          };
        }
        /**
         * Decode a nonce authorize system instruction and retrieve the instruction params.
         */
        static decodeNonceAuthorize(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            authorized: authorized2
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);
          return {
            noncePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[1].pubkey,
            newAuthorizedPubkey: new PublicKey2(authorized2)
          };
        }
        /**
         * @internal
         */
        static checkProgramId(programId) {
          if (!programId.equals(SystemProgram2.programId)) {
            throw new Error("invalid instruction; programId is not SystemProgram");
          }
        }
        /**
         * @internal
         */
        static checkKeyLength(keys, expectedLength) {
          if (keys.length < expectedLength) {
            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
          }
        }
      };
      var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
        Create: {
          index: 0,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports"), BufferLayout__namespace.ns64("space"), publicKey3("programId")])
        },
        Assign: {
          index: 1,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("programId")])
        },
        Transfer: {
          index: 2,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u643("lamports")])
        },
        CreateWithSeed: {
          index: 3,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("base"), rustString("seed"), BufferLayout__namespace.ns64("lamports"), BufferLayout__namespace.ns64("space"), publicKey3("programId")])
        },
        AdvanceNonceAccount: {
          index: 4,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        },
        WithdrawNonceAccount: {
          index: 5,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
        },
        InitializeNonceAccount: {
          index: 6,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("authorized")])
        },
        AuthorizeNonceAccount: {
          index: 7,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("authorized")])
        },
        Allocate: {
          index: 8,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("space")])
        },
        AllocateWithSeed: {
          index: 9,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("base"), rustString("seed"), BufferLayout__namespace.ns64("space"), publicKey3("programId")])
        },
        AssignWithSeed: {
          index: 10,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("base"), rustString("seed"), publicKey3("programId")])
        },
        TransferWithSeed: {
          index: 11,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u643("lamports"), rustString("seed"), publicKey3("programId")])
        },
        UpgradeNonceAccount: {
          index: 12,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        }
      });
      var SystemProgram2 = class _SystemProgram {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Public key that identifies the System program
         */
        /**
         * Generate a transaction instruction that creates a new account
         */
        static createAccount(params) {
          const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Create;
          const data = encodeData2(type2, {
            lamports: params.lamports,
            space: params.space,
            programId: toBuffer(params.programId.toBuffer())
          });
          return new TransactionInstruction2({
            keys: [{
              pubkey: params.fromPubkey,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: params.newAccountPubkey,
              isSigner: true,
              isWritable: true
            }],
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction instruction that transfers lamports from one account to another
         */
        static transfer(params) {
          let data;
          let keys;
          if ("basePubkey" in params) {
            const type2 = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
            data = encodeData2(type2, {
              lamports: BigInt(params.lamports),
              seed: params.seed,
              programId: toBuffer(params.programId.toBuffer())
            });
            keys = [{
              pubkey: params.fromPubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: params.basePubkey,
              isSigner: true,
              isWritable: false
            }, {
              pubkey: params.toPubkey,
              isSigner: false,
              isWritable: true
            }];
          } else {
            const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
            data = encodeData2(type2, {
              lamports: BigInt(params.lamports)
            });
            keys = [{
              pubkey: params.fromPubkey,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: params.toPubkey,
              isSigner: false,
              isWritable: true
            }];
          }
          return new TransactionInstruction2({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction instruction that assigns an account to a program
         */
        static assign(params) {
          let data;
          let keys;
          if ("basePubkey" in params) {
            const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
            data = encodeData2(type2, {
              base: toBuffer(params.basePubkey.toBuffer()),
              seed: params.seed,
              programId: toBuffer(params.programId.toBuffer())
            });
            keys = [{
              pubkey: params.accountPubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: params.basePubkey,
              isSigner: true,
              isWritable: false
            }];
          } else {
            const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
            data = encodeData2(type2, {
              programId: toBuffer(params.programId.toBuffer())
            });
            keys = [{
              pubkey: params.accountPubkey,
              isSigner: true,
              isWritable: true
            }];
          }
          return new TransactionInstruction2({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction instruction that creates a new account at
         *   an address generated with `from`, a seed, and programId
         */
        static createAccountWithSeed(params) {
          const type2 = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
          const data = encodeData2(type2, {
            base: toBuffer(params.basePubkey.toBuffer()),
            seed: params.seed,
            lamports: params.lamports,
            space: params.space,
            programId: toBuffer(params.programId.toBuffer())
          });
          let keys = [{
            pubkey: params.fromPubkey,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: params.newAccountPubkey,
            isSigner: false,
            isWritable: true
          }];
          if (!params.basePubkey.equals(params.fromPubkey)) {
            keys.push({
              pubkey: params.basePubkey,
              isSigner: true,
              isWritable: false
            });
          }
          return new TransactionInstruction2({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction that creates a new Nonce account
         */
        static createNonceAccount(params) {
          const transaction = new Transaction2();
          if ("basePubkey" in params && "seed" in params) {
            transaction.add(_SystemProgram.createAccountWithSeed({
              fromPubkey: params.fromPubkey,
              newAccountPubkey: params.noncePubkey,
              basePubkey: params.basePubkey,
              seed: params.seed,
              lamports: params.lamports,
              space: NONCE_ACCOUNT_LENGTH2,
              programId: this.programId
            }));
          } else {
            transaction.add(_SystemProgram.createAccount({
              fromPubkey: params.fromPubkey,
              newAccountPubkey: params.noncePubkey,
              lamports: params.lamports,
              space: NONCE_ACCOUNT_LENGTH2,
              programId: this.programId
            }));
          }
          const initParams = {
            noncePubkey: params.noncePubkey,
            authorizedPubkey: params.authorizedPubkey
          };
          transaction.add(this.nonceInitialize(initParams));
          return transaction;
        }
        /**
         * Generate an instruction to initialize a Nonce account
         */
        static nonceInitialize(params) {
          const type2 = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
          const data = encodeData2(type2, {
            authorized: toBuffer(params.authorizedPubkey.toBuffer())
          });
          const instructionData = {
            keys: [{
              pubkey: params.noncePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }],
            programId: this.programId,
            data
          };
          return new TransactionInstruction2(instructionData);
        }
        /**
         * Generate an instruction to advance the nonce in a Nonce account
         */
        static nonceAdvance(params) {
          const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
          const data = encodeData2(type2);
          const instructionData = {
            keys: [{
              pubkey: params.noncePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: params.authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          };
          return new TransactionInstruction2(instructionData);
        }
        /**
         * Generate a transaction instruction that withdraws lamports from a Nonce account
         */
        static nonceWithdraw(params) {
          const type2 = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
          const data = encodeData2(type2, {
            lamports: params.lamports
          });
          return new TransactionInstruction2({
            keys: [{
              pubkey: params.noncePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: params.toPubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: params.authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction instruction that authorizes a new PublicKey as the authority
         * on a Nonce account.
         */
        static nonceAuthorize(params) {
          const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
          const data = encodeData2(type2, {
            authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
          });
          return new TransactionInstruction2({
            keys: [{
              pubkey: params.noncePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: params.authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction instruction that allocates space in an account without funding
         */
        static allocate(params) {
          let data;
          let keys;
          if ("basePubkey" in params) {
            const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
            data = encodeData2(type2, {
              base: toBuffer(params.basePubkey.toBuffer()),
              seed: params.seed,
              space: params.space,
              programId: toBuffer(params.programId.toBuffer())
            });
            keys = [{
              pubkey: params.accountPubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: params.basePubkey,
              isSigner: true,
              isWritable: false
            }];
          } else {
            const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
            data = encodeData2(type2, {
              space: params.space
            });
            keys = [{
              pubkey: params.accountPubkey,
              isSigner: true,
              isWritable: true
            }];
          }
          return new TransactionInstruction2({
            keys,
            programId: this.programId,
            data
          });
        }
      };
      SystemProgram2.programId = new PublicKey2("11111111111111111111111111111111");
      var CHUNK_SIZE = PACKET_DATA_SIZE - 300;
      var Loader = class _Loader {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Amount of program data placed in each load Transaction
         */
        /**
         * Minimum number of signatures required to load a program not including
         * retries
         *
         * Can be used to calculate transaction fees
         */
        static getMinNumSignatures(dataLength) {
          return 2 * // Every transaction requires two signatures (payer + program)
          (Math.ceil(dataLength / _Loader.chunkSize) + 1 + // Add one for Create transaction
          1);
        }
        /**
         * Loads a generic program
         *
         * @param connection The connection to use
         * @param payer System account that pays to load the program
         * @param program Account to load the program into
         * @param programId Public key that identifies the loader
         * @param data Program octets
         * @return true if program was loaded successfully, false if program was already loaded
         */
        static async load(connection, payer, program2, programId, data) {
          {
            const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
            const programInfo = await connection.getAccountInfo(program2.publicKey, "confirmed");
            let transaction = null;
            if (programInfo !== null) {
              if (programInfo.executable) {
                console.error("Program load failed, account is already executable");
                return false;
              }
              if (programInfo.data.length !== data.length) {
                transaction = transaction || new Transaction2();
                transaction.add(SystemProgram2.allocate({
                  accountPubkey: program2.publicKey,
                  space: data.length
                }));
              }
              if (!programInfo.owner.equals(programId)) {
                transaction = transaction || new Transaction2();
                transaction.add(SystemProgram2.assign({
                  accountPubkey: program2.publicKey,
                  programId
                }));
              }
              if (programInfo.lamports < balanceNeeded) {
                transaction = transaction || new Transaction2();
                transaction.add(SystemProgram2.transfer({
                  fromPubkey: payer.publicKey,
                  toPubkey: program2.publicKey,
                  lamports: balanceNeeded - programInfo.lamports
                }));
              }
            } else {
              transaction = new Transaction2().add(SystemProgram2.createAccount({
                fromPubkey: payer.publicKey,
                newAccountPubkey: program2.publicKey,
                lamports: balanceNeeded > 0 ? balanceNeeded : 1,
                space: data.length,
                programId
              }));
            }
            if (transaction !== null) {
              await sendAndConfirmTransaction(connection, transaction, [payer, program2], {
                commitment: "confirmed"
              });
            }
          }
          const dataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.u32("offset"), BufferLayout__namespace.u32("bytesLength"), BufferLayout__namespace.u32("bytesLengthPadding"), BufferLayout__namespace.seq(BufferLayout__namespace.u8("byte"), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "bytes")]);
          const chunkSize = _Loader.chunkSize;
          let offset2 = 0;
          let array3 = data;
          let transactions = [];
          while (array3.length > 0) {
            const bytes = array3.slice(0, chunkSize);
            const data2 = buffer.Buffer.alloc(chunkSize + 16);
            dataLayout.encode({
              instruction: 0,
              // Load instruction
              offset: offset2,
              bytes,
              bytesLength: 0,
              bytesLengthPadding: 0
            }, data2);
            const transaction = new Transaction2().add({
              keys: [{
                pubkey: program2.publicKey,
                isSigner: true,
                isWritable: true
              }],
              programId,
              data: data2
            });
            transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program2], {
              commitment: "confirmed"
            }));
            if (connection._rpcEndpoint.includes("solana.com")) {
              const REQUESTS_PER_SECOND = 4;
              await sleep(1e3 / REQUESTS_PER_SECOND);
            }
            offset2 += chunkSize;
            array3 = array3.slice(chunkSize);
          }
          await Promise.all(transactions);
          {
            const dataLayout2 = BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")]);
            const data2 = buffer.Buffer.alloc(dataLayout2.span);
            dataLayout2.encode({
              instruction: 1
              // Finalize instruction
            }, data2);
            const transaction = new Transaction2().add({
              keys: [{
                pubkey: program2.publicKey,
                isSigner: true,
                isWritable: true
              }, {
                pubkey: SYSVAR_RENT_PUBKEY,
                isSigner: false,
                isWritable: false
              }],
              programId,
              data: data2
            });
            const deployCommitment = "processed";
            const finalizeSignature = await connection.sendTransaction(transaction, [payer, program2], {
              preflightCommitment: deployCommitment
            });
            const {
              context,
              value
            } = await connection.confirmTransaction({
              signature: finalizeSignature,
              lastValidBlockHeight: transaction.lastValidBlockHeight,
              blockhash: transaction.recentBlockhash
            }, deployCommitment);
            if (value.err) {
              throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
            }
            while (true) {
              try {
                const currentSlot = await connection.getSlot({
                  commitment: deployCommitment
                });
                if (currentSlot > context.slot) {
                  break;
                }
              } catch {
              }
              await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));
            }
          }
          return true;
        }
      };
      Loader.chunkSize = CHUNK_SIZE;
      var BPF_LOADER_PROGRAM_ID = new PublicKey2("BPFLoader2111111111111111111111111111111111");
      var BpfLoader = class {
        /**
         * Minimum number of signatures required to load a program not including
         * retries
         *
         * Can be used to calculate transaction fees
         */
        static getMinNumSignatures(dataLength) {
          return Loader.getMinNumSignatures(dataLength);
        }
        /**
         * Load a SBF program
         *
         * @param connection The connection to use
         * @param payer Account that will pay program loading fees
         * @param program Account to load the program into
         * @param elf The entire ELF containing the SBF program
         * @param loaderProgramId The program id of the BPF loader to use
         * @return true if program was loaded successfully, false if program was already loaded
         */
        static load(connection, payer, program2, elf, loaderProgramId) {
          return Loader.load(connection, payer, program2, loaderProgramId, elf);
        }
      };
      function getDefaultExportFromCjs2(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      var objToString = Object.prototype.toString;
      var objKeys = Object.keys || function(obj) {
        var keys = [];
        for (var name in obj) {
          keys.push(name);
        }
        return keys;
      };
      function stringify2(val, isArrayProp) {
        var i, max, str2, keys, key, propVal, toStr;
        if (val === true) {
          return "true";
        }
        if (val === false) {
          return "false";
        }
        switch (typeof val) {
          case "object":
            if (val === null) {
              return null;
            } else if (val.toJSON && typeof val.toJSON === "function") {
              return stringify2(val.toJSON(), isArrayProp);
            } else {
              toStr = objToString.call(val);
              if (toStr === "[object Array]") {
                str2 = "[";
                max = val.length - 1;
                for (i = 0; i < max; i++) {
                  str2 += stringify2(val[i], true) + ",";
                }
                if (max > -1) {
                  str2 += stringify2(val[i], true);
                }
                return str2 + "]";
              } else if (toStr === "[object Object]") {
                keys = objKeys(val).sort();
                max = keys.length;
                str2 = "";
                i = 0;
                while (i < max) {
                  key = keys[i];
                  propVal = stringify2(val[key], false);
                  if (propVal !== void 0) {
                    if (str2) {
                      str2 += ",";
                    }
                    str2 += JSON.stringify(key) + ":" + propVal;
                  }
                  i++;
                }
                return "{" + str2 + "}";
              } else {
                return JSON.stringify(val);
              }
            }
          case "function":
          case "undefined":
            return isArrayProp ? null : void 0;
          case "string":
            return JSON.stringify(val);
          default:
            return isFinite(val) ? val : null;
        }
      }
      var fastStableStringify = function(val) {
        var returnVal = stringify2(val, false);
        if (returnVal !== void 0) {
          return "" + returnVal;
        }
      };
      var fastStableStringify$1 = /* @__PURE__ */ getDefaultExportFromCjs2(fastStableStringify);
      var MINIMUM_SLOT_PER_EPOCH = 32;
      function trailingZeros(n) {
        let trailingZeros2 = 0;
        while (n > 1) {
          n /= 2;
          trailingZeros2++;
        }
        return trailingZeros2;
      }
      function nextPowerOfTwo(n) {
        if (n === 0) return 1;
        n--;
        n |= n >> 1;
        n |= n >> 2;
        n |= n >> 4;
        n |= n >> 8;
        n |= n >> 16;
        n |= n >> 32;
        return n + 1;
      }
      var EpochSchedule = class {
        constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
          this.slotsPerEpoch = void 0;
          this.leaderScheduleSlotOffset = void 0;
          this.warmup = void 0;
          this.firstNormalEpoch = void 0;
          this.firstNormalSlot = void 0;
          this.slotsPerEpoch = slotsPerEpoch;
          this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
          this.warmup = warmup;
          this.firstNormalEpoch = firstNormalEpoch;
          this.firstNormalSlot = firstNormalSlot;
        }
        getEpoch(slot) {
          return this.getEpochAndSlotIndex(slot)[0];
        }
        getEpochAndSlotIndex(slot) {
          if (slot < this.firstNormalSlot) {
            const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
            const epochLen = this.getSlotsInEpoch(epoch);
            const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
            return [epoch, slotIndex];
          } else {
            const normalSlotIndex = slot - this.firstNormalSlot;
            const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
            const epoch = this.firstNormalEpoch + normalEpochIndex;
            const slotIndex = normalSlotIndex % this.slotsPerEpoch;
            return [epoch, slotIndex];
          }
        }
        getFirstSlotInEpoch(epoch) {
          if (epoch <= this.firstNormalEpoch) {
            return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
          } else {
            return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
          }
        }
        getLastSlotInEpoch(epoch) {
          return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
        }
        getSlotsInEpoch(epoch) {
          if (epoch < this.firstNormalEpoch) {
            return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
          } else {
            return this.slotsPerEpoch;
          }
        }
      };
      var fetchImpl = globalThis.fetch;
      var RpcWebSocketClient = class extends rpcWebsockets.CommonClient {
        constructor(address, options, generate_request_id) {
          const webSocketFactory = (url) => {
            const rpc2 = rpcWebsockets.WebSocket(url, {
              autoconnect: true,
              max_reconnects: 5,
              reconnect: true,
              reconnect_interval: 1e3,
              ...options
            });
            if ("socket" in rpc2) {
              this.underlyingSocket = rpc2.socket;
            } else {
              this.underlyingSocket = rpc2;
            }
            return rpc2;
          };
          super(webSocketFactory, address, options, generate_request_id);
          this.underlyingSocket = void 0;
        }
        call(...args) {
          const readyState = this.underlyingSocket?.readyState;
          if (readyState === 1) {
            return super.call(...args);
          }
          return Promise.reject(new Error("Tried to call a JSON-RPC method `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
        }
        notify(...args) {
          const readyState = this.underlyingSocket?.readyState;
          if (readyState === 1) {
            return super.notify(...args);
          }
          return Promise.reject(new Error("Tried to send a JSON-RPC notification `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
        }
      };
      function decodeData(type2, data) {
        let decoded;
        try {
          decoded = type2.layout.decode(data);
        } catch (err2) {
          throw new Error("invalid instruction; " + err2);
        }
        if (decoded.typeIndex !== type2.index) {
          throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type2.index}`);
        }
        return decoded;
      }
      var LOOKUP_TABLE_META_SIZE = 56;
      var AddressLookupTableAccount = class {
        constructor(args) {
          this.key = void 0;
          this.state = void 0;
          this.key = args.key;
          this.state = args.state;
        }
        isActive() {
          const U64_MAX = BigInt("0xffffffffffffffff");
          return this.state.deactivationSlot === U64_MAX;
        }
        static deserialize(accountData) {
          const meta = decodeData(LookupTableMetaLayout, accountData);
          const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
          assert2(serializedAddressesLen >= 0, "lookup table is invalid");
          assert2(serializedAddressesLen % 32 === 0, "lookup table is invalid");
          const numSerializedAddresses = serializedAddressesLen / 32;
          const {
            addresses
          } = BufferLayout__namespace.struct([BufferLayout__namespace.seq(publicKey3(), numSerializedAddresses, "addresses")]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
          return {
            deactivationSlot: meta.deactivationSlot,
            lastExtendedSlot: meta.lastExtendedSlot,
            lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
            authority: meta.authority.length !== 0 ? new PublicKey2(meta.authority[0]) : void 0,
            addresses: addresses.map((address) => new PublicKey2(address))
          };
        }
      };
      var LookupTableMetaLayout = {
        index: 1,
        layout: BufferLayout__namespace.struct([
          BufferLayout__namespace.u32("typeIndex"),
          u643("deactivationSlot"),
          BufferLayout__namespace.nu64("lastExtendedSlot"),
          BufferLayout__namespace.u8("lastExtendedStartIndex"),
          BufferLayout__namespace.u8(),
          // option
          BufferLayout__namespace.seq(publicKey3(), BufferLayout__namespace.offset(BufferLayout__namespace.u8(), -1), "authority")
        ])
      };
      var URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
      function makeWebsocketUrl(endpoint2) {
        const matches = endpoint2.match(URL_RE);
        if (matches == null) {
          throw TypeError(`Failed to validate endpoint URL \`${endpoint2}\``);
        }
        const [
          _,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          hostish,
          portWithColon,
          rest
        ] = matches;
        const protocol = endpoint2.startsWith("https:") ? "wss:" : "ws:";
        const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
        const websocketPort = (
          // Only shift the port by +1 as a convention for ws(s) only if given endpoint
          // is explicitly specifying the endpoint port (HTTP-based RPC), assuming
          // we're directly trying to connect to agave-validator's ws listening port.
          // When the endpoint omits the port, we're connecting to the protocol
          // default ports: http(80) or https(443) and it's assumed we're behind a reverse
          // proxy which manages WebSocket upgrade and backend port redirection.
          startPort == null ? "" : `:${startPort + 1}`
        );
        return `${protocol}//${hostish}${websocketPort}${rest}`;
      }
      var PublicKeyFromString = superstruct.coerce(superstruct.instance(PublicKey2), superstruct.string(), (value) => new PublicKey2(value));
      var RawAccountDataResult = superstruct.tuple([superstruct.string(), superstruct.literal("base64")]);
      var BufferFromRawAccountData = superstruct.coerce(superstruct.instance(buffer.Buffer), RawAccountDataResult, (value) => buffer.Buffer.from(value[0], "base64"));
      var BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
      function assertEndpointUrl(putativeUrl) {
        if (/^https?:/.test(putativeUrl) === false) {
          throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
        }
        return putativeUrl;
      }
      function extractCommitmentFromConfig(commitmentOrConfig) {
        let commitment;
        let config;
        if (typeof commitmentOrConfig === "string") {
          commitment = commitmentOrConfig;
        } else if (commitmentOrConfig) {
          const {
            commitment: specifiedCommitment,
            ...specifiedConfig
          } = commitmentOrConfig;
          commitment = specifiedCommitment;
          config = specifiedConfig;
        }
        return {
          commitment,
          config
        };
      }
      function applyDefaultMemcmpEncodingToFilters(filters) {
        return filters.map((filter) => "memcmp" in filter ? {
          ...filter,
          memcmp: {
            ...filter.memcmp,
            encoding: filter.memcmp.encoding ?? "base58"
          }
        } : filter);
      }
      function createRpcResult2(result) {
        return superstruct.union([superstruct.type({
          jsonrpc: superstruct.literal("2.0"),
          id: superstruct.string(),
          result
        }), superstruct.type({
          jsonrpc: superstruct.literal("2.0"),
          id: superstruct.string(),
          error: superstruct.type({
            code: superstruct.unknown(),
            message: superstruct.string(),
            data: superstruct.optional(superstruct.any())
          })
        })]);
      }
      var UnknownRpcResult2 = createRpcResult2(superstruct.unknown());
      function jsonRpcResult2(schema) {
        return superstruct.coerce(createRpcResult2(schema), UnknownRpcResult2, (value) => {
          if ("error" in value) {
            return value;
          } else {
            return {
              ...value,
              result: superstruct.create(value.result, schema)
            };
          }
        });
      }
      function jsonRpcResultAndContext2(value) {
        return jsonRpcResult2(superstruct.type({
          context: superstruct.type({
            slot: superstruct.number()
          }),
          value
        }));
      }
      function notificationResultAndContext(value) {
        return superstruct.type({
          context: superstruct.type({
            slot: superstruct.number()
          }),
          value
        });
      }
      function versionedMessageFromResponse(version2, response) {
        if (version2 === 0) {
          return new MessageV0({
            header: response.header,
            staticAccountKeys: response.accountKeys.map((accountKey) => new PublicKey2(accountKey)),
            recentBlockhash: response.recentBlockhash,
            compiledInstructions: response.instructions.map((ix) => ({
              programIdIndex: ix.programIdIndex,
              accountKeyIndexes: ix.accounts,
              data: bs58__default.default.decode(ix.data)
            })),
            addressTableLookups: response.addressTableLookups
          });
        } else {
          return new Message(response);
        }
      }
      var GetInflationGovernorResult = superstruct.type({
        foundation: superstruct.number(),
        foundationTerm: superstruct.number(),
        initial: superstruct.number(),
        taper: superstruct.number(),
        terminal: superstruct.number()
      });
      var GetInflationRewardResult = jsonRpcResult2(superstruct.array(superstruct.nullable(superstruct.type({
        epoch: superstruct.number(),
        effectiveSlot: superstruct.number(),
        amount: superstruct.number(),
        postBalance: superstruct.number(),
        commission: superstruct.optional(superstruct.nullable(superstruct.number()))
      }))));
      var GetRecentPrioritizationFeesResult = superstruct.array(superstruct.type({
        slot: superstruct.number(),
        prioritizationFee: superstruct.number()
      }));
      var GetInflationRateResult = superstruct.type({
        total: superstruct.number(),
        validator: superstruct.number(),
        foundation: superstruct.number(),
        epoch: superstruct.number()
      });
      var GetEpochInfoResult = superstruct.type({
        epoch: superstruct.number(),
        slotIndex: superstruct.number(),
        slotsInEpoch: superstruct.number(),
        absoluteSlot: superstruct.number(),
        blockHeight: superstruct.optional(superstruct.number()),
        transactionCount: superstruct.optional(superstruct.number())
      });
      var GetEpochScheduleResult = superstruct.type({
        slotsPerEpoch: superstruct.number(),
        leaderScheduleSlotOffset: superstruct.number(),
        warmup: superstruct.boolean(),
        firstNormalEpoch: superstruct.number(),
        firstNormalSlot: superstruct.number()
      });
      var GetLeaderScheduleResult = superstruct.record(superstruct.string(), superstruct.array(superstruct.number()));
      var TransactionErrorResult = superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()]));
      var SignatureStatusResult = superstruct.type({
        err: TransactionErrorResult
      });
      var SignatureReceivedResult = superstruct.literal("receivedSignature");
      var VersionResult = superstruct.type({
        "solana-core": superstruct.string(),
        "feature-set": superstruct.optional(superstruct.number())
      });
      var ParsedInstructionStruct = superstruct.type({
        program: superstruct.string(),
        programId: PublicKeyFromString,
        parsed: superstruct.unknown()
      });
      var PartiallyDecodedInstructionStruct = superstruct.type({
        programId: PublicKeyFromString,
        accounts: superstruct.array(PublicKeyFromString),
        data: superstruct.string()
      });
      var SimulatedTransactionResponseStruct2 = jsonRpcResultAndContext2(superstruct.type({
        err: superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()])),
        logs: superstruct.nullable(superstruct.array(superstruct.string())),
        accounts: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.nullable(superstruct.type({
          executable: superstruct.boolean(),
          owner: superstruct.string(),
          lamports: superstruct.number(),
          data: superstruct.array(superstruct.string()),
          rentEpoch: superstruct.optional(superstruct.number())
        }))))),
        unitsConsumed: superstruct.optional(superstruct.number()),
        returnData: superstruct.optional(superstruct.nullable(superstruct.type({
          programId: superstruct.string(),
          data: superstruct.tuple([superstruct.string(), superstruct.literal("base64")])
        }))),
        innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({
          index: superstruct.number(),
          instructions: superstruct.array(superstruct.union([ParsedInstructionStruct, PartiallyDecodedInstructionStruct]))
        }))))
      }));
      var BlockProductionResponseStruct = jsonRpcResultAndContext2(superstruct.type({
        byIdentity: superstruct.record(superstruct.string(), superstruct.array(superstruct.number())),
        range: superstruct.type({
          firstSlot: superstruct.number(),
          lastSlot: superstruct.number()
        })
      }));
      function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
        const fetch2 = customFetch ? customFetch : fetchImpl;
        let agent;
        {
          if (httpAgent != null) {
            console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
          }
        }
        let fetchWithMiddleware;
        if (fetchMiddleware) {
          fetchWithMiddleware = async (info, init) => {
            const modifiedFetchArgs = await new Promise((resolve, reject) => {
              try {
                fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
              } catch (error) {
                reject(error);
              }
            });
            return await fetch2(...modifiedFetchArgs);
          };
        }
        const clientBrowser = new RpcClient__default.default(async (request, callback) => {
          const options = {
            method: "POST",
            body: request,
            agent,
            headers: Object.assign({
              "Content-Type": "application/json"
            }, httpHeaders || {}, COMMON_HTTP_HEADERS)
          };
          try {
            let too_many_requests_retries = 5;
            let res;
            let waitTime = 500;
            for (; ; ) {
              if (fetchWithMiddleware) {
                res = await fetchWithMiddleware(url, options);
              } else {
                res = await fetch2(url, options);
              }
              if (res.status !== 429) {
                break;
              }
              if (disableRetryOnRateLimit === true) {
                break;
              }
              too_many_requests_retries -= 1;
              if (too_many_requests_retries === 0) {
                break;
              }
              console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
              await sleep(waitTime);
              waitTime *= 2;
            }
            const text = await res.text();
            if (res.ok) {
              callback(null, text);
            } else {
              callback(new Error(`${res.status} ${res.statusText}: ${text}`));
            }
          } catch (err2) {
            if (err2 instanceof Error) callback(err2);
          }
        }, {});
        return clientBrowser;
      }
      function createRpcRequest(client) {
        return (method, args) => {
          return new Promise((resolve, reject) => {
            client.request(method, args, (err2, response) => {
              if (err2) {
                reject(err2);
                return;
              }
              resolve(response);
            });
          });
        };
      }
      function createRpcBatchRequest(client) {
        return (requests) => {
          return new Promise((resolve, reject) => {
            if (requests.length === 0) resolve([]);
            const batch = requests.map((params) => {
              return client.request(params.methodName, params.args);
            });
            client.request(batch, (err2, response) => {
              if (err2) {
                reject(err2);
                return;
              }
              resolve(response);
            });
          });
        };
      }
      var GetInflationGovernorRpcResult = jsonRpcResult2(GetInflationGovernorResult);
      var GetInflationRateRpcResult = jsonRpcResult2(GetInflationRateResult);
      var GetRecentPrioritizationFeesRpcResult = jsonRpcResult2(GetRecentPrioritizationFeesResult);
      var GetEpochInfoRpcResult = jsonRpcResult2(GetEpochInfoResult);
      var GetEpochScheduleRpcResult = jsonRpcResult2(GetEpochScheduleResult);
      var GetLeaderScheduleRpcResult = jsonRpcResult2(GetLeaderScheduleResult);
      var SlotRpcResult = jsonRpcResult2(superstruct.number());
      var GetSupplyRpcResult = jsonRpcResultAndContext2(superstruct.type({
        total: superstruct.number(),
        circulating: superstruct.number(),
        nonCirculating: superstruct.number(),
        nonCirculatingAccounts: superstruct.array(PublicKeyFromString)
      }));
      var TokenAmountResult = superstruct.type({
        amount: superstruct.string(),
        uiAmount: superstruct.nullable(superstruct.number()),
        decimals: superstruct.number(),
        uiAmountString: superstruct.optional(superstruct.string())
      });
      var GetTokenLargestAccountsResult = jsonRpcResultAndContext2(superstruct.array(superstruct.type({
        address: PublicKeyFromString,
        amount: superstruct.string(),
        uiAmount: superstruct.nullable(superstruct.number()),
        decimals: superstruct.number(),
        uiAmountString: superstruct.optional(superstruct.string())
      })));
      var GetTokenAccountsByOwner = jsonRpcResultAndContext2(superstruct.array(superstruct.type({
        pubkey: PublicKeyFromString,
        account: superstruct.type({
          executable: superstruct.boolean(),
          owner: PublicKeyFromString,
          lamports: superstruct.number(),
          data: BufferFromRawAccountData,
          rentEpoch: superstruct.number()
        })
      })));
      var ParsedAccountDataResult = superstruct.type({
        program: superstruct.string(),
        parsed: superstruct.unknown(),
        space: superstruct.number()
      });
      var GetParsedTokenAccountsByOwner = jsonRpcResultAndContext2(superstruct.array(superstruct.type({
        pubkey: PublicKeyFromString,
        account: superstruct.type({
          executable: superstruct.boolean(),
          owner: PublicKeyFromString,
          lamports: superstruct.number(),
          data: ParsedAccountDataResult,
          rentEpoch: superstruct.number()
        })
      })));
      var GetLargestAccountsRpcResult = jsonRpcResultAndContext2(superstruct.array(superstruct.type({
        lamports: superstruct.number(),
        address: PublicKeyFromString
      })));
      var AccountInfoResult = superstruct.type({
        executable: superstruct.boolean(),
        owner: PublicKeyFromString,
        lamports: superstruct.number(),
        data: BufferFromRawAccountData,
        rentEpoch: superstruct.number()
      });
      var KeyedAccountInfoResult = superstruct.type({
        pubkey: PublicKeyFromString,
        account: AccountInfoResult
      });
      var ParsedOrRawAccountData = superstruct.coerce(superstruct.union([superstruct.instance(buffer.Buffer), ParsedAccountDataResult]), superstruct.union([RawAccountDataResult, ParsedAccountDataResult]), (value) => {
        if (Array.isArray(value)) {
          return superstruct.create(value, BufferFromRawAccountData);
        } else {
          return value;
        }
      });
      var ParsedAccountInfoResult = superstruct.type({
        executable: superstruct.boolean(),
        owner: PublicKeyFromString,
        lamports: superstruct.number(),
        data: ParsedOrRawAccountData,
        rentEpoch: superstruct.number()
      });
      var KeyedParsedAccountInfoResult = superstruct.type({
        pubkey: PublicKeyFromString,
        account: ParsedAccountInfoResult
      });
      var StakeActivationResult = superstruct.type({
        state: superstruct.union([superstruct.literal("active"), superstruct.literal("inactive"), superstruct.literal("activating"), superstruct.literal("deactivating")]),
        active: superstruct.number(),
        inactive: superstruct.number()
      });
      var GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult2(superstruct.array(superstruct.type({
        signature: superstruct.string(),
        slot: superstruct.number(),
        err: TransactionErrorResult,
        memo: superstruct.nullable(superstruct.string()),
        blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))
      })));
      var GetSignaturesForAddressRpcResult = jsonRpcResult2(superstruct.array(superstruct.type({
        signature: superstruct.string(),
        slot: superstruct.number(),
        err: TransactionErrorResult,
        memo: superstruct.nullable(superstruct.string()),
        blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))
      })));
      var AccountNotificationResult = superstruct.type({
        subscription: superstruct.number(),
        result: notificationResultAndContext(AccountInfoResult)
      });
      var ProgramAccountInfoResult = superstruct.type({
        pubkey: PublicKeyFromString,
        account: AccountInfoResult
      });
      var ProgramAccountNotificationResult = superstruct.type({
        subscription: superstruct.number(),
        result: notificationResultAndContext(ProgramAccountInfoResult)
      });
      var SlotInfoResult = superstruct.type({
        parent: superstruct.number(),
        slot: superstruct.number(),
        root: superstruct.number()
      });
      var SlotNotificationResult = superstruct.type({
        subscription: superstruct.number(),
        result: SlotInfoResult
      });
      var SlotUpdateResult = superstruct.union([superstruct.type({
        type: superstruct.union([superstruct.literal("firstShredReceived"), superstruct.literal("completed"), superstruct.literal("optimisticConfirmation"), superstruct.literal("root")]),
        slot: superstruct.number(),
        timestamp: superstruct.number()
      }), superstruct.type({
        type: superstruct.literal("createdBank"),
        parent: superstruct.number(),
        slot: superstruct.number(),
        timestamp: superstruct.number()
      }), superstruct.type({
        type: superstruct.literal("frozen"),
        slot: superstruct.number(),
        timestamp: superstruct.number(),
        stats: superstruct.type({
          numTransactionEntries: superstruct.number(),
          numSuccessfulTransactions: superstruct.number(),
          numFailedTransactions: superstruct.number(),
          maxTransactionsPerEntry: superstruct.number()
        })
      }), superstruct.type({
        type: superstruct.literal("dead"),
        slot: superstruct.number(),
        timestamp: superstruct.number(),
        err: superstruct.string()
      })]);
      var SlotUpdateNotificationResult = superstruct.type({
        subscription: superstruct.number(),
        result: SlotUpdateResult
      });
      var SignatureNotificationResult = superstruct.type({
        subscription: superstruct.number(),
        result: notificationResultAndContext(superstruct.union([SignatureStatusResult, SignatureReceivedResult]))
      });
      var RootNotificationResult = superstruct.type({
        subscription: superstruct.number(),
        result: superstruct.number()
      });
      var ContactInfoResult = superstruct.type({
        pubkey: superstruct.string(),
        gossip: superstruct.nullable(superstruct.string()),
        tpu: superstruct.nullable(superstruct.string()),
        rpc: superstruct.nullable(superstruct.string()),
        version: superstruct.nullable(superstruct.string())
      });
      var VoteAccountInfoResult = superstruct.type({
        votePubkey: superstruct.string(),
        nodePubkey: superstruct.string(),
        activatedStake: superstruct.number(),
        epochVoteAccount: superstruct.boolean(),
        epochCredits: superstruct.array(superstruct.tuple([superstruct.number(), superstruct.number(), superstruct.number()])),
        commission: superstruct.number(),
        lastVote: superstruct.number(),
        rootSlot: superstruct.nullable(superstruct.number())
      });
      var GetVoteAccounts = jsonRpcResult2(superstruct.type({
        current: superstruct.array(VoteAccountInfoResult),
        delinquent: superstruct.array(VoteAccountInfoResult)
      }));
      var ConfirmationStatus = superstruct.union([superstruct.literal("processed"), superstruct.literal("confirmed"), superstruct.literal("finalized")]);
      var SignatureStatusResponse = superstruct.type({
        slot: superstruct.number(),
        confirmations: superstruct.nullable(superstruct.number()),
        err: TransactionErrorResult,
        confirmationStatus: superstruct.optional(ConfirmationStatus)
      });
      var GetSignatureStatusesRpcResult = jsonRpcResultAndContext2(superstruct.array(superstruct.nullable(SignatureStatusResponse)));
      var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult2(superstruct.number());
      var AddressTableLookupStruct = superstruct.type({
        accountKey: PublicKeyFromString,
        writableIndexes: superstruct.array(superstruct.number()),
        readonlyIndexes: superstruct.array(superstruct.number())
      });
      var ConfirmedTransactionResult = superstruct.type({
        signatures: superstruct.array(superstruct.string()),
        message: superstruct.type({
          accountKeys: superstruct.array(superstruct.string()),
          header: superstruct.type({
            numRequiredSignatures: superstruct.number(),
            numReadonlySignedAccounts: superstruct.number(),
            numReadonlyUnsignedAccounts: superstruct.number()
          }),
          instructions: superstruct.array(superstruct.type({
            accounts: superstruct.array(superstruct.number()),
            data: superstruct.string(),
            programIdIndex: superstruct.number()
          })),
          recentBlockhash: superstruct.string(),
          addressTableLookups: superstruct.optional(superstruct.array(AddressTableLookupStruct))
        })
      });
      var AnnotatedAccountKey = superstruct.type({
        pubkey: PublicKeyFromString,
        signer: superstruct.boolean(),
        writable: superstruct.boolean(),
        source: superstruct.optional(superstruct.union([superstruct.literal("transaction"), superstruct.literal("lookupTable")]))
      });
      var ConfirmedTransactionAccountsModeResult = superstruct.type({
        accountKeys: superstruct.array(AnnotatedAccountKey),
        signatures: superstruct.array(superstruct.string())
      });
      var ParsedInstructionResult = superstruct.type({
        parsed: superstruct.unknown(),
        program: superstruct.string(),
        programId: PublicKeyFromString
      });
      var RawInstructionResult = superstruct.type({
        accounts: superstruct.array(PublicKeyFromString),
        data: superstruct.string(),
        programId: PublicKeyFromString
      });
      var InstructionResult = superstruct.union([RawInstructionResult, ParsedInstructionResult]);
      var UnknownInstructionResult = superstruct.union([superstruct.type({
        parsed: superstruct.unknown(),
        program: superstruct.string(),
        programId: superstruct.string()
      }), superstruct.type({
        accounts: superstruct.array(superstruct.string()),
        data: superstruct.string(),
        programId: superstruct.string()
      })]);
      var ParsedOrRawInstruction = superstruct.coerce(InstructionResult, UnknownInstructionResult, (value) => {
        if ("accounts" in value) {
          return superstruct.create(value, RawInstructionResult);
        } else {
          return superstruct.create(value, ParsedInstructionResult);
        }
      });
      var ParsedConfirmedTransactionResult = superstruct.type({
        signatures: superstruct.array(superstruct.string()),
        message: superstruct.type({
          accountKeys: superstruct.array(AnnotatedAccountKey),
          instructions: superstruct.array(ParsedOrRawInstruction),
          recentBlockhash: superstruct.string(),
          addressTableLookups: superstruct.optional(superstruct.nullable(superstruct.array(AddressTableLookupStruct)))
        })
      });
      var TokenBalanceResult = superstruct.type({
        accountIndex: superstruct.number(),
        mint: superstruct.string(),
        owner: superstruct.optional(superstruct.string()),
        uiTokenAmount: TokenAmountResult
      });
      var LoadedAddressesResult = superstruct.type({
        writable: superstruct.array(PublicKeyFromString),
        readonly: superstruct.array(PublicKeyFromString)
      });
      var ConfirmedTransactionMetaResult = superstruct.type({
        err: TransactionErrorResult,
        fee: superstruct.number(),
        innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({
          index: superstruct.number(),
          instructions: superstruct.array(superstruct.type({
            accounts: superstruct.array(superstruct.number()),
            data: superstruct.string(),
            programIdIndex: superstruct.number()
          }))
        })))),
        preBalances: superstruct.array(superstruct.number()),
        postBalances: superstruct.array(superstruct.number()),
        logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),
        preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
        postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
        loadedAddresses: superstruct.optional(LoadedAddressesResult),
        computeUnitsConsumed: superstruct.optional(superstruct.number())
      });
      var ParsedConfirmedTransactionMetaResult = superstruct.type({
        err: TransactionErrorResult,
        fee: superstruct.number(),
        innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({
          index: superstruct.number(),
          instructions: superstruct.array(ParsedOrRawInstruction)
        })))),
        preBalances: superstruct.array(superstruct.number()),
        postBalances: superstruct.array(superstruct.number()),
        logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),
        preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
        postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
        loadedAddresses: superstruct.optional(LoadedAddressesResult),
        computeUnitsConsumed: superstruct.optional(superstruct.number())
      });
      var TransactionVersionStruct = superstruct.union([superstruct.literal(0), superstruct.literal("legacy")]);
      var RewardsResult = superstruct.type({
        pubkey: superstruct.string(),
        lamports: superstruct.number(),
        postBalance: superstruct.nullable(superstruct.number()),
        rewardType: superstruct.nullable(superstruct.string()),
        commission: superstruct.optional(superstruct.nullable(superstruct.number()))
      });
      var GetBlockRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        transactions: superstruct.array(superstruct.type({
          transaction: ConfirmedTransactionResult,
          meta: superstruct.nullable(ConfirmedTransactionMetaResult),
          version: superstruct.optional(TransactionVersionStruct)
        })),
        rewards: superstruct.optional(superstruct.array(RewardsResult)),
        blockTime: superstruct.nullable(superstruct.number()),
        blockHeight: superstruct.nullable(superstruct.number())
      })));
      var GetNoneModeBlockRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        rewards: superstruct.optional(superstruct.array(RewardsResult)),
        blockTime: superstruct.nullable(superstruct.number()),
        blockHeight: superstruct.nullable(superstruct.number())
      })));
      var GetAccountsModeBlockRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        transactions: superstruct.array(superstruct.type({
          transaction: ConfirmedTransactionAccountsModeResult,
          meta: superstruct.nullable(ConfirmedTransactionMetaResult),
          version: superstruct.optional(TransactionVersionStruct)
        })),
        rewards: superstruct.optional(superstruct.array(RewardsResult)),
        blockTime: superstruct.nullable(superstruct.number()),
        blockHeight: superstruct.nullable(superstruct.number())
      })));
      var GetParsedBlockRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        transactions: superstruct.array(superstruct.type({
          transaction: ParsedConfirmedTransactionResult,
          meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),
          version: superstruct.optional(TransactionVersionStruct)
        })),
        rewards: superstruct.optional(superstruct.array(RewardsResult)),
        blockTime: superstruct.nullable(superstruct.number()),
        blockHeight: superstruct.nullable(superstruct.number())
      })));
      var GetParsedAccountsModeBlockRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        transactions: superstruct.array(superstruct.type({
          transaction: ConfirmedTransactionAccountsModeResult,
          meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),
          version: superstruct.optional(TransactionVersionStruct)
        })),
        rewards: superstruct.optional(superstruct.array(RewardsResult)),
        blockTime: superstruct.nullable(superstruct.number()),
        blockHeight: superstruct.nullable(superstruct.number())
      })));
      var GetParsedNoneModeBlockRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        rewards: superstruct.optional(superstruct.array(RewardsResult)),
        blockTime: superstruct.nullable(superstruct.number()),
        blockHeight: superstruct.nullable(superstruct.number())
      })));
      var GetConfirmedBlockRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        transactions: superstruct.array(superstruct.type({
          transaction: ConfirmedTransactionResult,
          meta: superstruct.nullable(ConfirmedTransactionMetaResult)
        })),
        rewards: superstruct.optional(superstruct.array(RewardsResult)),
        blockTime: superstruct.nullable(superstruct.number())
      })));
      var GetBlockSignaturesRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        signatures: superstruct.array(superstruct.string()),
        blockTime: superstruct.nullable(superstruct.number())
      })));
      var GetTransactionRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        slot: superstruct.number(),
        meta: superstruct.nullable(ConfirmedTransactionMetaResult),
        blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),
        transaction: ConfirmedTransactionResult,
        version: superstruct.optional(TransactionVersionStruct)
      })));
      var GetParsedTransactionRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        slot: superstruct.number(),
        transaction: ParsedConfirmedTransactionResult,
        meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),
        blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),
        version: superstruct.optional(TransactionVersionStruct)
      })));
      var GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext2(superstruct.type({
        blockhash: superstruct.string(),
        feeCalculator: superstruct.type({
          lamportsPerSignature: superstruct.number()
        })
      }));
      var GetLatestBlockhashRpcResult = jsonRpcResultAndContext2(superstruct.type({
        blockhash: superstruct.string(),
        lastValidBlockHeight: superstruct.number()
      }));
      var IsBlockhashValidRpcResult = jsonRpcResultAndContext2(superstruct.boolean());
      var PerfSampleResult = superstruct.type({
        slot: superstruct.number(),
        numTransactions: superstruct.number(),
        numSlots: superstruct.number(),
        samplePeriodSecs: superstruct.number()
      });
      var GetRecentPerformanceSamplesRpcResult = jsonRpcResult2(superstruct.array(PerfSampleResult));
      var GetFeeCalculatorRpcResult = jsonRpcResultAndContext2(superstruct.nullable(superstruct.type({
        feeCalculator: superstruct.type({
          lamportsPerSignature: superstruct.number()
        })
      })));
      var RequestAirdropRpcResult = jsonRpcResult2(superstruct.string());
      var SendTransactionRpcResult = jsonRpcResult2(superstruct.string());
      var LogsResult = superstruct.type({
        err: TransactionErrorResult,
        logs: superstruct.array(superstruct.string()),
        signature: superstruct.string()
      });
      var LogsNotificationResult = superstruct.type({
        result: notificationResultAndContext(LogsResult),
        subscription: superstruct.number()
      });
      var COMMON_HTTP_HEADERS = {
        "solana-client": `js/${"1.0.0-maintenance"}`
      };
      var Connection = class {
        /**
         * Establish a JSON RPC connection
         *
         * @param endpoint URL to the fullnode JSON RPC endpoint
         * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
         */
        constructor(endpoint2, _commitmentOrConfig) {
          this._commitment = void 0;
          this._confirmTransactionInitialTimeout = void 0;
          this._rpcEndpoint = void 0;
          this._rpcWsEndpoint = void 0;
          this._rpcClient = void 0;
          this._rpcRequest = void 0;
          this._rpcBatchRequest = void 0;
          this._rpcWebSocket = void 0;
          this._rpcWebSocketConnected = false;
          this._rpcWebSocketHeartbeat = null;
          this._rpcWebSocketIdleTimeout = null;
          this._rpcWebSocketGeneration = 0;
          this._disableBlockhashCaching = false;
          this._pollingBlockhash = false;
          this._blockhashInfo = {
            latestBlockhash: null,
            lastFetch: 0,
            transactionSignatures: [],
            simulatedSignatures: []
          };
          this._nextClientSubscriptionId = 0;
          this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
          this._subscriptionHashByClientSubscriptionId = {};
          this._subscriptionStateChangeCallbacksByHash = {};
          this._subscriptionCallbacksByServerSubscriptionId = {};
          this._subscriptionsByHash = {};
          this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set();
          this.getBlockHeight = /* @__PURE__ */ (() => {
            const requestPromises = {};
            return async (commitmentOrConfig) => {
              const {
                commitment,
                config
              } = extractCommitmentFromConfig(commitmentOrConfig);
              const args = this._buildArgs([], commitment, void 0, config);
              const requestHash = fastStableStringify$1(args);
              requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {
                try {
                  const unsafeRes = await this._rpcRequest("getBlockHeight", args);
                  const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.number()));
                  if ("error" in res) {
                    throw new SolanaJSONRPCError(res.error, "failed to get block height information");
                  }
                  return res.result;
                } finally {
                  delete requestPromises[requestHash];
                }
              })();
              return await requestPromises[requestHash];
            };
          })();
          let wsEndpoint;
          let httpHeaders;
          let fetch2;
          let fetchMiddleware;
          let disableRetryOnRateLimit;
          let httpAgent;
          if (_commitmentOrConfig && typeof _commitmentOrConfig === "string") {
            this._commitment = _commitmentOrConfig;
          } else if (_commitmentOrConfig) {
            this._commitment = _commitmentOrConfig.commitment;
            this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
            wsEndpoint = _commitmentOrConfig.wsEndpoint;
            httpHeaders = _commitmentOrConfig.httpHeaders;
            fetch2 = _commitmentOrConfig.fetch;
            fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
            disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
            httpAgent = _commitmentOrConfig.httpAgent;
          }
          this._rpcEndpoint = assertEndpointUrl(endpoint2);
          this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint2);
          this._rpcClient = createRpcClient(endpoint2, httpHeaders, fetch2, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
          this._rpcRequest = createRpcRequest(this._rpcClient);
          this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
          this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
            autoconnect: false,
            max_reconnects: Infinity
          });
          this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
          this._rpcWebSocket.on("error", this._wsOnError.bind(this));
          this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
          this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
          this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
          this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
          this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
          this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
          this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
          this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
        }
        /**
         * The default commitment used for requests
         */
        get commitment() {
          return this._commitment;
        }
        /**
         * The RPC endpoint
         */
        get rpcEndpoint() {
          return this._rpcEndpoint;
        }
        /**
         * Fetch the balance for the specified public key, return with context
         */
        async getBalanceAndContext(publicKey4, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([publicKey4.toBase58()], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getBalance", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.number()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey4.toBase58()}`);
          }
          return res.result;
        }
        /**
         * Fetch the balance for the specified public key
         */
        async getBalance(publicKey4, commitmentOrConfig) {
          return await this.getBalanceAndContext(publicKey4, commitmentOrConfig).then((x) => x.value).catch((e) => {
            throw new Error("failed to get balance of account " + publicKey4.toBase58() + ": " + e);
          });
        }
        /**
         * Fetch the estimated production time of a block
         */
        async getBlockTime(slot) {
          const unsafeRes = await this._rpcRequest("getBlockTime", [slot]);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.nullable(superstruct.number())));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
          }
          return res.result;
        }
        /**
         * Fetch the lowest slot that the node has information about in its ledger.
         * This value may increase over time if the node is configured to purge older ledger data
         */
        async getMinimumLedgerSlot() {
          const unsafeRes = await this._rpcRequest("minimumLedgerSlot", []);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.number()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get minimum ledger slot");
          }
          return res.result;
        }
        /**
         * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
         */
        async getFirstAvailableBlock() {
          const unsafeRes = await this._rpcRequest("getFirstAvailableBlock", []);
          const res = superstruct.create(unsafeRes, SlotRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get first available block");
          }
          return res.result;
        }
        /**
         * Fetch information about the current supply
         */
        async getSupply(config) {
          let configArg = {};
          if (typeof config === "string") {
            configArg = {
              commitment: config
            };
          } else if (config) {
            configArg = {
              ...config,
              commitment: config && config.commitment || this.commitment
            };
          } else {
            configArg = {
              commitment: this.commitment
            };
          }
          const unsafeRes = await this._rpcRequest("getSupply", [configArg]);
          const res = superstruct.create(unsafeRes, GetSupplyRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get supply");
          }
          return res.result;
        }
        /**
         * Fetch the current supply of a token mint
         */
        async getTokenSupply(tokenMintAddress, commitment) {
          const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
          const unsafeRes = await this._rpcRequest("getTokenSupply", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(TokenAmountResult));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get token supply");
          }
          return res.result;
        }
        /**
         * Fetch the current balance of a token account
         */
        async getTokenAccountBalance(tokenAddress, commitment) {
          const args = this._buildArgs([tokenAddress.toBase58()], commitment);
          const unsafeRes = await this._rpcRequest("getTokenAccountBalance", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(TokenAmountResult));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get token account balance");
          }
          return res.result;
        }
        /**
         * Fetch all the token accounts owned by the specified account
         *
         * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}
         */
        async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          let _args = [ownerAddress.toBase58()];
          if ("mint" in filter) {
            _args.push({
              mint: filter.mint.toBase58()
            });
          } else {
            _args.push({
              programId: filter.programId.toBase58()
            });
          }
          const args = this._buildArgs(_args, commitment, "base64", config);
          const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
          const res = superstruct.create(unsafeRes, GetTokenAccountsByOwner);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
          }
          return res.result;
        }
        /**
         * Fetch parsed token accounts owned by the specified account
         *
         * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
         */
        async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
          let _args = [ownerAddress.toBase58()];
          if ("mint" in filter) {
            _args.push({
              mint: filter.mint.toBase58()
            });
          } else {
            _args.push({
              programId: filter.programId.toBase58()
            });
          }
          const args = this._buildArgs(_args, commitment, "jsonParsed");
          const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
          const res = superstruct.create(unsafeRes, GetParsedTokenAccountsByOwner);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
          }
          return res.result;
        }
        /**
         * Fetch the 20 largest accounts with their current balances
         */
        async getLargestAccounts(config) {
          const arg = {
            ...config,
            commitment: config && config.commitment || this.commitment
          };
          const args = arg.filter || arg.commitment ? [arg] : [];
          const unsafeRes = await this._rpcRequest("getLargestAccounts", args);
          const res = superstruct.create(unsafeRes, GetLargestAccountsRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get largest accounts");
          }
          return res.result;
        }
        /**
         * Fetch the 20 largest token accounts with their current balances
         * for a given mint.
         */
        async getTokenLargestAccounts(mintAddress, commitment) {
          const args = this._buildArgs([mintAddress.toBase58()], commitment);
          const unsafeRes = await this._rpcRequest("getTokenLargestAccounts", args);
          const res = superstruct.create(unsafeRes, GetTokenLargestAccountsResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get token largest accounts");
          }
          return res.result;
        }
        /**
         * Fetch all the account info for the specified public key, return with context
         */
        async getAccountInfoAndContext(publicKey4, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([publicKey4.toBase58()], commitment, "base64", config);
          const unsafeRes = await this._rpcRequest("getAccountInfo", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.nullable(AccountInfoResult)));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey4.toBase58()}`);
          }
          return res.result;
        }
        /**
         * Fetch parsed account info for the specified public key
         */
        async getParsedAccountInfo(publicKey4, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([publicKey4.toBase58()], commitment, "jsonParsed", config);
          const unsafeRes = await this._rpcRequest("getAccountInfo", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.nullable(ParsedAccountInfoResult)));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey4.toBase58()}`);
          }
          return res.result;
        }
        /**
         * Fetch all the account info for the specified public key
         */
        async getAccountInfo(publicKey4, commitmentOrConfig) {
          try {
            const res = await this.getAccountInfoAndContext(publicKey4, commitmentOrConfig);
            return res.value;
          } catch (e) {
            throw new Error("failed to get info about account " + publicKey4.toBase58() + ": " + e);
          }
        }
        /**
         * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
         */
        async getMultipleParsedAccounts(publicKeys, rawConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(rawConfig);
          const keys = publicKeys.map((key) => key.toBase58());
          const args = this._buildArgs([keys], commitment, "jsonParsed", config);
          const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.array(superstruct.nullable(ParsedAccountInfoResult))));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
          }
          return res.result;
        }
        /**
         * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
         */
        async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const keys = publicKeys.map((key) => key.toBase58());
          const args = this._buildArgs([keys], commitment, "base64", config);
          const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.array(superstruct.nullable(AccountInfoResult))));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
          }
          return res.result;
        }
        /**
         * Fetch all the account info for multiple accounts specified by an array of public keys
         */
        async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
          const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
          return res.value;
        }
        /**
         * Returns epoch activation information for a stake account that has been delegated
         *
         * @deprecated Deprecated since RPC v1.18; will be removed in a future version.
         */
        async getStakeActivation(publicKey4, commitmentOrConfig, epoch) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([publicKey4.toBase58()], commitment, void 0, {
            ...config,
            epoch: epoch != null ? epoch : config?.epoch
          });
          const unsafeRes = await this._rpcRequest("getStakeActivation", args);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(StakeActivationResult));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey4.toBase58()}`);
          }
          return res.result;
        }
        /**
         * Fetch all the accounts owned by the specified program id
         *
         * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
         */
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        async getProgramAccounts(programId, configOrCommitment) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(configOrCommitment);
          const {
            encoding,
            ...configWithoutEncoding
          } = config || {};
          const args = this._buildArgs([programId.toBase58()], commitment, encoding || "base64", {
            ...configWithoutEncoding,
            ...configWithoutEncoding.filters ? {
              filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)
            } : null
          });
          const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
          const baseSchema = superstruct.array(KeyedAccountInfoResult);
          const res = configWithoutEncoding.withContext === true ? superstruct.create(unsafeRes, jsonRpcResultAndContext2(baseSchema)) : superstruct.create(unsafeRes, jsonRpcResult2(baseSchema));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
          }
          return res.result;
        }
        /**
         * Fetch and parse all the accounts owned by the specified program id
         *
         * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
         */
        async getParsedProgramAccounts(programId, configOrCommitment) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(configOrCommitment);
          const args = this._buildArgs([programId.toBase58()], commitment, "jsonParsed", config);
          const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.array(KeyedParsedAccountInfoResult)));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
          }
          return res.result;
        }
        /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        async confirmTransaction(strategy, commitment) {
          let rawSignature;
          if (typeof strategy == "string") {
            rawSignature = strategy;
          } else {
            const config = strategy;
            if (config.abortSignal?.aborted) {
              return Promise.reject(config.abortSignal.reason);
            }
            rawSignature = config.signature;
          }
          let decodedSignature;
          try {
            decodedSignature = bs58__default.default.decode(rawSignature);
          } catch (err2) {
            throw new Error("signature must be base58 encoded: " + rawSignature);
          }
          assert2(decodedSignature.length === 64, "signature has invalid length");
          if (typeof strategy === "string") {
            return await this.confirmTransactionUsingLegacyTimeoutStrategy({
              commitment: commitment || this.commitment,
              signature: rawSignature
            });
          } else if ("lastValidBlockHeight" in strategy) {
            return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
              commitment: commitment || this.commitment,
              strategy
            });
          } else {
            return await this.confirmTransactionUsingDurableNonceStrategy({
              commitment: commitment || this.commitment,
              strategy
            });
          }
        }
        getCancellationPromise(signal) {
          return new Promise((_, reject) => {
            if (signal == null) {
              return;
            }
            if (signal.aborted) {
              reject(signal.reason);
            } else {
              signal.addEventListener("abort", () => {
                reject(signal.reason);
              });
            }
          });
        }
        getTransactionConfirmationPromise({
          commitment,
          signature: signature2
        }) {
          let signatureSubscriptionId;
          let disposeSignatureSubscriptionStateChangeObserver;
          let done = false;
          const confirmationPromise = new Promise((resolve, reject) => {
            try {
              signatureSubscriptionId = this.onSignature(signature2, (result, context) => {
                signatureSubscriptionId = void 0;
                const response = {
                  context,
                  value: result
                };
                resolve({
                  __type: TransactionStatus.PROCESSED,
                  response
                });
              }, commitment);
              const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup) => {
                if (signatureSubscriptionId == null) {
                  resolveSubscriptionSetup();
                } else {
                  disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState) => {
                    if (nextState === "subscribed") {
                      resolveSubscriptionSetup();
                    }
                  });
                }
              });
              (async () => {
                await subscriptionSetupPromise;
                if (done) return;
                const response = await this.getSignatureStatus(signature2);
                if (done) return;
                if (response == null) {
                  return;
                }
                const {
                  context,
                  value
                } = response;
                if (value == null) {
                  return;
                }
                if (value?.err) {
                  reject(value.err);
                } else {
                  switch (commitment) {
                    case "confirmed":
                    case "single":
                    case "singleGossip": {
                      if (value.confirmationStatus === "processed") {
                        return;
                      }
                      break;
                    }
                    case "finalized":
                    case "max":
                    case "root": {
                      if (value.confirmationStatus === "processed" || value.confirmationStatus === "confirmed") {
                        return;
                      }
                      break;
                    }
                    // exhaust enums to ensure full coverage
                    case "processed":
                    case "recent":
                  }
                  done = true;
                  resolve({
                    __type: TransactionStatus.PROCESSED,
                    response: {
                      context,
                      value
                    }
                  });
                }
              })();
            } catch (err2) {
              reject(err2);
            }
          });
          const abortConfirmation = () => {
            if (disposeSignatureSubscriptionStateChangeObserver) {
              disposeSignatureSubscriptionStateChangeObserver();
              disposeSignatureSubscriptionStateChangeObserver = void 0;
            }
            if (signatureSubscriptionId != null) {
              this.removeSignatureListener(signatureSubscriptionId);
              signatureSubscriptionId = void 0;
            }
          };
          return {
            abortConfirmation,
            confirmationPromise
          };
        }
        async confirmTransactionUsingBlockHeightExceedanceStrategy({
          commitment,
          strategy: {
            abortSignal,
            lastValidBlockHeight,
            signature: signature2
          }
        }) {
          let done = false;
          const expiryPromise = new Promise((resolve) => {
            const checkBlockHeight = async () => {
              try {
                const blockHeight = await this.getBlockHeight(commitment);
                return blockHeight;
              } catch (_e) {
                return -1;
              }
            };
            (async () => {
              let currentBlockHeight = await checkBlockHeight();
              if (done) return;
              while (currentBlockHeight <= lastValidBlockHeight) {
                await sleep(1e3);
                if (done) return;
                currentBlockHeight = await checkBlockHeight();
                if (done) return;
              }
              resolve({
                __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
              });
            })();
          });
          const {
            abortConfirmation,
            confirmationPromise
          } = this.getTransactionConfirmationPromise({
            commitment,
            signature: signature2
          });
          const cancellationPromise = this.getCancellationPromise(abortSignal);
          let result;
          try {
            const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
            if (outcome.__type === TransactionStatus.PROCESSED) {
              result = outcome.response;
            } else {
              throw new TransactionExpiredBlockheightExceededError(signature2);
            }
          } finally {
            done = true;
            abortConfirmation();
          }
          return result;
        }
        async confirmTransactionUsingDurableNonceStrategy({
          commitment,
          strategy: {
            abortSignal,
            minContextSlot,
            nonceAccountPubkey,
            nonceValue,
            signature: signature2
          }
        }) {
          let done = false;
          const expiryPromise = new Promise((resolve) => {
            let currentNonceValue = nonceValue;
            let lastCheckedSlot = null;
            const getCurrentNonceValue = async () => {
              try {
                const {
                  context,
                  value: nonceAccount
                } = await this.getNonceAndContext(nonceAccountPubkey, {
                  commitment,
                  minContextSlot
                });
                lastCheckedSlot = context.slot;
                return nonceAccount?.nonce;
              } catch (e) {
                return currentNonceValue;
              }
            };
            (async () => {
              currentNonceValue = await getCurrentNonceValue();
              if (done) return;
              while (true) {
                if (nonceValue !== currentNonceValue) {
                  resolve({
                    __type: TransactionStatus.NONCE_INVALID,
                    slotInWhichNonceDidAdvance: lastCheckedSlot
                  });
                  return;
                }
                await sleep(2e3);
                if (done) return;
                currentNonceValue = await getCurrentNonceValue();
                if (done) return;
              }
            })();
          });
          const {
            abortConfirmation,
            confirmationPromise
          } = this.getTransactionConfirmationPromise({
            commitment,
            signature: signature2
          });
          const cancellationPromise = this.getCancellationPromise(abortSignal);
          let result;
          try {
            const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
            if (outcome.__type === TransactionStatus.PROCESSED) {
              result = outcome.response;
            } else {
              let signatureStatus;
              while (true) {
                const status = await this.getSignatureStatus(signature2);
                if (status == null) {
                  break;
                }
                if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
                  await sleep(400);
                  continue;
                }
                signatureStatus = status;
                break;
              }
              if (signatureStatus?.value) {
                const commitmentForStatus = commitment || "finalized";
                const {
                  confirmationStatus
                } = signatureStatus.value;
                switch (commitmentForStatus) {
                  case "processed":
                  case "recent":
                    if (confirmationStatus !== "processed" && confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                      throw new TransactionExpiredNonceInvalidError(signature2);
                    }
                    break;
                  case "confirmed":
                  case "single":
                  case "singleGossip":
                    if (confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                      throw new TransactionExpiredNonceInvalidError(signature2);
                    }
                    break;
                  case "finalized":
                  case "max":
                  case "root":
                    if (confirmationStatus !== "finalized") {
                      throw new TransactionExpiredNonceInvalidError(signature2);
                    }
                    break;
                  default:
                    /* @__PURE__ */ ((_) => {
                    })(commitmentForStatus);
                }
                result = {
                  context: signatureStatus.context,
                  value: {
                    err: signatureStatus.value.err
                  }
                };
              } else {
                throw new TransactionExpiredNonceInvalidError(signature2);
              }
            }
          } finally {
            done = true;
            abortConfirmation();
          }
          return result;
        }
        async confirmTransactionUsingLegacyTimeoutStrategy({
          commitment,
          signature: signature2
        }) {
          let timeoutId;
          const expiryPromise = new Promise((resolve) => {
            let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1e3;
            switch (commitment) {
              case "processed":
              case "recent":
              case "single":
              case "confirmed":
              case "singleGossip": {
                timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1e3;
                break;
              }
            }
            timeoutId = setTimeout(() => resolve({
              __type: TransactionStatus.TIMED_OUT,
              timeoutMs
            }), timeoutMs);
          });
          const {
            abortConfirmation,
            confirmationPromise
          } = this.getTransactionConfirmationPromise({
            commitment,
            signature: signature2
          });
          let result;
          try {
            const outcome = await Promise.race([confirmationPromise, expiryPromise]);
            if (outcome.__type === TransactionStatus.PROCESSED) {
              result = outcome.response;
            } else {
              throw new TransactionExpiredTimeoutError(signature2, outcome.timeoutMs / 1e3);
            }
          } finally {
            clearTimeout(timeoutId);
            abortConfirmation();
          }
          return result;
        }
        /**
         * Return the list of nodes that are currently participating in the cluster
         */
        async getClusterNodes() {
          const unsafeRes = await this._rpcRequest("getClusterNodes", []);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.array(ContactInfoResult)));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get cluster nodes");
          }
          return res.result;
        }
        /**
         * Return the list of nodes that are currently participating in the cluster
         */
        async getVoteAccounts(commitment) {
          const args = this._buildArgs([], commitment);
          const unsafeRes = await this._rpcRequest("getVoteAccounts", args);
          const res = superstruct.create(unsafeRes, GetVoteAccounts);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get vote accounts");
          }
          return res.result;
        }
        /**
         * Fetch the current slot that the node is processing
         */
        async getSlot(commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getSlot", args);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.number()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get slot");
          }
          return res.result;
        }
        /**
         * Fetch the current slot leader of the cluster
         */
        async getSlotLeader(commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getSlotLeader", args);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.string()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get slot leader");
          }
          return res.result;
        }
        /**
         * Fetch `limit` number of slot leaders starting from `startSlot`
         *
         * @param startSlot fetch slot leaders starting from this slot
         * @param limit number of slot leaders to return
         */
        async getSlotLeaders(startSlot, limit) {
          const args = [startSlot, limit];
          const unsafeRes = await this._rpcRequest("getSlotLeaders", args);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.array(PublicKeyFromString)));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get slot leaders");
          }
          return res.result;
        }
        /**
         * Fetch the current status of a signature
         */
        async getSignatureStatus(signature2, config) {
          const {
            context,
            value: values
          } = await this.getSignatureStatuses([signature2], config);
          assert2(values.length === 1);
          const value = values[0];
          return {
            context,
            value
          };
        }
        /**
         * Fetch the current statuses of a batch of signatures
         */
        async getSignatureStatuses(signatures, config) {
          const params = [signatures];
          if (config) {
            params.push(config);
          }
          const unsafeRes = await this._rpcRequest("getSignatureStatuses", params);
          const res = superstruct.create(unsafeRes, GetSignatureStatusesRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get signature status");
          }
          return res.result;
        }
        /**
         * Fetch the current transaction count of the cluster
         */
        async getTransactionCount(commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getTransactionCount", args);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.number()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get transaction count");
          }
          return res.result;
        }
        /**
         * Fetch the current total currency supply of the cluster in lamports
         *
         * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.
         */
        async getTotalSupply(commitment) {
          const result = await this.getSupply({
            commitment,
            excludeNonCirculatingAccountsList: true
          });
          return result.value.total;
        }
        /**
         * Fetch the cluster InflationGovernor parameters
         */
        async getInflationGovernor(commitment) {
          const args = this._buildArgs([], commitment);
          const unsafeRes = await this._rpcRequest("getInflationGovernor", args);
          const res = superstruct.create(unsafeRes, GetInflationGovernorRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get inflation");
          }
          return res.result;
        }
        /**
         * Fetch the inflation reward for a list of addresses for an epoch
         */
        async getInflationReward(addresses, epoch, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([addresses.map((pubkey2) => pubkey2.toBase58())], commitment, void 0, {
            ...config,
            epoch: epoch != null ? epoch : config?.epoch
          });
          const unsafeRes = await this._rpcRequest("getInflationReward", args);
          const res = superstruct.create(unsafeRes, GetInflationRewardResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get inflation reward");
          }
          return res.result;
        }
        /**
         * Fetch the specific inflation values for the current epoch
         */
        async getInflationRate() {
          const unsafeRes = await this._rpcRequest("getInflationRate", []);
          const res = superstruct.create(unsafeRes, GetInflationRateRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get inflation rate");
          }
          return res.result;
        }
        /**
         * Fetch the Epoch Info parameters
         */
        async getEpochInfo(commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getEpochInfo", args);
          const res = superstruct.create(unsafeRes, GetEpochInfoRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get epoch info");
          }
          return res.result;
        }
        /**
         * Fetch the Epoch Schedule parameters
         */
        async getEpochSchedule() {
          const unsafeRes = await this._rpcRequest("getEpochSchedule", []);
          const res = superstruct.create(unsafeRes, GetEpochScheduleRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get epoch schedule");
          }
          const epochSchedule = res.result;
          return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
        }
        /**
         * Fetch the leader schedule for the current epoch
         * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
         */
        async getLeaderSchedule() {
          const unsafeRes = await this._rpcRequest("getLeaderSchedule", []);
          const res = superstruct.create(unsafeRes, GetLeaderScheduleRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get leader schedule");
          }
          return res.result;
        }
        /**
         * Fetch the minimum balance needed to exempt an account of `dataLength`
         * size from rent
         */
        async getMinimumBalanceForRentExemption(dataLength, commitment) {
          const args = this._buildArgs([dataLength], commitment);
          const unsafeRes = await this._rpcRequest("getMinimumBalanceForRentExemption", args);
          const res = superstruct.create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
          if ("error" in res) {
            console.warn("Unable to fetch minimum balance for rent exemption");
            return 0;
          }
          return res.result;
        }
        /**
         * Fetch a recent blockhash from the cluster, return with context
         * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
         *
         * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.
         */
        async getRecentBlockhashAndContext(commitment) {
          const args = this._buildArgs([], commitment);
          const unsafeRes = await this._rpcRequest("getRecentBlockhash", args);
          const res = superstruct.create(unsafeRes, GetRecentBlockhashAndContextRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get recent blockhash");
          }
          return res.result;
        }
        /**
         * Fetch recent performance samples
         * @return {Promise<Array<PerfSample>>}
         */
        async getRecentPerformanceSamples(limit) {
          const unsafeRes = await this._rpcRequest("getRecentPerformanceSamples", limit ? [limit] : []);
          const res = superstruct.create(unsafeRes, GetRecentPerformanceSamplesRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get recent performance samples");
          }
          return res.result;
        }
        /**
         * Fetch the fee calculator for a recent blockhash from the cluster, return with context
         *
         * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.
         */
        async getFeeCalculatorForBlockhash(blockhash, commitment) {
          const args = this._buildArgs([blockhash], commitment);
          const unsafeRes = await this._rpcRequest("getFeeCalculatorForBlockhash", args);
          const res = superstruct.create(unsafeRes, GetFeeCalculatorRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get fee calculator");
          }
          const {
            context,
            value
          } = res.result;
          return {
            context,
            value: value !== null ? value.feeCalculator : null
          };
        }
        /**
         * Fetch the fee for a message from the cluster, return with context
         */
        async getFeeForMessage(message, commitment) {
          const wireMessage = toBuffer(message.serialize()).toString("base64");
          const args = this._buildArgs([wireMessage], commitment);
          const unsafeRes = await this._rpcRequest("getFeeForMessage", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.nullable(superstruct.number())));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get fee for message");
          }
          if (res.result === null) {
            throw new Error("invalid blockhash");
          }
          return res.result;
        }
        /**
         * Fetch a list of prioritization fees from recent blocks.
         */
        async getRecentPrioritizationFees(config) {
          const accounts = config?.lockedWritableAccounts?.map((key) => key.toBase58());
          const args = accounts?.length ? [accounts] : [];
          const unsafeRes = await this._rpcRequest("getRecentPrioritizationFees", args);
          const res = superstruct.create(unsafeRes, GetRecentPrioritizationFeesRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get recent prioritization fees");
          }
          return res.result;
        }
        /**
         * Fetch a recent blockhash from the cluster
         * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
         *
         * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.
         */
        async getRecentBlockhash(commitment) {
          try {
            const res = await this.getRecentBlockhashAndContext(commitment);
            return res.value;
          } catch (e) {
            throw new Error("failed to get recent blockhash: " + e);
          }
        }
        /**
         * Fetch the latest blockhash from the cluster
         * @return {Promise<BlockhashWithExpiryBlockHeight>}
         */
        async getLatestBlockhash(commitmentOrConfig) {
          try {
            const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
            return res.value;
          } catch (e) {
            throw new Error("failed to get recent blockhash: " + e);
          }
        }
        /**
         * Fetch the latest blockhash from the cluster
         * @return {Promise<BlockhashWithExpiryBlockHeight>}
         */
        async getLatestBlockhashAndContext(commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getLatestBlockhash", args);
          const res = superstruct.create(unsafeRes, GetLatestBlockhashRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get latest blockhash");
          }
          return res.result;
        }
        /**
         * Returns whether a blockhash is still valid or not
         */
        async isBlockhashValid(blockhash, rawConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(rawConfig);
          const args = this._buildArgs([blockhash], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("isBlockhashValid", args);
          const res = superstruct.create(unsafeRes, IsBlockhashValidRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to determine if the blockhash `" + blockhash + "`is valid");
          }
          return res.result;
        }
        /**
         * Fetch the node version
         */
        async getVersion() {
          const unsafeRes = await this._rpcRequest("getVersion", []);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(VersionResult));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get version");
          }
          return res.result;
        }
        /**
         * Fetch the genesis hash
         */
        async getGenesisHash() {
          const unsafeRes = await this._rpcRequest("getGenesisHash", []);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.string()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get genesis hash");
          }
          return res.result;
        }
        /**
         * Fetch a processed block from the cluster.
         *
         * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
         * setting the `maxSupportedTransactionVersion` property.
         */
        /**
         * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
         * setting the `maxSupportedTransactionVersion` property.
         */
        // eslint-disable-next-line no-dupe-class-members
        /**
         * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
         * setting the `maxSupportedTransactionVersion` property.
         */
        // eslint-disable-next-line no-dupe-class-members
        /**
         * Fetch a processed block from the cluster.
         */
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        /**
         * Fetch a processed block from the cluster.
         */
        // eslint-disable-next-line no-dupe-class-members
        async getBlock(slot, rawConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(rawConfig);
          const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getBlock", args);
          try {
            switch (config?.transactionDetails) {
              case "accounts": {
                const res = superstruct.create(unsafeRes, GetAccountsModeBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                return res.result;
              }
              case "none": {
                const res = superstruct.create(unsafeRes, GetNoneModeBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                return res.result;
              }
              default: {
                const res = superstruct.create(unsafeRes, GetBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                const {
                  result
                } = res;
                return result ? {
                  ...result,
                  transactions: result.transactions.map(({
                    transaction,
                    meta,
                    version: version2
                  }) => ({
                    meta,
                    transaction: {
                      ...transaction,
                      message: versionedMessageFromResponse(version2, transaction.message)
                    },
                    version: version2
                  }))
                } : null;
              }
            }
          } catch (e) {
            throw new SolanaJSONRPCError(e, "failed to get confirmed block");
          }
        }
        /**
         * Fetch parsed transaction details for a confirmed or finalized block
         */
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        async getParsedBlock(slot, rawConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(rawConfig);
          const args = this._buildArgsAtLeastConfirmed([slot], commitment, "jsonParsed", config);
          const unsafeRes = await this._rpcRequest("getBlock", args);
          try {
            switch (config?.transactionDetails) {
              case "accounts": {
                const res = superstruct.create(unsafeRes, GetParsedAccountsModeBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                return res.result;
              }
              case "none": {
                const res = superstruct.create(unsafeRes, GetParsedNoneModeBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                return res.result;
              }
              default: {
                const res = superstruct.create(unsafeRes, GetParsedBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                return res.result;
              }
            }
          } catch (e) {
            throw new SolanaJSONRPCError(e, "failed to get block");
          }
        }
        /*
         * Returns recent block production information from the current or previous epoch
         */
        async getBlockProduction(configOrCommitment) {
          let extra;
          let commitment;
          if (typeof configOrCommitment === "string") {
            commitment = configOrCommitment;
          } else if (configOrCommitment) {
            const {
              commitment: c,
              ...rest
            } = configOrCommitment;
            commitment = c;
            extra = rest;
          }
          const args = this._buildArgs([], commitment, "base64", extra);
          const unsafeRes = await this._rpcRequest("getBlockProduction", args);
          const res = superstruct.create(unsafeRes, BlockProductionResponseStruct);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get block production information");
          }
          return res.result;
        }
        /**
         * Fetch a confirmed or finalized transaction from the cluster.
         *
         * @deprecated Instead, call `getTransaction` using a
         * `GetVersionedTransactionConfig` by setting the
         * `maxSupportedTransactionVersion` property.
         */
        /**
         * Fetch a confirmed or finalized transaction from the cluster.
         */
        // eslint-disable-next-line no-dupe-class-members
        /**
         * Fetch a confirmed or finalized transaction from the cluster.
         */
        // eslint-disable-next-line no-dupe-class-members
        async getTransaction(signature2, rawConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(rawConfig);
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getTransaction", args);
          const res = superstruct.create(unsafeRes, GetTransactionRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get transaction");
          }
          const result = res.result;
          if (!result) return result;
          return {
            ...result,
            transaction: {
              ...result.transaction,
              message: versionedMessageFromResponse(result.version, result.transaction.message)
            }
          };
        }
        /**
         * Fetch parsed transaction details for a confirmed or finalized transaction
         */
        async getParsedTransaction(signature2, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config);
          const unsafeRes = await this._rpcRequest("getTransaction", args);
          const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get transaction");
          }
          return res.result;
        }
        /**
         * Fetch parsed transaction details for a batch of confirmed transactions
         */
        async getParsedTransactions(signatures, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const batch = signatures.map((signature2) => {
            const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config);
            return {
              methodName: "getTransaction",
              args
            };
          });
          const unsafeRes = await this._rpcBatchRequest(batch);
          const res = unsafeRes.map((unsafeRes2) => {
            const res2 = superstruct.create(unsafeRes2, GetParsedTransactionRpcResult);
            if ("error" in res2) {
              throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
            }
            return res2.result;
          });
          return res;
        }
        /**
         * Fetch transaction details for a batch of confirmed transactions.
         * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
         *
         * @deprecated Instead, call `getTransactions` using a
         * `GetVersionedTransactionConfig` by setting the
         * `maxSupportedTransactionVersion` property.
         */
        /**
         * Fetch transaction details for a batch of confirmed transactions.
         * Similar to {@link getParsedTransactions} but returns a {@link
         * VersionedTransactionResponse}.
         */
        // eslint-disable-next-line no-dupe-class-members
        /**
         * Fetch transaction details for a batch of confirmed transactions.
         * Similar to {@link getParsedTransactions} but returns a {@link
         * VersionedTransactionResponse}.
         */
        // eslint-disable-next-line no-dupe-class-members
        async getTransactions(signatures, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const batch = signatures.map((signature2) => {
            const args = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config);
            return {
              methodName: "getTransaction",
              args
            };
          });
          const unsafeRes = await this._rpcBatchRequest(batch);
          const res = unsafeRes.map((unsafeRes2) => {
            const res2 = superstruct.create(unsafeRes2, GetTransactionRpcResult);
            if ("error" in res2) {
              throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
            }
            const result = res2.result;
            if (!result) return result;
            return {
              ...result,
              transaction: {
                ...result.transaction,
                message: versionedMessageFromResponse(result.version, result.transaction.message)
              }
            };
          });
          return res;
        }
        /**
         * Fetch a list of Transactions and transaction statuses from the cluster
         * for a confirmed block.
         *
         * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.
         */
        async getConfirmedBlock(slot, commitment) {
          const args = this._buildArgsAtLeastConfirmed([slot], commitment);
          const unsafeRes = await this._rpcRequest("getConfirmedBlock", args);
          const res = superstruct.create(unsafeRes, GetConfirmedBlockRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
          }
          const result = res.result;
          if (!result) {
            throw new Error("Confirmed block " + slot + " not found");
          }
          const block = {
            ...result,
            transactions: result.transactions.map(({
              transaction,
              meta
            }) => {
              const message = new Message(transaction.message);
              return {
                meta,
                transaction: {
                  ...transaction,
                  message
                }
              };
            })
          };
          return {
            ...block,
            transactions: block.transactions.map(({
              transaction,
              meta
            }) => {
              return {
                meta,
                transaction: Transaction2.populate(transaction.message, transaction.signatures)
              };
            })
          };
        }
        /**
         * Fetch confirmed blocks between two slots
         */
        async getBlocks(startSlot, endSlot, commitment) {
          const args = this._buildArgsAtLeastConfirmed(endSlot !== void 0 ? [startSlot, endSlot] : [startSlot], commitment);
          const unsafeRes = await this._rpcRequest("getBlocks", args);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.array(superstruct.number())));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get blocks");
          }
          return res.result;
        }
        /**
         * Fetch a list of Signatures from the cluster for a block, excluding rewards
         */
        async getBlockSignatures(slot, commitment) {
          const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
            transactionDetails: "signatures",
            rewards: false
          });
          const unsafeRes = await this._rpcRequest("getBlock", args);
          const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get block");
          }
          const result = res.result;
          if (!result) {
            throw new Error("Block " + slot + " not found");
          }
          return result;
        }
        /**
         * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
         *
         * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.
         */
        async getConfirmedBlockSignatures(slot, commitment) {
          const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
            transactionDetails: "signatures",
            rewards: false
          });
          const unsafeRes = await this._rpcRequest("getConfirmedBlock", args);
          const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
          }
          const result = res.result;
          if (!result) {
            throw new Error("Confirmed block " + slot + " not found");
          }
          return result;
        }
        /**
         * Fetch a transaction details for a confirmed transaction
         *
         * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.
         */
        async getConfirmedTransaction(signature2, commitment) {
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment);
          const unsafeRes = await this._rpcRequest("getConfirmedTransaction", args);
          const res = superstruct.create(unsafeRes, GetTransactionRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get transaction");
          }
          const result = res.result;
          if (!result) return result;
          const message = new Message(result.transaction.message);
          const signatures = result.transaction.signatures;
          return {
            ...result,
            transaction: Transaction2.populate(message, signatures)
          };
        }
        /**
         * Fetch parsed transaction details for a confirmed transaction
         *
         * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.
         */
        async getParsedConfirmedTransaction(signature2, commitment) {
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
          const unsafeRes = await this._rpcRequest("getConfirmedTransaction", args);
          const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get confirmed transaction");
          }
          return res.result;
        }
        /**
         * Fetch parsed transaction details for a batch of confirmed transactions
         *
         * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.
         */
        async getParsedConfirmedTransactions(signatures, commitment) {
          const batch = signatures.map((signature2) => {
            const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
            return {
              methodName: "getConfirmedTransaction",
              args
            };
          });
          const unsafeRes = await this._rpcBatchRequest(batch);
          const res = unsafeRes.map((unsafeRes2) => {
            const res2 = superstruct.create(unsafeRes2, GetParsedTransactionRpcResult);
            if ("error" in res2) {
              throw new SolanaJSONRPCError(res2.error, "failed to get confirmed transactions");
            }
            return res2.result;
          });
          return res;
        }
        /**
         * Fetch a list of all the confirmed signatures for transactions involving an address
         * within a specified slot range. Max range allowed is 10,000 slots.
         *
         * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
         *
         * @param address queried address
         * @param startSlot start slot, inclusive
         * @param endSlot end slot, inclusive
         */
        async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
          let options = {};
          let firstAvailableBlock = await this.getFirstAvailableBlock();
          while (!("until" in options)) {
            startSlot--;
            if (startSlot <= 0 || startSlot < firstAvailableBlock) {
              break;
            }
            try {
              const block = await this.getConfirmedBlockSignatures(startSlot, "finalized");
              if (block.signatures.length > 0) {
                options.until = block.signatures[block.signatures.length - 1].toString();
              }
            } catch (err2) {
              if (err2 instanceof Error && err2.message.includes("skipped")) {
                continue;
              } else {
                throw err2;
              }
            }
          }
          let highestConfirmedRoot = await this.getSlot("finalized");
          while (!("before" in options)) {
            endSlot++;
            if (endSlot > highestConfirmedRoot) {
              break;
            }
            try {
              const block = await this.getConfirmedBlockSignatures(endSlot);
              if (block.signatures.length > 0) {
                options.before = block.signatures[block.signatures.length - 1].toString();
              }
            } catch (err2) {
              if (err2 instanceof Error && err2.message.includes("skipped")) {
                continue;
              } else {
                throw err2;
              }
            }
          }
          const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
          return confirmedSignatureInfo.map((info) => info.signature);
        }
        /**
         * Returns confirmed signatures for transactions involving an
         * address backwards in time from the provided signature or most recent confirmed block
         *
         * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.
         */
        async getConfirmedSignaturesForAddress2(address, options, commitment) {
          const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
          const unsafeRes = await this._rpcRequest("getConfirmedSignaturesForAddress2", args);
          const res = superstruct.create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get confirmed signatures for address");
          }
          return res.result;
        }
        /**
         * Returns confirmed signatures for transactions involving an
         * address backwards in time from the provided signature or most recent confirmed block
         *
         *
         * @param address queried address
         * @param options
         */
        async getSignaturesForAddress(address, options, commitment) {
          const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
          const unsafeRes = await this._rpcRequest("getSignaturesForAddress", args);
          const res = superstruct.create(unsafeRes, GetSignaturesForAddressRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get signatures for address");
          }
          return res.result;
        }
        async getAddressLookupTable(accountKey, config) {
          const {
            context,
            value: accountInfo
          } = await this.getAccountInfoAndContext(accountKey, config);
          let value = null;
          if (accountInfo !== null) {
            value = new AddressLookupTableAccount({
              key: accountKey,
              state: AddressLookupTableAccount.deserialize(accountInfo.data)
            });
          }
          return {
            context,
            value
          };
        }
        /**
         * Fetch the contents of a Nonce account from the cluster, return with context
         */
        async getNonceAndContext(nonceAccount, commitmentOrConfig) {
          const {
            context,
            value: accountInfo
          } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
          let value = null;
          if (accountInfo !== null) {
            value = NonceAccount.fromAccountData(accountInfo.data);
          }
          return {
            context,
            value
          };
        }
        /**
         * Fetch the contents of a Nonce account from the cluster
         */
        async getNonce(nonceAccount, commitmentOrConfig) {
          return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x) => x.value).catch((e) => {
            throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e);
          });
        }
        /**
         * Request an allocation of lamports to the specified address
         *
         * ```typescript
         * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
         *
         * (async () => {
         *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
         *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
         *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
         *   await connection.confirmTransaction(signature);
         * })();
         * ```
         */
        async requestAirdrop(to, lamports) {
          const unsafeRes = await this._rpcRequest("requestAirdrop", [to.toBase58(), lamports]);
          const res = superstruct.create(unsafeRes, RequestAirdropRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
          }
          return res.result;
        }
        /**
         * @internal
         */
        async _blockhashWithExpiryBlockHeight(disableCache) {
          if (!disableCache) {
            while (this._pollingBlockhash) {
              await sleep(100);
            }
            const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
            const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
            if (this._blockhashInfo.latestBlockhash !== null && !expired) {
              return this._blockhashInfo.latestBlockhash;
            }
          }
          return await this._pollNewBlockhash();
        }
        /**
         * @internal
         */
        async _pollNewBlockhash() {
          this._pollingBlockhash = true;
          try {
            const startTime = Date.now();
            const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
            const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
            for (let i = 0; i < 50; i++) {
              const latestBlockhash = await this.getLatestBlockhash("finalized");
              if (cachedBlockhash !== latestBlockhash.blockhash) {
                this._blockhashInfo = {
                  latestBlockhash,
                  lastFetch: Date.now(),
                  transactionSignatures: [],
                  simulatedSignatures: []
                };
                return latestBlockhash;
              }
              await sleep(MS_PER_SLOT / 2);
            }
            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
          } finally {
            this._pollingBlockhash = false;
          }
        }
        /**
         * get the stake minimum delegation
         */
        async getStakeMinimumDelegation(config) {
          const {
            commitment,
            config: configArg
          } = extractCommitmentFromConfig(config);
          const args = this._buildArgs([], commitment, "base64", configArg);
          const unsafeRes = await this._rpcRequest("getStakeMinimumDelegation", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.number()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
          }
          return res.result;
        }
        /**
         * Simulate a transaction
         *
         * @deprecated Instead, call {@link simulateTransaction} with {@link
         * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
         */
        /**
         * Simulate a transaction
         */
        // eslint-disable-next-line no-dupe-class-members
        /**
         * Simulate a transaction
         */
        // eslint-disable-next-line no-dupe-class-members
        async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
          if ("message" in transactionOrMessage) {
            const versionedTx = transactionOrMessage;
            const wireTransaction2 = versionedTx.serialize();
            const encodedTransaction2 = buffer.Buffer.from(wireTransaction2).toString("base64");
            if (Array.isArray(configOrSigners) || includeAccounts !== void 0) {
              throw new Error("Invalid arguments");
            }
            const config2 = configOrSigners || {};
            config2.encoding = "base64";
            if (!("commitment" in config2)) {
              config2.commitment = this.commitment;
            }
            if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
              config2.innerInstructions = configOrSigners.innerInstructions;
            }
            const args2 = [encodedTransaction2, config2];
            const unsafeRes2 = await this._rpcRequest("simulateTransaction", args2);
            const res2 = superstruct.create(unsafeRes2, SimulatedTransactionResponseStruct2);
            if ("error" in res2) {
              throw new Error("failed to simulate transaction: " + res2.error.message);
            }
            return res2.result;
          }
          let transaction;
          if (transactionOrMessage instanceof Transaction2) {
            let originalTx = transactionOrMessage;
            transaction = new Transaction2();
            transaction.feePayer = originalTx.feePayer;
            transaction.instructions = transactionOrMessage.instructions;
            transaction.nonceInfo = originalTx.nonceInfo;
            transaction.signatures = originalTx.signatures;
          } else {
            transaction = Transaction2.populate(transactionOrMessage);
            transaction._message = transaction._json = void 0;
          }
          if (configOrSigners !== void 0 && !Array.isArray(configOrSigners)) {
            throw new Error("Invalid arguments");
          }
          const signers = configOrSigners;
          if (transaction.nonceInfo && signers) {
            transaction.sign(...signers);
          } else {
            let disableCache = this._disableBlockhashCaching;
            for (; ; ) {
              const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
              transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
              transaction.recentBlockhash = latestBlockhash.blockhash;
              if (!signers) break;
              transaction.sign(...signers);
              if (!transaction.signature) {
                throw new Error("!signature");
              }
              const signature2 = transaction.signature.toString("base64");
              if (!this._blockhashInfo.simulatedSignatures.includes(signature2) && !this._blockhashInfo.transactionSignatures.includes(signature2)) {
                this._blockhashInfo.simulatedSignatures.push(signature2);
                break;
              } else {
                disableCache = true;
              }
            }
          }
          const message = transaction._compile();
          const signData = message.serialize();
          const wireTransaction = transaction._serialize(signData);
          const encodedTransaction = wireTransaction.toString("base64");
          const config = {
            encoding: "base64",
            commitment: this.commitment
          };
          if (includeAccounts) {
            const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
            config["accounts"] = {
              encoding: "base64",
              addresses
            };
          }
          if (signers) {
            config.sigVerify = true;
          }
          if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
            config.innerInstructions = configOrSigners.innerInstructions;
          }
          const args = [encodedTransaction, config];
          const unsafeRes = await this._rpcRequest("simulateTransaction", args);
          const res = superstruct.create(unsafeRes, SimulatedTransactionResponseStruct2);
          if ("error" in res) {
            let logs;
            if ("data" in res.error) {
              logs = res.error.data.logs;
              if (logs && Array.isArray(logs)) {
                const traceIndent = "\n    ";
                const logTrace = traceIndent + logs.join(traceIndent);
                console.error(res.error.message, logTrace);
              }
            }
            throw new SendTransactionError2({
              action: "simulate",
              signature: "",
              transactionMessage: res.error.message,
              logs
            });
          }
          return res.result;
        }
        /**
         * Sign and send a transaction
         *
         * @deprecated Instead, call {@link sendTransaction} with a {@link
         * VersionedTransaction}
         */
        /**
         * Send a signed transaction
         */
        // eslint-disable-next-line no-dupe-class-members
        /**
         * Sign and send a transaction
         */
        // eslint-disable-next-line no-dupe-class-members
        async sendTransaction(transaction, signersOrOptions, options) {
          if ("version" in transaction) {
            if (signersOrOptions && Array.isArray(signersOrOptions)) {
              throw new Error("Invalid arguments");
            }
            const wireTransaction2 = transaction.serialize();
            return await this.sendRawTransaction(wireTransaction2, signersOrOptions);
          }
          if (signersOrOptions === void 0 || !Array.isArray(signersOrOptions)) {
            throw new Error("Invalid arguments");
          }
          const signers = signersOrOptions;
          if (transaction.nonceInfo) {
            transaction.sign(...signers);
          } else {
            let disableCache = this._disableBlockhashCaching;
            for (; ; ) {
              const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
              transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
              transaction.recentBlockhash = latestBlockhash.blockhash;
              transaction.sign(...signers);
              if (!transaction.signature) {
                throw new Error("!signature");
              }
              const signature2 = transaction.signature.toString("base64");
              if (!this._blockhashInfo.transactionSignatures.includes(signature2)) {
                this._blockhashInfo.transactionSignatures.push(signature2);
                break;
              } else {
                disableCache = true;
              }
            }
          }
          const wireTransaction = transaction.serialize();
          return await this.sendRawTransaction(wireTransaction, options);
        }
        /**
         * Send a transaction that has already been signed and serialized into the
         * wire format
         */
        async sendRawTransaction(rawTransaction, options) {
          const encodedTransaction = toBuffer(rawTransaction).toString("base64");
          const result = await this.sendEncodedTransaction(encodedTransaction, options);
          return result;
        }
        /**
         * Send a transaction that has already been signed, serialized into the
         * wire format, and encoded as a base64 string
         */
        async sendEncodedTransaction(encodedTransaction, options) {
          const config = {
            encoding: "base64"
          };
          const skipPreflight = options && options.skipPreflight;
          const preflightCommitment = skipPreflight === true ? "processed" : options && options.preflightCommitment || this.commitment;
          if (options && options.maxRetries != null) {
            config.maxRetries = options.maxRetries;
          }
          if (options && options.minContextSlot != null) {
            config.minContextSlot = options.minContextSlot;
          }
          if (skipPreflight) {
            config.skipPreflight = skipPreflight;
          }
          if (preflightCommitment) {
            config.preflightCommitment = preflightCommitment;
          }
          const args = [encodedTransaction, config];
          const unsafeRes = await this._rpcRequest("sendTransaction", args);
          const res = superstruct.create(unsafeRes, SendTransactionRpcResult);
          if ("error" in res) {
            let logs = void 0;
            if ("data" in res.error) {
              logs = res.error.data.logs;
            }
            throw new SendTransactionError2({
              action: skipPreflight ? "send" : "simulate",
              signature: "",
              transactionMessage: res.error.message,
              logs
            });
          }
          return res.result;
        }
        /**
         * @internal
         */
        _wsOnOpen() {
          this._rpcWebSocketConnected = true;
          this._rpcWebSocketHeartbeat = setInterval(() => {
            (async () => {
              try {
                await this._rpcWebSocket.notify("ping");
              } catch {
              }
            })();
          }, 5e3);
          this._updateSubscriptions();
        }
        /**
         * @internal
         */
        _wsOnError(err2) {
          this._rpcWebSocketConnected = false;
          console.error("ws error:", err2.message);
        }
        /**
         * @internal
         */
        _wsOnClose(code) {
          this._rpcWebSocketConnected = false;
          this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
          if (this._rpcWebSocketIdleTimeout) {
            clearTimeout(this._rpcWebSocketIdleTimeout);
            this._rpcWebSocketIdleTimeout = null;
          }
          if (this._rpcWebSocketHeartbeat) {
            clearInterval(this._rpcWebSocketHeartbeat);
            this._rpcWebSocketHeartbeat = null;
          }
          if (code === 1e3) {
            this._updateSubscriptions();
            return;
          }
          this._subscriptionCallbacksByServerSubscriptionId = {};
          Object.entries(this._subscriptionsByHash).forEach(([hash2, subscription]) => {
            this._setSubscription(hash2, {
              ...subscription,
              state: "pending"
            });
          });
        }
        /**
         * @internal
         */
        _setSubscription(hash2, nextSubscription) {
          const prevState = this._subscriptionsByHash[hash2]?.state;
          this._subscriptionsByHash[hash2] = nextSubscription;
          if (prevState !== nextSubscription.state) {
            const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash2];
            if (stateChangeCallbacks) {
              stateChangeCallbacks.forEach((cb) => {
                try {
                  cb(nextSubscription.state);
                } catch {
                }
              });
            }
          }
        }
        /**
         * @internal
         */
        _onSubscriptionStateChange(clientSubscriptionId, callback) {
          const hash2 = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
          if (hash2 == null) {
            return () => {
            };
          }
          const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash2] ||= /* @__PURE__ */ new Set();
          stateChangeCallbacks.add(callback);
          return () => {
            stateChangeCallbacks.delete(callback);
            if (stateChangeCallbacks.size === 0) {
              delete this._subscriptionStateChangeCallbacksByHash[hash2];
            }
          };
        }
        /**
         * @internal
         */
        async _updateSubscriptions() {
          if (Object.keys(this._subscriptionsByHash).length === 0) {
            if (this._rpcWebSocketConnected) {
              this._rpcWebSocketConnected = false;
              this._rpcWebSocketIdleTimeout = setTimeout(() => {
                this._rpcWebSocketIdleTimeout = null;
                try {
                  this._rpcWebSocket.close();
                } catch (err2) {
                  if (err2 instanceof Error) {
                    console.log(`Error when closing socket connection: ${err2.message}`);
                  }
                }
              }, 500);
            }
            return;
          }
          if (this._rpcWebSocketIdleTimeout !== null) {
            clearTimeout(this._rpcWebSocketIdleTimeout);
            this._rpcWebSocketIdleTimeout = null;
            this._rpcWebSocketConnected = true;
          }
          if (!this._rpcWebSocketConnected) {
            this._rpcWebSocket.connect();
            return;
          }
          const activeWebSocketGeneration = this._rpcWebSocketGeneration;
          const isCurrentConnectionStillActive = () => {
            return activeWebSocketGeneration === this._rpcWebSocketGeneration;
          };
          await Promise.all(
            // Don't be tempted to change this to `Object.entries`. We call
            // `_updateSubscriptions` recursively when processing the state,
            // so it's important that we look up the *current* version of
            // each subscription, every time we process a hash.
            Object.keys(this._subscriptionsByHash).map(async (hash2) => {
              const subscription = this._subscriptionsByHash[hash2];
              if (subscription === void 0) {
                return;
              }
              switch (subscription.state) {
                case "pending":
                case "unsubscribed":
                  if (subscription.callbacks.size === 0) {
                    delete this._subscriptionsByHash[hash2];
                    if (subscription.state === "unsubscribed") {
                      delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
                    }
                    await this._updateSubscriptions();
                    return;
                  }
                  await (async () => {
                    const {
                      args,
                      method
                    } = subscription;
                    try {
                      this._setSubscription(hash2, {
                        ...subscription,
                        state: "subscribing"
                      });
                      const serverSubscriptionId = await this._rpcWebSocket.call(method, args);
                      this._setSubscription(hash2, {
                        ...subscription,
                        serverSubscriptionId,
                        state: "subscribed"
                      });
                      this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
                      await this._updateSubscriptions();
                    } catch (e) {
                      if (e instanceof Error) {
                        console.error(`${method} error for argument`, args, e.message);
                      }
                      if (!isCurrentConnectionStillActive()) {
                        return;
                      }
                      this._setSubscription(hash2, {
                        ...subscription,
                        state: "pending"
                      });
                      await this._updateSubscriptions();
                    }
                  })();
                  break;
                case "subscribed":
                  if (subscription.callbacks.size === 0) {
                    await (async () => {
                      const {
                        serverSubscriptionId,
                        unsubscribeMethod
                      } = subscription;
                      if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                        this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
                      } else {
                        this._setSubscription(hash2, {
                          ...subscription,
                          state: "unsubscribing"
                        });
                        this._setSubscription(hash2, {
                          ...subscription,
                          state: "unsubscribing"
                        });
                        try {
                          await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                        } catch (e) {
                          if (e instanceof Error) {
                            console.error(`${unsubscribeMethod} error:`, e.message);
                          }
                          if (!isCurrentConnectionStillActive()) {
                            return;
                          }
                          this._setSubscription(hash2, {
                            ...subscription,
                            state: "subscribed"
                          });
                          await this._updateSubscriptions();
                          return;
                        }
                      }
                      this._setSubscription(hash2, {
                        ...subscription,
                        state: "unsubscribed"
                      });
                      await this._updateSubscriptions();
                    })();
                  }
                  break;
              }
            })
          );
        }
        /**
         * @internal
         */
        _handleServerNotification(serverSubscriptionId, callbackArgs) {
          const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
          if (callbacks === void 0) {
            return;
          }
          callbacks.forEach((cb) => {
            try {
              cb(
                ...callbackArgs
              );
            } catch (e) {
              console.error(e);
            }
          });
        }
        /**
         * @internal
         */
        _wsOnAccountNotification(notification) {
          const {
            result,
            subscription
          } = superstruct.create(notification, AccountNotificationResult);
          this._handleServerNotification(subscription, [result.value, result.context]);
        }
        /**
         * @internal
         */
        _makeSubscription(subscriptionConfig, args) {
          const clientSubscriptionId = this._nextClientSubscriptionId++;
          const hash2 = fastStableStringify$1([subscriptionConfig.method, args]);
          const existingSubscription = this._subscriptionsByHash[hash2];
          if (existingSubscription === void 0) {
            this._subscriptionsByHash[hash2] = {
              ...subscriptionConfig,
              args,
              callbacks: /* @__PURE__ */ new Set([subscriptionConfig.callback]),
              state: "pending"
            };
          } else {
            existingSubscription.callbacks.add(subscriptionConfig.callback);
          }
          this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash2;
          this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
            delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
            const subscription = this._subscriptionsByHash[hash2];
            assert2(subscription !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
            subscription.callbacks.delete(subscriptionConfig.callback);
            await this._updateSubscriptions();
          };
          this._updateSubscriptions();
          return clientSubscriptionId;
        }
        /**
         * Register a callback to be invoked whenever the specified account changes
         *
         * @param publicKey Public key of the account to monitor
         * @param callback Function to invoke whenever the account is changed
         * @param config
         * @return subscription id
         */
        /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        onAccountChange(publicKey4, callback, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs(
            [publicKey4.toBase58()],
            commitment || this._commitment || "finalized",
            // Apply connection/server default.
            "base64",
            config
          );
          return this._makeSubscription({
            callback,
            method: "accountSubscribe",
            unsubscribeMethod: "accountUnsubscribe"
          }, args);
        }
        /**
         * Deregister an account notification callback
         *
         * @param clientSubscriptionId client subscription id to deregister
         */
        async removeAccountChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "account change");
        }
        /**
         * @internal
         */
        _wsOnProgramAccountNotification(notification) {
          const {
            result,
            subscription
          } = superstruct.create(notification, ProgramAccountNotificationResult);
          this._handleServerNotification(subscription, [{
            accountId: result.value.pubkey,
            accountInfo: result.value.account
          }, result.context]);
        }
        /**
         * Register a callback to be invoked whenever accounts owned by the
         * specified program change
         *
         * @param programId Public key of the program to monitor
         * @param callback Function to invoke whenever the account is changed
         * @param config
         * @return subscription id
         */
        /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs(
            [programId.toBase58()],
            commitment || this._commitment || "finalized",
            // Apply connection/server default.
            "base64",
            config ? config : maybeFilters ? {
              filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)
            } : void 0
            /* extra */
          );
          return this._makeSubscription({
            callback,
            method: "programSubscribe",
            unsubscribeMethod: "programUnsubscribe"
          }, args);
        }
        /**
         * Deregister an account notification callback
         *
         * @param clientSubscriptionId client subscription id to deregister
         */
        async removeProgramAccountChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "program account change");
        }
        /**
         * Registers a callback to be invoked whenever logs are emitted.
         */
        onLogs(filter, callback, commitment) {
          const args = this._buildArgs(
            [typeof filter === "object" ? {
              mentions: [filter.toString()]
            } : filter],
            commitment || this._commitment || "finalized"
            // Apply connection/server default.
          );
          return this._makeSubscription({
            callback,
            method: "logsSubscribe",
            unsubscribeMethod: "logsUnsubscribe"
          }, args);
        }
        /**
         * Deregister a logs callback.
         *
         * @param clientSubscriptionId client subscription id to deregister.
         */
        async removeOnLogsListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "logs");
        }
        /**
         * @internal
         */
        _wsOnLogsNotification(notification) {
          const {
            result,
            subscription
          } = superstruct.create(notification, LogsNotificationResult);
          this._handleServerNotification(subscription, [result.value, result.context]);
        }
        /**
         * @internal
         */
        _wsOnSlotNotification(notification) {
          const {
            result,
            subscription
          } = superstruct.create(notification, SlotNotificationResult);
          this._handleServerNotification(subscription, [result]);
        }
        /**
         * Register a callback to be invoked upon slot changes
         *
         * @param callback Function to invoke whenever the slot changes
         * @return subscription id
         */
        onSlotChange(callback) {
          return this._makeSubscription(
            {
              callback,
              method: "slotSubscribe",
              unsubscribeMethod: "slotUnsubscribe"
            },
            []
            /* args */
          );
        }
        /**
         * Deregister a slot notification callback
         *
         * @param clientSubscriptionId client subscription id to deregister
         */
        async removeSlotChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "slot change");
        }
        /**
         * @internal
         */
        _wsOnSlotUpdatesNotification(notification) {
          const {
            result,
            subscription
          } = superstruct.create(notification, SlotUpdateNotificationResult);
          this._handleServerNotification(subscription, [result]);
        }
        /**
         * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
         * may be useful to track live progress of a cluster.
         *
         * @param callback Function to invoke whenever the slot updates
         * @return subscription id
         */
        onSlotUpdate(callback) {
          return this._makeSubscription(
            {
              callback,
              method: "slotsUpdatesSubscribe",
              unsubscribeMethod: "slotsUpdatesUnsubscribe"
            },
            []
            /* args */
          );
        }
        /**
         * Deregister a slot update notification callback
         *
         * @param clientSubscriptionId client subscription id to deregister
         */
        async removeSlotUpdateListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "slot update");
        }
        /**
         * @internal
         */
        async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
          const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
          if (dispose) {
            await dispose();
          } else {
            console.warn(`Ignored unsubscribe request because an active subscription with id \`${clientSubscriptionId}\` for '${subscriptionName}' events could not be found.`);
          }
        }
        _buildArgs(args, override, encoding, extra) {
          const commitment = override || this._commitment;
          if (commitment || encoding || extra) {
            let options = {};
            if (encoding) {
              options.encoding = encoding;
            }
            if (commitment) {
              options.commitment = commitment;
            }
            if (extra) {
              options = Object.assign(options, extra);
            }
            args.push(options);
          }
          return args;
        }
        /**
         * @internal
         */
        _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
          const commitment = override || this._commitment;
          if (commitment && !["confirmed", "finalized"].includes(commitment)) {
            throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
          }
          return this._buildArgs(args, override, encoding, extra);
        }
        /**
         * @internal
         */
        _wsOnSignatureNotification(notification) {
          const {
            result,
            subscription
          } = superstruct.create(notification, SignatureNotificationResult);
          if (result.value !== "receivedSignature") {
            this._subscriptionsAutoDisposedByRpc.add(subscription);
          }
          this._handleServerNotification(subscription, result.value === "receivedSignature" ? [{
            type: "received"
          }, result.context] : [{
            type: "status",
            result: result.value
          }, result.context]);
        }
        /**
         * Register a callback to be invoked upon signature updates
         *
         * @param signature Transaction signature string in base 58
         * @param callback Function to invoke on signature notifications
         * @param commitment Specify the commitment level signature must reach before notification
         * @return subscription id
         */
        onSignature(signature2, callback, commitment) {
          const args = this._buildArgs(
            [signature2],
            commitment || this._commitment || "finalized"
            // Apply connection/server default.
          );
          const clientSubscriptionId = this._makeSubscription({
            callback: (notification, context) => {
              if (notification.type === "status") {
                callback(notification.result, context);
                try {
                  this.removeSignatureListener(clientSubscriptionId);
                } catch (_err) {
                }
              }
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
          }, args);
          return clientSubscriptionId;
        }
        /**
         * Register a callback to be invoked when a transaction is
         * received and/or processed.
         *
         * @param signature Transaction signature string in base 58
         * @param callback Function to invoke on signature notifications
         * @param options Enable received notifications and set the commitment
         *   level that signature must reach before notification
         * @return subscription id
         */
        onSignatureWithOptions(signature2, callback, options) {
          const {
            commitment,
            ...extra
          } = {
            ...options,
            commitment: options && options.commitment || this._commitment || "finalized"
            // Apply connection/server default.
          };
          const args = this._buildArgs([signature2], commitment, void 0, extra);
          const clientSubscriptionId = this._makeSubscription({
            callback: (notification, context) => {
              callback(notification, context);
              try {
                this.removeSignatureListener(clientSubscriptionId);
              } catch (_err) {
              }
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
          }, args);
          return clientSubscriptionId;
        }
        /**
         * Deregister a signature notification callback
         *
         * @param clientSubscriptionId client subscription id to deregister
         */
        async removeSignatureListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "signature result");
        }
        /**
         * @internal
         */
        _wsOnRootNotification(notification) {
          const {
            result,
            subscription
          } = superstruct.create(notification, RootNotificationResult);
          this._handleServerNotification(subscription, [result]);
        }
        /**
         * Register a callback to be invoked upon root changes
         *
         * @param callback Function to invoke whenever the root changes
         * @return subscription id
         */
        onRootChange(callback) {
          return this._makeSubscription(
            {
              callback,
              method: "rootSubscribe",
              unsubscribeMethod: "rootUnsubscribe"
            },
            []
            /* args */
          );
        }
        /**
         * Deregister a root notification callback
         *
         * @param clientSubscriptionId client subscription id to deregister
         */
        async removeRootChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "root change");
        }
      };
      var Keypair = class _Keypair {
        /**
         * Create a new keypair instance.
         * Generate random keypair if no {@link Ed25519Keypair} is provided.
         *
         * @param {Ed25519Keypair} keypair ed25519 keypair
         */
        constructor(keypair) {
          this._keypair = void 0;
          this._keypair = keypair ?? generateKeypair();
        }
        /**
         * Generate a new random keypair
         *
         * @returns {Keypair} Keypair
         */
        static generate() {
          return new _Keypair(generateKeypair());
        }
        /**
         * Create a keypair from a raw secret key byte array.
         *
         * This method should only be used to recreate a keypair from a previously
         * generated secret key. Generating keypairs from a random seed should be done
         * with the {@link Keypair.fromSeed} method.
         *
         * @throws error if the provided secret key is invalid and validation is not skipped.
         *
         * @param secretKey secret key byte array
         * @param options skip secret key validation
         *
         * @returns {Keypair} Keypair
         */
        static fromSecretKey(secretKey, options) {
          if (secretKey.byteLength !== 64) {
            throw new Error("bad secret key size");
          }
          const publicKey4 = secretKey.slice(32, 64);
          if (!options || !options.skipValidation) {
            const privateScalar = secretKey.slice(0, 32);
            const computedPublicKey = getPublicKey(privateScalar);
            for (let ii = 0; ii < 32; ii++) {
              if (publicKey4[ii] !== computedPublicKey[ii]) {
                throw new Error("provided secretKey is invalid");
              }
            }
          }
          return new _Keypair({
            publicKey: publicKey4,
            secretKey
          });
        }
        /**
         * Generate a keypair from a 32 byte seed.
         *
         * @param seed seed byte array
         *
         * @returns {Keypair} Keypair
         */
        static fromSeed(seed2) {
          const publicKey4 = getPublicKey(seed2);
          const secretKey = new Uint8Array(64);
          secretKey.set(seed2);
          secretKey.set(publicKey4, 32);
          return new _Keypair({
            publicKey: publicKey4,
            secretKey
          });
        }
        /**
         * The public key for this keypair
         *
         * @returns {PublicKey} PublicKey
         */
        get publicKey() {
          return new PublicKey2(this._keypair.publicKey);
        }
        /**
         * The raw secret key for this keypair
         * @returns {Uint8Array} Secret key in an array of Uint8 bytes
         */
        get secretKey() {
          return new Uint8Array(this._keypair.secretKey);
        }
      };
      var LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
        CreateLookupTable: {
          index: 0,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u643("recentSlot"), BufferLayout__namespace.u8("bumpSeed")])
        },
        FreezeLookupTable: {
          index: 1,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        },
        ExtendLookupTable: {
          index: 2,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u643(), BufferLayout__namespace.seq(publicKey3(), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "addresses")])
        },
        DeactivateLookupTable: {
          index: 3,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        },
        CloseLookupTable: {
          index: 4,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        }
      });
      var AddressLookupTableInstruction = class {
        /**
         * @internal
         */
        constructor() {
        }
        static decodeInstructionType(instruction) {
          this.checkProgramId(instruction.programId);
          const instructionTypeLayout = BufferLayout__namespace.u32("instruction");
          const index2 = instructionTypeLayout.decode(instruction.data);
          let type2;
          for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)) {
            if (layout.index == index2) {
              type2 = layoutType;
              break;
            }
          }
          if (!type2) {
            throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
          }
          return type2;
        }
        static decodeCreateLookupTable(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeysLength(instruction.keys, 4);
          const {
            recentSlot
          } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);
          return {
            authority: instruction.keys[1].pubkey,
            payer: instruction.keys[2].pubkey,
            recentSlot: Number(recentSlot)
          };
        }
        static decodeExtendLookupTable(instruction) {
          this.checkProgramId(instruction.programId);
          if (instruction.keys.length < 2) {
            throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);
          }
          const {
            addresses
          } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);
          return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey,
            payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : void 0,
            addresses: addresses.map((buffer2) => new PublicKey2(buffer2))
          };
        }
        static decodeCloseLookupTable(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeysLength(instruction.keys, 3);
          return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey,
            recipient: instruction.keys[2].pubkey
          };
        }
        static decodeFreezeLookupTable(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeysLength(instruction.keys, 2);
          return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey
          };
        }
        static decodeDeactivateLookupTable(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeysLength(instruction.keys, 2);
          return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey
          };
        }
        /**
         * @internal
         */
        static checkProgramId(programId) {
          if (!programId.equals(AddressLookupTableProgram.programId)) {
            throw new Error("invalid instruction; programId is not AddressLookupTable Program");
          }
        }
        /**
         * @internal
         */
        static checkKeysLength(keys, expectedLength) {
          if (keys.length < expectedLength) {
            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
          }
        }
      };
      var AddressLookupTableProgram = class {
        /**
         * @internal
         */
        constructor() {
        }
        static createLookupTable(params) {
          const [lookupTableAddress, bumpSeed] = PublicKey2.findProgramAddressSync([params.authority.toBuffer(), bigintBuffer.toBufferLE(BigInt(params.recentSlot), 8)], this.programId);
          const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
          const data = encodeData2(type2, {
            recentSlot: BigInt(params.recentSlot),
            bumpSeed
          });
          const keys = [{
            pubkey: lookupTableAddress,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authority,
            isSigner: true,
            isWritable: false
          }, {
            pubkey: params.payer,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: SystemProgram2.programId,
            isSigner: false,
            isWritable: false
          }];
          return [new TransactionInstruction2({
            programId: this.programId,
            keys,
            data
          }), lookupTableAddress];
        }
        static freezeLookupTable(params) {
          const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
          const data = encodeData2(type2);
          const keys = [{
            pubkey: params.lookupTable,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authority,
            isSigner: true,
            isWritable: false
          }];
          return new TransactionInstruction2({
            programId: this.programId,
            keys,
            data
          });
        }
        static extendLookupTable(params) {
          const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
          const data = encodeData2(type2, {
            addresses: params.addresses.map((addr) => addr.toBytes())
          });
          const keys = [{
            pubkey: params.lookupTable,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authority,
            isSigner: true,
            isWritable: false
          }];
          if (params.payer) {
            keys.push({
              pubkey: params.payer,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: SystemProgram2.programId,
              isSigner: false,
              isWritable: false
            });
          }
          return new TransactionInstruction2({
            programId: this.programId,
            keys,
            data
          });
        }
        static deactivateLookupTable(params) {
          const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
          const data = encodeData2(type2);
          const keys = [{
            pubkey: params.lookupTable,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authority,
            isSigner: true,
            isWritable: false
          }];
          return new TransactionInstruction2({
            programId: this.programId,
            keys,
            data
          });
        }
        static closeLookupTable(params) {
          const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
          const data = encodeData2(type2);
          const keys = [{
            pubkey: params.lookupTable,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authority,
            isSigner: true,
            isWritable: false
          }, {
            pubkey: params.recipient,
            isSigner: false,
            isWritable: true
          }];
          return new TransactionInstruction2({
            programId: this.programId,
            keys,
            data
          });
        }
      };
      AddressLookupTableProgram.programId = new PublicKey2("AddressLookupTab1e1111111111111111111111111");
      var ComputeBudgetInstruction = class {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Decode a compute budget instruction and retrieve the instruction type.
         */
        static decodeInstructionType(instruction) {
          this.checkProgramId(instruction.programId);
          const instructionTypeLayout = BufferLayout__namespace.u8("instruction");
          const typeIndex = instructionTypeLayout.decode(instruction.data);
          let type2;
          for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)) {
            if (layout.index == typeIndex) {
              type2 = ixType;
              break;
            }
          }
          if (!type2) {
            throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
          }
          return type2;
        }
        /**
         * Decode request units compute budget instruction and retrieve the instruction params.
         */
        static decodeRequestUnits(instruction) {
          this.checkProgramId(instruction.programId);
          const {
            units,
            additionalFee
          } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);
          return {
            units,
            additionalFee
          };
        }
        /**
         * Decode request heap frame compute budget instruction and retrieve the instruction params.
         */
        static decodeRequestHeapFrame(instruction) {
          this.checkProgramId(instruction.programId);
          const {
            bytes
          } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);
          return {
            bytes
          };
        }
        /**
         * Decode set compute unit limit compute budget instruction and retrieve the instruction params.
         */
        static decodeSetComputeUnitLimit(instruction) {
          this.checkProgramId(instruction.programId);
          const {
            units
          } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);
          return {
            units
          };
        }
        /**
         * Decode set compute unit price compute budget instruction and retrieve the instruction params.
         */
        static decodeSetComputeUnitPrice(instruction) {
          this.checkProgramId(instruction.programId);
          const {
            microLamports
          } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);
          return {
            microLamports
          };
        }
        /**
         * @internal
         */
        static checkProgramId(programId) {
          if (!programId.equals(ComputeBudgetProgram.programId)) {
            throw new Error("invalid instruction; programId is not ComputeBudgetProgram");
          }
        }
      };
      var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
        RequestUnits: {
          index: 0,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), BufferLayout__namespace.u32("units"), BufferLayout__namespace.u32("additionalFee")])
        },
        RequestHeapFrame: {
          index: 1,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), BufferLayout__namespace.u32("bytes")])
        },
        SetComputeUnitLimit: {
          index: 2,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), BufferLayout__namespace.u32("units")])
        },
        SetComputeUnitPrice: {
          index: 3,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), u643("microLamports")])
        }
      });
      var ComputeBudgetProgram = class {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Public key that identifies the Compute Budget program
         */
        /**
         * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
         */
        static requestUnits(params) {
          const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
          const data = encodeData2(type2, params);
          return new TransactionInstruction2({
            keys: [],
            programId: this.programId,
            data
          });
        }
        static requestHeapFrame(params) {
          const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
          const data = encodeData2(type2, params);
          return new TransactionInstruction2({
            keys: [],
            programId: this.programId,
            data
          });
        }
        static setComputeUnitLimit(params) {
          const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
          const data = encodeData2(type2, params);
          return new TransactionInstruction2({
            keys: [],
            programId: this.programId,
            data
          });
        }
        static setComputeUnitPrice(params) {
          const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
          const data = encodeData2(type2, {
            microLamports: BigInt(params.microLamports)
          });
          return new TransactionInstruction2({
            keys: [],
            programId: this.programId,
            data
          });
        }
      };
      ComputeBudgetProgram.programId = new PublicKey2("ComputeBudget111111111111111111111111111111");
      var PRIVATE_KEY_BYTES$1 = 64;
      var PUBLIC_KEY_BYTES$1 = 32;
      var SIGNATURE_BYTES = 64;
      var ED25519_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([BufferLayout__namespace.u8("numSignatures"), BufferLayout__namespace.u8("padding"), BufferLayout__namespace.u16("signatureOffset"), BufferLayout__namespace.u16("signatureInstructionIndex"), BufferLayout__namespace.u16("publicKeyOffset"), BufferLayout__namespace.u16("publicKeyInstructionIndex"), BufferLayout__namespace.u16("messageDataOffset"), BufferLayout__namespace.u16("messageDataSize"), BufferLayout__namespace.u16("messageInstructionIndex")]);
      var Ed25519Program = class _Ed25519Program {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Public key that identifies the ed25519 program
         */
        /**
         * Create an ed25519 instruction with a public key and signature. The
         * public key must be a buffer that is 32 bytes long, and the signature
         * must be a buffer of 64 bytes.
         */
        static createInstructionWithPublicKey(params) {
          const {
            publicKey: publicKey4,
            message,
            signature: signature2,
            instructionIndex
          } = params;
          assert2(publicKey4.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey4.length} bytes`);
          assert2(signature2.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature2.length} bytes`);
          const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
          const signatureOffset = publicKeyOffset + publicKey4.length;
          const messageDataOffset = signatureOffset + signature2.length;
          const numSignatures = 1;
          const instructionData = buffer.Buffer.alloc(messageDataOffset + message.length);
          const index2 = instructionIndex == null ? 65535 : instructionIndex;
          ED25519_INSTRUCTION_LAYOUT.encode({
            numSignatures,
            padding: 0,
            signatureOffset,
            signatureInstructionIndex: index2,
            publicKeyOffset,
            publicKeyInstructionIndex: index2,
            messageDataOffset,
            messageDataSize: message.length,
            messageInstructionIndex: index2
          }, instructionData);
          instructionData.fill(publicKey4, publicKeyOffset);
          instructionData.fill(signature2, signatureOffset);
          instructionData.fill(message, messageDataOffset);
          return new TransactionInstruction2({
            keys: [],
            programId: _Ed25519Program.programId,
            data: instructionData
          });
        }
        /**
         * Create an ed25519 instruction with a private key. The private key
         * must be a buffer that is 64 bytes long.
         */
        static createInstructionWithPrivateKey(params) {
          const {
            privateKey,
            message,
            instructionIndex
          } = params;
          assert2(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
          try {
            const keypair = Keypair.fromSecretKey(privateKey);
            const publicKey4 = keypair.publicKey.toBytes();
            const signature2 = sign(message, keypair.secretKey);
            return this.createInstructionWithPublicKey({
              publicKey: publicKey4,
              message,
              signature: signature2,
              instructionIndex
            });
          } catch (error) {
            throw new Error(`Error creating instruction; ${error}`);
          }
        }
      };
      Ed25519Program.programId = new PublicKey2("Ed25519SigVerify111111111111111111111111111");
      var ecdsaSign = (msgHash, privKey) => {
        const signature2 = secp256k1.secp256k1.sign(msgHash, privKey);
        return [signature2.toCompactRawBytes(), signature2.recovery];
      };
      secp256k1.secp256k1.utils.isValidPrivateKey;
      var publicKeyCreate = secp256k1.secp256k1.getPublicKey;
      var PRIVATE_KEY_BYTES = 32;
      var ETHEREUM_ADDRESS_BYTES = 20;
      var PUBLIC_KEY_BYTES = 64;
      var SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
      var SECP256K1_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([BufferLayout__namespace.u8("numSignatures"), BufferLayout__namespace.u16("signatureOffset"), BufferLayout__namespace.u8("signatureInstructionIndex"), BufferLayout__namespace.u16("ethAddressOffset"), BufferLayout__namespace.u8("ethAddressInstructionIndex"), BufferLayout__namespace.u16("messageDataOffset"), BufferLayout__namespace.u16("messageDataSize"), BufferLayout__namespace.u8("messageInstructionIndex"), BufferLayout__namespace.blob(20, "ethAddress"), BufferLayout__namespace.blob(64, "signature"), BufferLayout__namespace.u8("recoveryId")]);
      var Secp256k1Program = class _Secp256k1Program {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Public key that identifies the secp256k1 program
         */
        /**
         * Construct an Ethereum address from a secp256k1 public key buffer.
         * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
         */
        static publicKeyToEthAddress(publicKey4) {
          assert2(publicKey4.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey4.length} bytes`);
          try {
            return buffer.Buffer.from(sha3.keccak_256(toBuffer(publicKey4))).slice(-ETHEREUM_ADDRESS_BYTES);
          } catch (error) {
            throw new Error(`Error constructing Ethereum address: ${error}`);
          }
        }
        /**
         * Create an secp256k1 instruction with a public key. The public key
         * must be a buffer that is 64 bytes long.
         */
        static createInstructionWithPublicKey(params) {
          const {
            publicKey: publicKey4,
            message,
            signature: signature2,
            recoveryId,
            instructionIndex
          } = params;
          return _Secp256k1Program.createInstructionWithEthAddress({
            ethAddress: _Secp256k1Program.publicKeyToEthAddress(publicKey4),
            message,
            signature: signature2,
            recoveryId,
            instructionIndex
          });
        }
        /**
         * Create an secp256k1 instruction with an Ethereum address. The address
         * must be a hex string or a buffer that is 20 bytes long.
         */
        static createInstructionWithEthAddress(params) {
          const {
            ethAddress: rawAddress,
            message,
            signature: signature2,
            recoveryId,
            instructionIndex = 0
          } = params;
          let ethAddress;
          if (typeof rawAddress === "string") {
            if (rawAddress.startsWith("0x")) {
              ethAddress = buffer.Buffer.from(rawAddress.substr(2), "hex");
            } else {
              ethAddress = buffer.Buffer.from(rawAddress, "hex");
            }
          } else {
            ethAddress = rawAddress;
          }
          assert2(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
          const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
          const ethAddressOffset = dataStart;
          const signatureOffset = dataStart + ethAddress.length;
          const messageDataOffset = signatureOffset + signature2.length + 1;
          const numSignatures = 1;
          const instructionData = buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
          SECP256K1_INSTRUCTION_LAYOUT.encode({
            numSignatures,
            signatureOffset,
            signatureInstructionIndex: instructionIndex,
            ethAddressOffset,
            ethAddressInstructionIndex: instructionIndex,
            messageDataOffset,
            messageDataSize: message.length,
            messageInstructionIndex: instructionIndex,
            signature: toBuffer(signature2),
            ethAddress: toBuffer(ethAddress),
            recoveryId
          }, instructionData);
          instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
          return new TransactionInstruction2({
            keys: [],
            programId: _Secp256k1Program.programId,
            data: instructionData
          });
        }
        /**
         * Create an secp256k1 instruction with a private key. The private key
         * must be a buffer that is 32 bytes long.
         */
        static createInstructionWithPrivateKey(params) {
          const {
            privateKey: pkey,
            message,
            instructionIndex
          } = params;
          assert2(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
          try {
            const privateKey = toBuffer(pkey);
            const publicKey4 = publicKeyCreate(
              privateKey,
              false
              /* isCompressed */
            ).slice(1);
            const messageHash = buffer.Buffer.from(sha3.keccak_256(toBuffer(message)));
            const [signature2, recoveryId] = ecdsaSign(messageHash, privateKey);
            return this.createInstructionWithPublicKey({
              publicKey: publicKey4,
              message,
              signature: signature2,
              recoveryId,
              instructionIndex
            });
          } catch (error) {
            throw new Error(`Error creating instruction; ${error}`);
          }
        }
      };
      Secp256k1Program.programId = new PublicKey2("KeccakSecp256k11111111111111111111111111111");
      var _Lockup;
      var STAKE_CONFIG_ID = new PublicKey2("StakeConfig11111111111111111111111111111111");
      var Authorized = class {
        /**
         * Create a new Authorized object
         * @param staker the stake authority
         * @param withdrawer the withdraw authority
         */
        constructor(staker, withdrawer) {
          this.staker = void 0;
          this.withdrawer = void 0;
          this.staker = staker;
          this.withdrawer = withdrawer;
        }
      };
      var Lockup = class {
        /**
         * Create a new Lockup object
         */
        constructor(unixTimestamp, epoch, custodian) {
          this.unixTimestamp = void 0;
          this.epoch = void 0;
          this.custodian = void 0;
          this.unixTimestamp = unixTimestamp;
          this.epoch = epoch;
          this.custodian = custodian;
        }
        /**
         * Default, inactive Lockup value
         */
      };
      _Lockup = Lockup;
      Lockup.default = new _Lockup(0, 0, PublicKey2.default);
      var StakeInstruction = class {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Decode a stake instruction and retrieve the instruction type.
         */
        static decodeInstructionType(instruction) {
          this.checkProgramId(instruction.programId);
          const instructionTypeLayout = BufferLayout__namespace.u32("instruction");
          const typeIndex = instructionTypeLayout.decode(instruction.data);
          let type2;
          for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)) {
            if (layout.index == typeIndex) {
              type2 = ixType;
              break;
            }
          }
          if (!type2) {
            throw new Error("Instruction type incorrect; not a StakeInstruction");
          }
          return type2;
        }
        /**
         * Decode a initialize stake instruction and retrieve the instruction params.
         */
        static decodeInitialize(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            authorized: authorized2,
            lockup: lockup2
          } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);
          return {
            stakePubkey: instruction.keys[0].pubkey,
            authorized: new Authorized(new PublicKey2(authorized2.staker), new PublicKey2(authorized2.withdrawer)),
            lockup: new Lockup(lockup2.unixTimestamp, lockup2.epoch, new PublicKey2(lockup2.custodian))
          };
        }
        /**
         * Decode a delegate stake instruction and retrieve the instruction params.
         */
        static decodeDelegate(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 6);
          decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
          return {
            stakePubkey: instruction.keys[0].pubkey,
            votePubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[5].pubkey
          };
        }
        /**
         * Decode an authorize stake instruction and retrieve the instruction params.
         */
        static decodeAuthorize(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            newAuthorized,
            stakeAuthorizationType
          } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
          const o = {
            stakePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey,
            newAuthorizedPubkey: new PublicKey2(newAuthorized),
            stakeAuthorizationType: {
              index: stakeAuthorizationType
            }
          };
          if (instruction.keys.length > 3) {
            o.custodianPubkey = instruction.keys[3].pubkey;
          }
          return o;
        }
        /**
         * Decode an authorize-with-seed stake instruction and retrieve the instruction params.
         */
        static decodeAuthorizeWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            newAuthorized,
            stakeAuthorizationType,
            authoritySeed,
            authorityOwner
          } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
          const o = {
            stakePubkey: instruction.keys[0].pubkey,
            authorityBase: instruction.keys[1].pubkey,
            authoritySeed,
            authorityOwner: new PublicKey2(authorityOwner),
            newAuthorizedPubkey: new PublicKey2(newAuthorized),
            stakeAuthorizationType: {
              index: stakeAuthorizationType
            }
          };
          if (instruction.keys.length > 3) {
            o.custodianPubkey = instruction.keys[3].pubkey;
          }
          return o;
        }
        /**
         * Decode a split stake instruction and retrieve the instruction params.
         */
        static decodeSplit(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            lamports
          } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);
          return {
            stakePubkey: instruction.keys[0].pubkey,
            splitStakePubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey,
            lamports
          };
        }
        /**
         * Decode a merge stake instruction and retrieve the instruction params.
         */
        static decodeMerge(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);
          return {
            stakePubkey: instruction.keys[0].pubkey,
            sourceStakePubKey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[4].pubkey
          };
        }
        /**
         * Decode a withdraw stake instruction and retrieve the instruction params.
         */
        static decodeWithdraw(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 5);
          const {
            lamports
          } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
          const o = {
            stakePubkey: instruction.keys[0].pubkey,
            toPubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[4].pubkey,
            lamports
          };
          if (instruction.keys.length > 5) {
            o.custodianPubkey = instruction.keys[5].pubkey;
          }
          return o;
        }
        /**
         * Decode a deactivate stake instruction and retrieve the instruction params.
         */
        static decodeDeactivate(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
          return {
            stakePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey
          };
        }
        /**
         * @internal
         */
        static checkProgramId(programId) {
          if (!programId.equals(StakeProgram.programId)) {
            throw new Error("invalid instruction; programId is not StakeProgram");
          }
        }
        /**
         * @internal
         */
        static checkKeyLength(keys, expectedLength) {
          if (keys.length < expectedLength) {
            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
          }
        }
      };
      var STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
        Initialize: {
          index: 0,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), authorized(), lockup()])
        },
        Authorize: {
          index: 1,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("newAuthorized"), BufferLayout__namespace.u32("stakeAuthorizationType")])
        },
        Delegate: {
          index: 2,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        },
        Split: {
          index: 3,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
        },
        Withdraw: {
          index: 4,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
        },
        Deactivate: {
          index: 5,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        },
        Merge: {
          index: 7,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        },
        AuthorizeWithSeed: {
          index: 8,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("newAuthorized"), BufferLayout__namespace.u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey3("authorityOwner")])
        }
      });
      var StakeAuthorizationLayout = Object.freeze({
        Staker: {
          index: 0
        },
        Withdrawer: {
          index: 1
        }
      });
      var StakeProgram = class {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Public key that identifies the Stake program
         */
        /**
         * Generate an Initialize instruction to add to a Stake Create transaction
         */
        static initialize(params) {
          const {
            stakePubkey,
            authorized: authorized2,
            lockup: maybeLockup
          } = params;
          const lockup2 = maybeLockup || Lockup.default;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.Initialize;
          const data = encodeData2(type2, {
            authorized: {
              staker: toBuffer(authorized2.staker.toBuffer()),
              withdrawer: toBuffer(authorized2.withdrawer.toBuffer())
            },
            lockup: {
              unixTimestamp: lockup2.unixTimestamp,
              epoch: lockup2.epoch,
              custodian: toBuffer(lockup2.custodian.toBuffer())
            }
          });
          const instructionData = {
            keys: [{
              pubkey: stakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }],
            programId: this.programId,
            data
          };
          return new TransactionInstruction2(instructionData);
        }
        /**
         * Generate a Transaction that creates a new Stake account at
         *   an address generated with `from`, a seed, and the Stake programId
         */
        static createAccountWithSeed(params) {
          const transaction = new Transaction2();
          transaction.add(SystemProgram2.createAccountWithSeed({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.stakePubkey,
            basePubkey: params.basePubkey,
            seed: params.seed,
            lamports: params.lamports,
            space: this.space,
            programId: this.programId
          }));
          const {
            stakePubkey,
            authorized: authorized2,
            lockup: lockup2
          } = params;
          return transaction.add(this.initialize({
            stakePubkey,
            authorized: authorized2,
            lockup: lockup2
          }));
        }
        /**
         * Generate a Transaction that creates a new Stake account
         */
        static createAccount(params) {
          const transaction = new Transaction2();
          transaction.add(SystemProgram2.createAccount({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.stakePubkey,
            lamports: params.lamports,
            space: this.space,
            programId: this.programId
          }));
          const {
            stakePubkey,
            authorized: authorized2,
            lockup: lockup2
          } = params;
          return transaction.add(this.initialize({
            stakePubkey,
            authorized: authorized2,
            lockup: lockup2
          }));
        }
        /**
         * Generate a Transaction that delegates Stake tokens to a validator
         * Vote PublicKey. This transaction can also be used to redelegate Stake
         * to a new validator Vote PublicKey.
         */
        static delegate(params) {
          const {
            stakePubkey,
            authorizedPubkey,
            votePubkey
          } = params;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.Delegate;
          const data = encodeData2(type2);
          return new Transaction2().add({
            keys: [{
              pubkey: stakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: votePubkey,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_CLOCK_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: STAKE_CONFIG_ID,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a Transaction that authorizes a new PublicKey as Staker
         * or Withdrawer on the Stake account.
         */
        static authorize(params) {
          const {
            stakePubkey,
            authorizedPubkey,
            newAuthorizedPubkey,
            stakeAuthorizationType,
            custodianPubkey
          } = params;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.Authorize;
          const data = encodeData2(type2, {
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            stakeAuthorizationType: stakeAuthorizationType.index
          });
          const keys = [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }];
          if (custodianPubkey) {
            keys.push({
              pubkey: custodianPubkey,
              isSigner: true,
              isWritable: false
            });
          }
          return new Transaction2().add({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a Transaction that authorizes a new PublicKey as Staker
         * or Withdrawer on the Stake account.
         */
        static authorizeWithSeed(params) {
          const {
            stakePubkey,
            authorityBase,
            authoritySeed,
            authorityOwner,
            newAuthorizedPubkey,
            stakeAuthorizationType,
            custodianPubkey
          } = params;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
          const data = encodeData2(type2, {
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            stakeAuthorizationType: stakeAuthorizationType.index,
            authoritySeed,
            authorityOwner: toBuffer(authorityOwner.toBuffer())
          });
          const keys = [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: authorityBase,
            isSigner: true,
            isWritable: false
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }];
          if (custodianPubkey) {
            keys.push({
              pubkey: custodianPubkey,
              isSigner: true,
              isWritable: false
            });
          }
          return new Transaction2().add({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * @internal
         */
        static splitInstruction(params) {
          const {
            stakePubkey,
            authorizedPubkey,
            splitStakePubkey,
            lamports
          } = params;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.Split;
          const data = encodeData2(type2, {
            lamports
          });
          return new TransactionInstruction2({
            keys: [{
              pubkey: stakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: splitStakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a Transaction that splits Stake tokens into another stake account
         */
        static split(params, rentExemptReserve) {
          const transaction = new Transaction2();
          transaction.add(SystemProgram2.createAccount({
            fromPubkey: params.authorizedPubkey,
            newAccountPubkey: params.splitStakePubkey,
            lamports: rentExemptReserve,
            space: this.space,
            programId: this.programId
          }));
          return transaction.add(this.splitInstruction(params));
        }
        /**
         * Generate a Transaction that splits Stake tokens into another account
         * derived from a base public key and seed
         */
        static splitWithSeed(params, rentExemptReserve) {
          const {
            stakePubkey,
            authorizedPubkey,
            splitStakePubkey,
            basePubkey,
            seed: seed2,
            lamports
          } = params;
          const transaction = new Transaction2();
          transaction.add(SystemProgram2.allocate({
            accountPubkey: splitStakePubkey,
            basePubkey,
            seed: seed2,
            space: this.space,
            programId: this.programId
          }));
          if (rentExemptReserve && rentExemptReserve > 0) {
            transaction.add(SystemProgram2.transfer({
              fromPubkey: params.authorizedPubkey,
              toPubkey: splitStakePubkey,
              lamports: rentExemptReserve
            }));
          }
          return transaction.add(this.splitInstruction({
            stakePubkey,
            authorizedPubkey,
            splitStakePubkey,
            lamports
          }));
        }
        /**
         * Generate a Transaction that merges Stake accounts.
         */
        static merge(params) {
          const {
            stakePubkey,
            sourceStakePubKey,
            authorizedPubkey
          } = params;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.Merge;
          const data = encodeData2(type2);
          return new Transaction2().add({
            keys: [{
              pubkey: stakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: sourceStakePubKey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_CLOCK_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a Transaction that withdraws deactivated Stake tokens.
         */
        static withdraw(params) {
          const {
            stakePubkey,
            authorizedPubkey,
            toPubkey,
            lamports,
            custodianPubkey
          } = params;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
          const data = encodeData2(type2, {
            lamports
          });
          const keys = [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: toPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }];
          if (custodianPubkey) {
            keys.push({
              pubkey: custodianPubkey,
              isSigner: true,
              isWritable: false
            });
          }
          return new Transaction2().add({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a Transaction that deactivates Stake tokens.
         */
        static deactivate(params) {
          const {
            stakePubkey,
            authorizedPubkey
          } = params;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
          const data = encodeData2(type2);
          return new Transaction2().add({
            keys: [{
              pubkey: stakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_CLOCK_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
      };
      StakeProgram.programId = new PublicKey2("Stake11111111111111111111111111111111111111");
      StakeProgram.space = 200;
      var VoteInit = class {
        /** [0, 100] */
        constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {
          this.nodePubkey = void 0;
          this.authorizedVoter = void 0;
          this.authorizedWithdrawer = void 0;
          this.commission = void 0;
          this.nodePubkey = nodePubkey;
          this.authorizedVoter = authorizedVoter;
          this.authorizedWithdrawer = authorizedWithdrawer;
          this.commission = commission;
        }
      };
      var VoteInstruction = class {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Decode a vote instruction and retrieve the instruction type.
         */
        static decodeInstructionType(instruction) {
          this.checkProgramId(instruction.programId);
          const instructionTypeLayout = BufferLayout__namespace.u32("instruction");
          const typeIndex = instructionTypeLayout.decode(instruction.data);
          let type2;
          for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)) {
            if (layout.index == typeIndex) {
              type2 = ixType;
              break;
            }
          }
          if (!type2) {
            throw new Error("Instruction type incorrect; not a VoteInstruction");
          }
          return type2;
        }
        /**
         * Decode an initialize vote instruction and retrieve the instruction params.
         */
        static decodeInitializeAccount(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 4);
          const {
            voteInit: voteInit2
          } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);
          return {
            votePubkey: instruction.keys[0].pubkey,
            nodePubkey: instruction.keys[3].pubkey,
            voteInit: new VoteInit(new PublicKey2(voteInit2.nodePubkey), new PublicKey2(voteInit2.authorizedVoter), new PublicKey2(voteInit2.authorizedWithdrawer), voteInit2.commission)
          };
        }
        /**
         * Decode an authorize instruction and retrieve the instruction params.
         */
        static decodeAuthorize(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            newAuthorized,
            voteAuthorizationType
          } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
          return {
            votePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey,
            newAuthorizedPubkey: new PublicKey2(newAuthorized),
            voteAuthorizationType: {
              index: voteAuthorizationType
            }
          };
        }
        /**
         * Decode an authorize instruction and retrieve the instruction params.
         */
        static decodeAuthorizeWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            voteAuthorizeWithSeedArgs: {
              currentAuthorityDerivedKeyOwnerPubkey,
              currentAuthorityDerivedKeySeed,
              newAuthorized,
              voteAuthorizationType
            }
          } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
          return {
            currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,
            currentAuthorityDerivedKeyOwnerPubkey: new PublicKey2(currentAuthorityDerivedKeyOwnerPubkey),
            currentAuthorityDerivedKeySeed,
            newAuthorizedPubkey: new PublicKey2(newAuthorized),
            voteAuthorizationType: {
              index: voteAuthorizationType
            },
            votePubkey: instruction.keys[0].pubkey
          };
        }
        /**
         * Decode a withdraw instruction and retrieve the instruction params.
         */
        static decodeWithdraw(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            lamports
          } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
          return {
            votePubkey: instruction.keys[0].pubkey,
            authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
            lamports,
            toPubkey: instruction.keys[1].pubkey
          };
        }
        /**
         * @internal
         */
        static checkProgramId(programId) {
          if (!programId.equals(VoteProgram.programId)) {
            throw new Error("invalid instruction; programId is not VoteProgram");
          }
        }
        /**
         * @internal
         */
        static checkKeyLength(keys, expectedLength) {
          if (keys.length < expectedLength) {
            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
          }
        }
      };
      var VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
        InitializeAccount: {
          index: 0,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), voteInit()])
        },
        Authorize: {
          index: 1,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("newAuthorized"), BufferLayout__namespace.u32("voteAuthorizationType")])
        },
        Withdraw: {
          index: 3,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
        },
        UpdateValidatorIdentity: {
          index: 4,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        },
        AuthorizeWithSeed: {
          index: 10,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), voteAuthorizeWithSeedArgs()])
        }
      });
      var VoteAuthorizationLayout = Object.freeze({
        Voter: {
          index: 0
        },
        Withdrawer: {
          index: 1
        }
      });
      var VoteProgram = class _VoteProgram {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Public key that identifies the Vote program
         */
        /**
         * Generate an Initialize instruction.
         */
        static initializeAccount(params) {
          const {
            votePubkey,
            nodePubkey,
            voteInit: voteInit2
          } = params;
          const type2 = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
          const data = encodeData2(type2, {
            voteInit: {
              nodePubkey: toBuffer(voteInit2.nodePubkey.toBuffer()),
              authorizedVoter: toBuffer(voteInit2.authorizedVoter.toBuffer()),
              authorizedWithdrawer: toBuffer(voteInit2.authorizedWithdrawer.toBuffer()),
              commission: voteInit2.commission
            }
          });
          const instructionData = {
            keys: [{
              pubkey: votePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_CLOCK_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: nodePubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          };
          return new TransactionInstruction2(instructionData);
        }
        /**
         * Generate a transaction that creates a new Vote account.
         */
        static createAccount(params) {
          const transaction = new Transaction2();
          transaction.add(SystemProgram2.createAccount({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.votePubkey,
            lamports: params.lamports,
            space: this.space,
            programId: this.programId
          }));
          return transaction.add(this.initializeAccount({
            votePubkey: params.votePubkey,
            nodePubkey: params.voteInit.nodePubkey,
            voteInit: params.voteInit
          }));
        }
        /**
         * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
         */
        static authorize(params) {
          const {
            votePubkey,
            authorizedPubkey,
            newAuthorizedPubkey,
            voteAuthorizationType
          } = params;
          const type2 = VOTE_INSTRUCTION_LAYOUTS.Authorize;
          const data = encodeData2(type2, {
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            voteAuthorizationType: voteAuthorizationType.index
          });
          const keys = [{
            pubkey: votePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }];
          return new Transaction2().add({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
         * where the current Voter or Withdrawer authority is a derived key.
         */
        static authorizeWithSeed(params) {
          const {
            currentAuthorityDerivedKeyBasePubkey,
            currentAuthorityDerivedKeyOwnerPubkey,
            currentAuthorityDerivedKeySeed,
            newAuthorizedPubkey,
            voteAuthorizationType,
            votePubkey
          } = params;
          const type2 = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
          const data = encodeData2(type2, {
            voteAuthorizeWithSeedArgs: {
              currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
              currentAuthorityDerivedKeySeed,
              newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
              voteAuthorizationType: voteAuthorizationType.index
            }
          });
          const keys = [{
            pubkey: votePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: currentAuthorityDerivedKeyBasePubkey,
            isSigner: true,
            isWritable: false
          }];
          return new Transaction2().add({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction to withdraw from a Vote account.
         */
        static withdraw(params) {
          const {
            votePubkey,
            authorizedWithdrawerPubkey,
            lamports,
            toPubkey
          } = params;
          const type2 = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
          const data = encodeData2(type2, {
            lamports
          });
          const keys = [{
            pubkey: votePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: toPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: authorizedWithdrawerPubkey,
            isSigner: true,
            isWritable: false
          }];
          return new Transaction2().add({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction to withdraw safely from a Vote account.
         *
         * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
         * checks that the withdraw amount will not exceed the specified balance while leaving enough left
         * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
         * `withdraw` method directly.
         */
        static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
          if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
            throw new Error("Withdraw will leave vote account with insufficient funds.");
          }
          return _VoteProgram.withdraw(params);
        }
        /**
         * Generate a transaction to update the validator identity (node pubkey) of a Vote account.
         */
        static updateValidatorIdentity(params) {
          const {
            votePubkey,
            authorizedWithdrawerPubkey,
            nodePubkey
          } = params;
          const type2 = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;
          const data = encodeData2(type2);
          const keys = [{
            pubkey: votePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: nodePubkey,
            isSigner: true,
            isWritable: false
          }, {
            pubkey: authorizedWithdrawerPubkey,
            isSigner: true,
            isWritable: false
          }];
          return new Transaction2().add({
            keys,
            programId: this.programId,
            data
          });
        }
      };
      VoteProgram.programId = new PublicKey2("Vote111111111111111111111111111111111111111");
      VoteProgram.space = 3762;
      var VALIDATOR_INFO_KEY = new PublicKey2("Va1idator1nfo111111111111111111111111111111");
      var InfoString = superstruct.type({
        name: superstruct.string(),
        website: superstruct.optional(superstruct.string()),
        details: superstruct.optional(superstruct.string()),
        iconUrl: superstruct.optional(superstruct.string()),
        keybaseUsername: superstruct.optional(superstruct.string())
      });
      var ValidatorInfo = class _ValidatorInfo {
        /**
         * Construct a valid ValidatorInfo
         *
         * @param key validator public key
         * @param info validator information
         */
        constructor(key, info) {
          this.key = void 0;
          this.info = void 0;
          this.key = key;
          this.info = info;
        }
        /**
         * Deserialize ValidatorInfo from the config account data. Exactly two config
         * keys are required in the data.
         *
         * @param buffer config account data
         * @return null if info was not found
         */
        static fromConfigData(buffer$1) {
          let byteArray = [...buffer$1];
          const configKeyCount = decodeLength(byteArray);
          if (configKeyCount !== 2) return null;
          const configKeys = [];
          for (let i = 0; i < 2; i++) {
            const publicKey4 = new PublicKey2(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
            const isSigner = guardedShift(byteArray) === 1;
            configKeys.push({
              publicKey: publicKey4,
              isSigner
            });
          }
          if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
            if (configKeys[1].isSigner) {
              const rawInfo = rustString().decode(buffer.Buffer.from(byteArray));
              const info = JSON.parse(rawInfo);
              superstruct.assert(info, InfoString);
              return new _ValidatorInfo(configKeys[1].publicKey, info);
            }
          }
          return null;
        }
      };
      var VOTE_PROGRAM_ID = new PublicKey2("Vote111111111111111111111111111111111111111");
      var VoteAccountLayout = BufferLayout__namespace.struct([
        publicKey3("nodePubkey"),
        publicKey3("authorizedWithdrawer"),
        BufferLayout__namespace.u8("commission"),
        BufferLayout__namespace.nu64(),
        // votes.length
        BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64("slot"), BufferLayout__namespace.u32("confirmationCount")]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "votes"),
        BufferLayout__namespace.u8("rootSlotValid"),
        BufferLayout__namespace.nu64("rootSlot"),
        BufferLayout__namespace.nu64(),
        // authorizedVoters.length
        BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64("epoch"), publicKey3("authorizedVoter")]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "authorizedVoters"),
        BufferLayout__namespace.struct([BufferLayout__namespace.seq(BufferLayout__namespace.struct([publicKey3("authorizedPubkey"), BufferLayout__namespace.nu64("epochOfLastAuthorizedSwitch"), BufferLayout__namespace.nu64("targetEpoch")]), 32, "buf"), BufferLayout__namespace.nu64("idx"), BufferLayout__namespace.u8("isEmpty")], "priorVoters"),
        BufferLayout__namespace.nu64(),
        // epochCredits.length
        BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64("epoch"), BufferLayout__namespace.nu64("credits"), BufferLayout__namespace.nu64("prevCredits")]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "epochCredits"),
        BufferLayout__namespace.struct([BufferLayout__namespace.nu64("slot"), BufferLayout__namespace.nu64("timestamp")], "lastTimestamp")
      ]);
      var VoteAccount = class _VoteAccount {
        /**
         * @internal
         */
        constructor(args) {
          this.nodePubkey = void 0;
          this.authorizedWithdrawer = void 0;
          this.commission = void 0;
          this.rootSlot = void 0;
          this.votes = void 0;
          this.authorizedVoters = void 0;
          this.priorVoters = void 0;
          this.epochCredits = void 0;
          this.lastTimestamp = void 0;
          this.nodePubkey = args.nodePubkey;
          this.authorizedWithdrawer = args.authorizedWithdrawer;
          this.commission = args.commission;
          this.rootSlot = args.rootSlot;
          this.votes = args.votes;
          this.authorizedVoters = args.authorizedVoters;
          this.priorVoters = args.priorVoters;
          this.epochCredits = args.epochCredits;
          this.lastTimestamp = args.lastTimestamp;
        }
        /**
         * Deserialize VoteAccount from the account data.
         *
         * @param buffer account data
         * @return VoteAccount
         */
        static fromAccountData(buffer2) {
          const versionOffset = 4;
          const va = VoteAccountLayout.decode(toBuffer(buffer2), versionOffset);
          let rootSlot = va.rootSlot;
          if (!va.rootSlotValid) {
            rootSlot = null;
          }
          return new _VoteAccount({
            nodePubkey: new PublicKey2(va.nodePubkey),
            authorizedWithdrawer: new PublicKey2(va.authorizedWithdrawer),
            commission: va.commission,
            votes: va.votes,
            rootSlot,
            authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
            priorVoters: getPriorVoters(va.priorVoters),
            epochCredits: va.epochCredits,
            lastTimestamp: va.lastTimestamp
          });
        }
      };
      function parseAuthorizedVoter({
        authorizedVoter,
        epoch
      }) {
        return {
          epoch,
          authorizedVoter: new PublicKey2(authorizedVoter)
        };
      }
      function parsePriorVoters({
        authorizedPubkey,
        epochOfLastAuthorizedSwitch,
        targetEpoch
      }) {
        return {
          authorizedPubkey: new PublicKey2(authorizedPubkey),
          epochOfLastAuthorizedSwitch,
          targetEpoch
        };
      }
      function getPriorVoters({
        buf,
        idx,
        isEmpty
      }) {
        if (isEmpty) {
          return [];
        }
        return [...buf.slice(idx + 1).map(parsePriorVoters), ...buf.slice(0, idx).map(parsePriorVoters)];
      }
      var endpoint = {
        http: {
          devnet: "http://api.devnet.solana.com",
          testnet: "http://api.testnet.solana.com",
          "mainnet-beta": "http://api.mainnet-beta.solana.com/"
        },
        https: {
          devnet: "https://api.devnet.solana.com",
          testnet: "https://api.testnet.solana.com",
          "mainnet-beta": "https://api.mainnet-beta.solana.com/"
        }
      };
      function clusterApiUrl(cluster, tls) {
        const key = tls === false ? "http" : "https";
        if (!cluster) {
          return endpoint[key]["devnet"];
        }
        const url = endpoint[key][cluster];
        if (!url) {
          throw new Error(`Unknown ${key} cluster: ${cluster}`);
        }
        return url;
      }
      async function sendAndConfirmRawTransaction2(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {
        let confirmationStrategy;
        let options;
        if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "lastValidBlockHeight")) {
          confirmationStrategy = confirmationStrategyOrConfirmOptions;
          options = maybeConfirmOptions;
        } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "nonceValue")) {
          confirmationStrategy = confirmationStrategyOrConfirmOptions;
          options = maybeConfirmOptions;
        } else {
          options = confirmationStrategyOrConfirmOptions;
        }
        const sendOptions = options && {
          skipPreflight: options.skipPreflight,
          preflightCommitment: options.preflightCommitment || options.commitment,
          minContextSlot: options.minContextSlot
        };
        const signature2 = await connection.sendRawTransaction(rawTransaction, sendOptions);
        const commitment = options && options.commitment;
        const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature2, commitment);
        const status = (await confirmationPromise).value;
        if (status.err) {
          if (signature2 != null) {
            throw new SendTransactionError2({
              action: sendOptions?.skipPreflight ? "send" : "simulate",
              signature: signature2,
              transactionMessage: `Status: (${JSON.stringify(status)})`
            });
          }
          throw new Error(`Raw transaction ${signature2} failed (${JSON.stringify(status)})`);
        }
        return signature2;
      }
      var LAMPORTS_PER_SOL = 1e9;
      exports.Account = Account;
      exports.AddressLookupTableAccount = AddressLookupTableAccount;
      exports.AddressLookupTableInstruction = AddressLookupTableInstruction;
      exports.AddressLookupTableProgram = AddressLookupTableProgram;
      exports.Authorized = Authorized;
      exports.BLOCKHASH_CACHE_TIMEOUT_MS = BLOCKHASH_CACHE_TIMEOUT_MS;
      exports.BPF_LOADER_DEPRECATED_PROGRAM_ID = BPF_LOADER_DEPRECATED_PROGRAM_ID;
      exports.BPF_LOADER_PROGRAM_ID = BPF_LOADER_PROGRAM_ID;
      exports.BpfLoader = BpfLoader;
      exports.COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS;
      exports.ComputeBudgetInstruction = ComputeBudgetInstruction;
      exports.ComputeBudgetProgram = ComputeBudgetProgram;
      exports.Connection = Connection;
      exports.Ed25519Program = Ed25519Program;
      exports.Enum = Enum;
      exports.EpochSchedule = EpochSchedule;
      exports.FeeCalculatorLayout = FeeCalculatorLayout;
      exports.Keypair = Keypair;
      exports.LAMPORTS_PER_SOL = LAMPORTS_PER_SOL;
      exports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS = LOOKUP_TABLE_INSTRUCTION_LAYOUTS;
      exports.Loader = Loader;
      exports.Lockup = Lockup;
      exports.MAX_SEED_LENGTH = MAX_SEED_LENGTH;
      exports.Message = Message;
      exports.MessageAccountKeys = MessageAccountKeys;
      exports.MessageV0 = MessageV0;
      exports.NONCE_ACCOUNT_LENGTH = NONCE_ACCOUNT_LENGTH2;
      exports.NonceAccount = NonceAccount;
      exports.PACKET_DATA_SIZE = PACKET_DATA_SIZE;
      exports.PUBLIC_KEY_LENGTH = PUBLIC_KEY_LENGTH;
      exports.PublicKey = PublicKey2;
      exports.SIGNATURE_LENGTH_IN_BYTES = SIGNATURE_LENGTH_IN_BYTES;
      exports.SOLANA_SCHEMA = SOLANA_SCHEMA;
      exports.STAKE_CONFIG_ID = STAKE_CONFIG_ID;
      exports.STAKE_INSTRUCTION_LAYOUTS = STAKE_INSTRUCTION_LAYOUTS;
      exports.SYSTEM_INSTRUCTION_LAYOUTS = SYSTEM_INSTRUCTION_LAYOUTS;
      exports.SYSVAR_CLOCK_PUBKEY = SYSVAR_CLOCK_PUBKEY;
      exports.SYSVAR_EPOCH_SCHEDULE_PUBKEY = SYSVAR_EPOCH_SCHEDULE_PUBKEY;
      exports.SYSVAR_INSTRUCTIONS_PUBKEY = SYSVAR_INSTRUCTIONS_PUBKEY;
      exports.SYSVAR_RECENT_BLOCKHASHES_PUBKEY = SYSVAR_RECENT_BLOCKHASHES_PUBKEY;
      exports.SYSVAR_RENT_PUBKEY = SYSVAR_RENT_PUBKEY;
      exports.SYSVAR_REWARDS_PUBKEY = SYSVAR_REWARDS_PUBKEY;
      exports.SYSVAR_SLOT_HASHES_PUBKEY = SYSVAR_SLOT_HASHES_PUBKEY;
      exports.SYSVAR_SLOT_HISTORY_PUBKEY = SYSVAR_SLOT_HISTORY_PUBKEY;
      exports.SYSVAR_STAKE_HISTORY_PUBKEY = SYSVAR_STAKE_HISTORY_PUBKEY;
      exports.Secp256k1Program = Secp256k1Program;
      exports.SendTransactionError = SendTransactionError2;
      exports.SolanaJSONRPCError = SolanaJSONRPCError;
      exports.SolanaJSONRPCErrorCode = SolanaJSONRPCErrorCode;
      exports.StakeAuthorizationLayout = StakeAuthorizationLayout;
      exports.StakeInstruction = StakeInstruction;
      exports.StakeProgram = StakeProgram;
      exports.Struct = Struct2;
      exports.SystemInstruction = SystemInstruction;
      exports.SystemProgram = SystemProgram2;
      exports.Transaction = Transaction2;
      exports.TransactionExpiredBlockheightExceededError = TransactionExpiredBlockheightExceededError;
      exports.TransactionExpiredNonceInvalidError = TransactionExpiredNonceInvalidError;
      exports.TransactionExpiredTimeoutError = TransactionExpiredTimeoutError;
      exports.TransactionInstruction = TransactionInstruction2;
      exports.TransactionMessage = TransactionMessage;
      exports.TransactionStatus = TransactionStatus;
      exports.VALIDATOR_INFO_KEY = VALIDATOR_INFO_KEY;
      exports.VERSION_PREFIX_MASK = VERSION_PREFIX_MASK;
      exports.VOTE_PROGRAM_ID = VOTE_PROGRAM_ID;
      exports.ValidatorInfo = ValidatorInfo;
      exports.VersionedMessage = VersionedMessage;
      exports.VersionedTransaction = VersionedTransaction;
      exports.VoteAccount = VoteAccount;
      exports.VoteAuthorizationLayout = VoteAuthorizationLayout;
      exports.VoteInit = VoteInit;
      exports.VoteInstruction = VoteInstruction;
      exports.VoteProgram = VoteProgram;
      exports.clusterApiUrl = clusterApiUrl;
      exports.sendAndConfirmRawTransaction = sendAndConfirmRawTransaction2;
      exports.sendAndConfirmTransaction = sendAndConfirmTransaction;
    }
  });

  // node_modules/camelcase/index.js
  var require_camelcase = __commonJS({
    "node_modules/camelcase/index.js"(exports, module) {
      "use strict";
      var UPPERCASE = /[\p{Lu}]/u;
      var LOWERCASE = /[\p{Ll}]/u;
      var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
      var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
      var SEPARATORS = /[_.\- ]+/;
      var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
      var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
      var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
      var preserveCamelCase = (string2, toLowerCase, toUpperCase) => {
        let isLastCharLower = false;
        let isLastCharUpper = false;
        let isLastLastCharUpper = false;
        for (let i = 0; i < string2.length; i++) {
          const character = string2[i];
          if (isLastCharLower && UPPERCASE.test(character)) {
            string2 = string2.slice(0, i) + "-" + string2.slice(i);
            isLastCharLower = false;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = true;
            i++;
          } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
            string2 = string2.slice(0, i - 1) + "-" + string2.slice(i - 1);
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = false;
            isLastCharLower = true;
          } else {
            isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
          }
        }
        return string2;
      };
      var preserveConsecutiveUppercase = (input, toLowerCase) => {
        LEADING_CAPITAL.lastIndex = 0;
        return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
      };
      var postProcess = (input, toUpperCase) => {
        SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
        NUMBERS_AND_IDENTIFIER.lastIndex = 0;
        return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
      };
      var camelCase2 = (input, options) => {
        if (!(typeof input === "string" || Array.isArray(input))) {
          throw new TypeError("Expected the input to be `string | string[]`");
        }
        options = {
          pascalCase: false,
          preserveConsecutiveUppercase: false,
          ...options
        };
        if (Array.isArray(input)) {
          input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
        } else {
          input = input.trim();
        }
        if (input.length === 0) {
          return "";
        }
        const toLowerCase = options.locale === false ? (string2) => string2.toLowerCase() : (string2) => string2.toLocaleLowerCase(options.locale);
        const toUpperCase = options.locale === false ? (string2) => string2.toUpperCase() : (string2) => string2.toLocaleUpperCase(options.locale);
        if (input.length === 1) {
          return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
        }
        const hasUpperCase = input !== toLowerCase(input);
        if (hasUpperCase) {
          input = preserveCamelCase(input, toLowerCase, toUpperCase);
        }
        input = input.replace(LEADING_SEPARATORS, "");
        if (options.preserveConsecutiveUppercase) {
          input = preserveConsecutiveUppercase(input, toLowerCase);
        } else {
          input = toLowerCase(input);
        }
        if (options.pascalCase) {
          input = toUpperCase(input.charAt(0)) + input.slice(1);
        }
        return postProcess(input, toUpperCase);
      };
      module.exports = camelCase2;
      module.exports.default = camelCase2;
    }
  });

  // node_modules/buffer-layout/lib/Layout.js
  var require_Layout2 = __commonJS({
    "node_modules/buffer-layout/lib/Layout.js"(exports) {
      "use strict";
      var Layout2 = class {
        constructor(span, property) {
          if (!Number.isInteger(span)) {
            throw new TypeError("span must be an integer");
          }
          this.span = span;
          this.property = property;
        }
        /** Function to create an Object into which decoded properties will
         * be written.
         *
         * Used only for layouts that {@link Layout#decode|decode} to Object
         * instances, which means:
         * * {@link Structure}
         * * {@link Union}
         * * {@link VariantLayout}
         * * {@link BitStructure}
         *
         * If left undefined the JavaScript representation of these layouts
         * will be Object instances.
         *
         * See {@link bindConstructorLayout}.
         */
        makeDestinationObject() {
          return {};
        }
        /**
         * Decode from a Buffer into an JavaScript value.
         *
         * @param {Buffer} b - the buffer from which encoded data is read.
         *
         * @param {Number} [offset] - the offset at which the encoded data
         * starts.  If absent a zero offset is inferred.
         *
         * @returns {(Number|Array|Object)} - the value of the decoded data.
         *
         * @abstract
         */
        decode(b, offset2) {
          throw new Error("Layout is abstract");
        }
        /**
         * Encode a JavaScript value into a Buffer.
         *
         * @param {(Number|Array|Object)} src - the value to be encoded into
         * the buffer.  The type accepted depends on the (sub-)type of {@link
         * Layout}.
         *
         * @param {Buffer} b - the buffer into which encoded data will be
         * written.
         *
         * @param {Number} [offset] - the offset at which the encoded data
         * starts.  If absent a zero offset is inferred.
         *
         * @returns {Number} - the number of bytes encoded, including the
         * space skipped for internal padding, but excluding data such as
         * {@link Sequence#count|lengths} when stored {@link
         * ExternalLayout|externally}.  This is the adjustment to `offset`
         * producing the offset where data for the next layout would be
         * written.
         *
         * @abstract
         */
        encode(src, b, offset2) {
          throw new Error("Layout is abstract");
        }
        /**
         * Calculate the span of a specific instance of a layout.
         *
         * @param {Buffer} b - the buffer that contains an encoded instance.
         *
         * @param {Number} [offset] - the offset at which the encoded instance
         * starts.  If absent a zero offset is inferred.
         *
         * @return {Number} - the number of bytes covered by the layout
         * instance.  If this method is not overridden in a subclass the
         * definition-time constant {@link Layout#span|span} will be
         * returned.
         *
         * @throws {RangeError} - if the length of the value cannot be
         * determined.
         */
        getSpan(b, offset2) {
          if (0 > this.span) {
            throw new RangeError("indeterminate span");
          }
          return this.span;
        }
        /**
         * Replicate the layout using a new property.
         *
         * This function must be used to get a structurally-equivalent layout
         * with a different name since all {@link Layout} instances are
         * immutable.
         *
         * **NOTE** This is a shallow copy.  All fields except {@link
         * Layout#property|property} are strictly equal to the origin layout.
         *
         * @param {String} property - the value for {@link
         * Layout#property|property} in the replica.
         *
         * @returns {Layout} - the copy with {@link Layout#property|property}
         * set to `property`.
         */
        replicate(property) {
          const rv = Object.create(this.constructor.prototype);
          Object.assign(rv, this);
          rv.property = property;
          return rv;
        }
        /**
         * Create an object from layout properties and an array of values.
         *
         * **NOTE** This function returns `undefined` if invoked on a layout
         * that does not return its value as an Object.  Objects are
         * returned for things that are a {@link Structure}, which includes
         * {@link VariantLayout|variant layouts} if they are structures, and
         * excludes {@link Union}s.  If you want this feature for a union
         * you must use {@link Union.getVariant|getVariant} to select the
         * desired layout.
         *
         * @param {Array} values - an array of values that correspond to the
         * default order for properties.  As with {@link Layout#decode|decode}
         * layout elements that have no property name are skipped when
         * iterating over the array values.  Only the top-level properties are
         * assigned; arguments are not assigned to properties of contained
         * layouts.  Any unused values are ignored.
         *
         * @return {(Object|undefined)}
         */
        fromArray(values) {
          return void 0;
        }
      };
      exports.Layout = Layout2;
      function nameWithProperty2(name, lo) {
        if (lo.property) {
          return name + "[" + lo.property + "]";
        }
        return name;
      }
      exports.nameWithProperty = nameWithProperty2;
      function bindConstructorLayout(Class, layout) {
        if ("function" !== typeof Class) {
          throw new TypeError("Class must be constructor");
        }
        if (Class.hasOwnProperty("layout_")) {
          throw new Error("Class is already bound to a layout");
        }
        if (!(layout && layout instanceof Layout2)) {
          throw new TypeError("layout must be a Layout");
        }
        if (layout.hasOwnProperty("boundConstructor_")) {
          throw new Error("layout is already bound to a constructor");
        }
        Class.layout_ = layout;
        layout.boundConstructor_ = Class;
        layout.makeDestinationObject = (() => new Class());
        Object.defineProperty(Class.prototype, "encode", {
          value: function(b, offset2) {
            return layout.encode(this, b, offset2);
          },
          writable: true
        });
        Object.defineProperty(Class, "decode", {
          value: function(b, offset2) {
            return layout.decode(b, offset2);
          },
          writable: true
        });
      }
      exports.bindConstructorLayout = bindConstructorLayout;
      var ExternalLayout2 = class extends Layout2 {
        /**
         * Return `true` iff the external layout decodes to an unsigned
         * integer layout.
         *
         * In that case it can be used as the source of {@link
         * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
         * or as {@link UnionLayoutDiscriminator#layout|external union
         * discriminators}.
         *
         * @abstract
         */
        isCount() {
          throw new Error("ExternalLayout is abstract");
        }
      };
      var GreedyCount = class extends ExternalLayout2 {
        constructor(elementSpan, property) {
          if (void 0 === elementSpan) {
            elementSpan = 1;
          }
          if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
            throw new TypeError("elementSpan must be a (positive) integer");
          }
          super(-1, property);
          this.elementSpan = elementSpan;
        }
        /** @override */
        isCount() {
          return true;
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const rem = b.length - offset2;
          return Math.floor(rem / this.elementSpan);
        }
        /** @override */
        encode(src, b, offset2) {
          return 0;
        }
      };
      var OffsetLayout2 = class extends ExternalLayout2 {
        constructor(layout, offset2, property) {
          if (!(layout instanceof Layout2)) {
            throw new TypeError("layout must be a Layout");
          }
          if (void 0 === offset2) {
            offset2 = 0;
          } else if (!Number.isInteger(offset2)) {
            throw new TypeError("offset must be integer or undefined");
          }
          super(layout.span, property || layout.property);
          this.layout = layout;
          this.offset = offset2;
        }
        /** @override */
        isCount() {
          return this.layout instanceof UInt2 || this.layout instanceof UIntBE2;
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return this.layout.decode(b, offset2 + this.offset);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return this.layout.encode(src, b, offset2 + this.offset);
        }
      };
      var UInt2 = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readUIntLE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeUIntLE(src, offset2, this.span);
          return this.span;
        }
      };
      var UIntBE2 = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readUIntBE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeUIntBE(src, offset2, this.span);
          return this.span;
        }
      };
      var Int = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readIntLE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeIntLE(src, offset2, this.span);
          return this.span;
        }
      };
      var IntBE = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readIntBE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeIntBE(src, offset2, this.span);
          return this.span;
        }
      };
      var V2E322 = Math.pow(2, 32);
      function divmodInt642(src) {
        const hi32 = Math.floor(src / V2E322);
        const lo32 = src - hi32 * V2E322;
        return { hi32, lo32 };
      }
      function roundedInt642(hi32, lo32) {
        return hi32 * V2E322 + lo32;
      }
      var NearUInt642 = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const lo32 = b.readUInt32LE(offset2);
          const hi32 = b.readUInt32LE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const split = divmodInt642(src);
          b.writeUInt32LE(split.lo32, offset2);
          b.writeUInt32LE(split.hi32, offset2 + 4);
          return 8;
        }
      };
      var NearUInt64BE = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const hi32 = b.readUInt32BE(offset2);
          const lo32 = b.readUInt32BE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const split = divmodInt642(src);
          b.writeUInt32BE(split.hi32, offset2);
          b.writeUInt32BE(split.lo32, offset2 + 4);
          return 8;
        }
      };
      var NearInt642 = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const lo32 = b.readUInt32LE(offset2);
          const hi32 = b.readInt32LE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const split = divmodInt642(src);
          b.writeUInt32LE(split.lo32, offset2);
          b.writeInt32LE(split.hi32, offset2 + 4);
          return 8;
        }
      };
      var NearInt64BE = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const hi32 = b.readInt32BE(offset2);
          const lo32 = b.readUInt32BE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const split = divmodInt642(src);
          b.writeInt32BE(split.hi32, offset2);
          b.writeUInt32BE(split.lo32, offset2 + 4);
          return 8;
        }
      };
      var Float = class extends Layout2 {
        constructor(property) {
          super(4, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readFloatLE(offset2);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeFloatLE(src, offset2);
          return 4;
        }
      };
      var FloatBE = class extends Layout2 {
        constructor(property) {
          super(4, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readFloatBE(offset2);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeFloatBE(src, offset2);
          return 4;
        }
      };
      var Double = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readDoubleLE(offset2);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeDoubleLE(src, offset2);
          return 8;
        }
      };
      var DoubleBE = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readDoubleBE(offset2);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeDoubleBE(src, offset2);
          return 8;
        }
      };
      var Sequence = class extends Layout2 {
        constructor(elementLayout, count, property) {
          if (!(elementLayout instanceof Layout2)) {
            throw new TypeError("elementLayout must be a Layout");
          }
          if (!(count instanceof ExternalLayout2 && count.isCount() || Number.isInteger(count) && 0 <= count)) {
            throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(count instanceof ExternalLayout2) && 0 < elementLayout.span) {
            span = count * elementLayout.span;
          }
          super(span, property);
          this.elementLayout = elementLayout;
          this.count = count;
        }
        /** @override */
        getSpan(b, offset2) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let span = 0;
          let count = this.count;
          if (count instanceof ExternalLayout2) {
            count = count.decode(b, offset2);
          }
          if (0 < this.elementLayout.span) {
            span = count * this.elementLayout.span;
          } else {
            let idx = 0;
            while (idx < count) {
              span += this.elementLayout.getSpan(b, offset2 + span);
              ++idx;
            }
          }
          return span;
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const rv = [];
          let i = 0;
          let count = this.count;
          if (count instanceof ExternalLayout2) {
            count = count.decode(b, offset2);
          }
          while (i < count) {
            rv.push(this.elementLayout.decode(b, offset2));
            offset2 += this.elementLayout.getSpan(b, offset2);
            i += 1;
          }
          return rv;
        }
        /** Implement {@link Layout#encode|encode} for {@link Sequence}.
         *
         * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
         * the unused space in the buffer is left unchanged.  If `src` is
         * longer than {@link Sequence#count|count} the unneeded elements are
         * ignored.
         *
         * **NOTE** If {@link Layout#count|count} is an instance of {@link
         * ExternalLayout} then the length of `src` will be encoded as the
         * count after `src` is encoded. */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const elo = this.elementLayout;
          const span = src.reduce((span2, v) => {
            return span2 + elo.encode(v, b, offset2 + span2);
          }, 0);
          if (this.count instanceof ExternalLayout2) {
            this.count.encode(src.length, b, offset2);
          }
          return span;
        }
      };
      var Structure2 = class extends Layout2 {
        constructor(fields, property, decodePrefixes) {
          if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout2, true))) {
            throw new TypeError("fields must be array of Layout instances");
          }
          if ("boolean" === typeof property && void 0 === decodePrefixes) {
            decodePrefixes = property;
            property = void 0;
          }
          for (const fd of fields) {
            if (0 > fd.span && void 0 === fd.property) {
              throw new Error("fields cannot contain unnamed variable-length layout");
            }
          }
          let span = -1;
          try {
            span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
          } catch (e) {
          }
          super(span, property);
          this.fields = fields;
          this.decodePrefixes = !!decodePrefixes;
        }
        /** @override */
        getSpan(b, offset2) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let span = 0;
          try {
            span = this.fields.reduce((span2, fd) => {
              const fsp = fd.getSpan(b, offset2);
              offset2 += fsp;
              return span2 + fsp;
            }, 0);
          } catch (e) {
            throw new RangeError("indeterminate span");
          }
          return span;
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(b, offset2);
            }
            offset2 += fd.getSpan(b, offset2);
            if (this.decodePrefixes && b.length === offset2) {
              break;
            }
          }
          return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link Structure}.
         *
         * If `src` is missing a property for a member with a defined {@link
         * Layout#property|property} the corresponding region of the buffer is
         * left unmodified. */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const firstOffset = offset2;
          let lastOffset = 0;
          let lastWrote = 0;
          for (const fd of this.fields) {
            let span = fd.span;
            lastWrote = 0 < span ? span : 0;
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                lastWrote = fd.encode(fv, b, offset2);
                if (0 > span) {
                  span = fd.getSpan(b, offset2);
                }
              }
            }
            lastOffset = offset2;
            offset2 += span;
          }
          return lastOffset + lastWrote - firstOffset;
        }
        /** @override */
        fromArray(values) {
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property && 0 < values.length) {
              dest[fd.property] = values.shift();
            }
          }
          return dest;
        }
        /**
         * Get access to the layout of a given property.
         *
         * @param {String} property - the structure member of interest.
         *
         * @return {Layout} - the layout associated with `property`, or
         * undefined if there is no such property.
         */
        layoutFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
        }
        /**
         * Get the offset of a structure member.
         *
         * @param {String} property - the structure member of interest.
         *
         * @return {Number} - the offset in bytes to the start of `property`
         * within the structure, or undefined if `property` is not a field
         * within the structure.  If the property is a member but follows a
         * variable-length structure member a negative number will be
         * returned.
         */
        offsetOf(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          let offset2 = 0;
          for (const fd of this.fields) {
            if (fd.property === property) {
              return offset2;
            }
            if (0 > fd.span) {
              offset2 = -1;
            } else if (0 <= offset2) {
              offset2 += fd.span;
            }
          }
        }
      };
      var UnionDiscriminator2 = class {
        constructor(property) {
          this.property = property;
        }
        /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
         *
         * The implementation of this method need not reference the buffer if
         * variant information is available through other means. */
        decode() {
          throw new Error("UnionDiscriminator is abstract");
        }
        /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
         *
         * The implementation of this method need not store the value if
         * variant information is maintained through other means. */
        encode() {
          throw new Error("UnionDiscriminator is abstract");
        }
      };
      var UnionLayoutDiscriminator2 = class extends UnionDiscriminator2 {
        constructor(layout, property) {
          if (!(layout instanceof ExternalLayout2 && layout.isCount())) {
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
          }
          super(property || layout.property || "variant");
          this.layout = layout;
        }
        /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
        decode(b, offset2) {
          return this.layout.decode(b, offset2);
        }
        /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
        encode(src, b, offset2) {
          return this.layout.encode(src, b, offset2);
        }
      };
      var Union2 = class extends Layout2 {
        constructor(discr, defaultLayout, property) {
          const upv = discr instanceof UInt2 || discr instanceof UIntBE2;
          if (upv) {
            discr = new UnionLayoutDiscriminator2(new OffsetLayout2(discr));
          } else if (discr instanceof ExternalLayout2 && discr.isCount()) {
            discr = new UnionLayoutDiscriminator2(discr);
          } else if (!(discr instanceof UnionDiscriminator2)) {
            throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
          }
          if (void 0 === defaultLayout) {
            defaultLayout = null;
          }
          if (!(null === defaultLayout || defaultLayout instanceof Layout2)) {
            throw new TypeError("defaultLayout must be null or a Layout");
          }
          if (null !== defaultLayout) {
            if (0 > defaultLayout.span) {
              throw new Error("defaultLayout must have constant span");
            }
            if (void 0 === defaultLayout.property) {
              defaultLayout = defaultLayout.replicate("content");
            }
          }
          let span = -1;
          if (defaultLayout) {
            span = defaultLayout.span;
            if (0 <= span && upv) {
              span += discr.layout.span;
            }
          }
          super(span, property);
          this.discriminator = discr;
          this.usesPrefixDiscriminator = upv;
          this.defaultLayout = defaultLayout;
          this.registry = {};
          let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
          this.getSourceVariant = function(src) {
            return boundGetSourceVariant(src);
          };
          this.configGetSourceVariant = function(gsv) {
            boundGetSourceVariant = gsv.bind(this);
          };
        }
        /** @override */
        getSpan(b, offset2) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const vlo = this.getVariant(b, offset2);
          if (!vlo) {
            throw new Error("unable to determine span for unrecognized variant");
          }
          return vlo.getSpan(b, offset2);
        }
        /**
         * Method to infer a registered Union variant compatible with `src`.
         *
         * The first satisified rule in the following sequence defines the
         * return value:
         * * If `src` has properties matching the Union discriminator and
         *   the default layout, `undefined` is returned regardless of the
         *   value of the discriminator property (this ensures the default
         *   layout will be used);
         * * If `src` has a property matching the Union discriminator, the
         *   value of the discriminator identifies a registered variant, and
         *   either (a) the variant has no layout, or (b) `src` has the
         *   variant's property, then the variant is returned (because the
         *   source satisfies the constraints of the variant it identifies);
         * * If `src` does not have a property matching the Union
         *   discriminator, but does have a property matching a registered
         *   variant, then the variant is returned (because the source
         *   matches a variant without an explicit conflict);
         * * An error is thrown (because we either can't identify a variant,
         *   or we were explicitly told the variant but can't satisfy it).
         *
         * @param {Object} src - an object presumed to be compatible with
         * the content of the Union.
         *
         * @return {(undefined|VariantLayout)} - as described above.
         *
         * @throws {Error} - if `src` cannot be associated with a default or
         * registered variant.
         */
        defaultGetSourceVariant(src) {
          if (src.hasOwnProperty(this.discriminator.property)) {
            if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
              return void 0;
            }
            const vlo = this.registry[src[this.discriminator.property]];
            if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
              return vlo;
            }
          } else {
            for (const tag in this.registry) {
              const vlo = this.registry[tag];
              if (src.hasOwnProperty(vlo.property)) {
                return vlo;
              }
            }
          }
          throw new Error("unable to infer src variant");
        }
        /** Implement {@link Layout#decode|decode} for {@link Union}.
         *
         * If the variant is {@link Union#addVariant|registered} the return
         * value is an instance of that variant, with no explicit
         * discriminator.  Otherwise the {@link Union#defaultLayout|default
         * layout} is used to decode the content. */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let dest;
          const dlo = this.discriminator;
          const discr = dlo.decode(b, offset2);
          let clo = this.registry[discr];
          if (void 0 === clo) {
            let contentOffset = 0;
            clo = this.defaultLayout;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dest = this.makeDestinationObject();
            dest[dlo.property] = discr;
            dest[clo.property] = this.defaultLayout.decode(b, offset2 + contentOffset);
          } else {
            dest = clo.decode(b, offset2);
          }
          return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link Union}.
         *
         * This API assumes the `src` object is consistent with the union's
         * {@link Union#defaultLayout|default layout}.  To encode variants
         * use the appropriate variant-specific {@link VariantLayout#encode}
         * method. */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const vlo = this.getSourceVariant(src);
          if (void 0 === vlo) {
            const dlo = this.discriminator;
            const clo = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dlo.encode(src[dlo.property], b, offset2);
            return contentOffset + clo.encode(
              src[clo.property],
              b,
              offset2 + contentOffset
            );
          }
          return vlo.encode(src, b, offset2);
        }
        /** Register a new variant structure within a union.  The newly
         * created variant is returned.
         *
         * @param {Number} variant - initializer for {@link
         * VariantLayout#variant|variant}.
         *
         * @param {Layout} layout - initializer for {@link
         * VariantLayout#layout|layout}.
         *
         * @param {String} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {VariantLayout} */
        addVariant(variant, layout, property) {
          const rv = new VariantLayout2(this, variant, layout, property);
          this.registry[variant] = rv;
          return rv;
        }
        /**
         * Get the layout associated with a registered variant.
         *
         * If `vb` does not produce a registered variant the function returns
         * `undefined`.
         *
         * @param {(Number|Buffer)} vb - either the variant number, or a
         * buffer from which the discriminator is to be read.
         *
         * @param {Number} offset - offset into `vb` for the start of the
         * union.  Used only when `vb` is an instance of {Buffer}.
         *
         * @return {({VariantLayout}|undefined)}
         */
        getVariant(vb, offset2) {
          let variant = vb;
          if (Buffer.isBuffer(vb)) {
            if (void 0 === offset2) {
              offset2 = 0;
            }
            variant = this.discriminator.decode(vb, offset2);
          }
          return this.registry[variant];
        }
      };
      var VariantLayout2 = class extends Layout2 {
        constructor(union2, variant, layout, property) {
          if (!(union2 instanceof Union2)) {
            throw new TypeError("union must be a Union");
          }
          if (!Number.isInteger(variant) || 0 > variant) {
            throw new TypeError("variant must be a (non-negative) integer");
          }
          if ("string" === typeof layout && void 0 === property) {
            property = layout;
            layout = null;
          }
          if (layout) {
            if (!(layout instanceof Layout2)) {
              throw new TypeError("layout must be a Layout");
            }
            if (null !== union2.defaultLayout && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
              throw new Error("variant span exceeds span of containing union");
            }
            if ("string" !== typeof property) {
              throw new TypeError("variant must have a String property");
            }
          }
          let span = union2.span;
          if (0 > union2.span) {
            span = layout ? layout.span : 0;
            if (0 <= span && union2.usesPrefixDiscriminator) {
              span += union2.discriminator.layout.span;
            }
          }
          super(span, property);
          this.union = union2;
          this.variant = variant;
          this.layout = layout || null;
        }
        /** @override */
        getSpan(b, offset2) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          return contentOffset + this.layout.getSpan(b, offset2 + contentOffset);
        }
        /** @override */
        decode(b, offset2) {
          const dest = this.makeDestinationObject();
          if (void 0 === offset2) {
            offset2 = 0;
          }
          if (this !== this.union.getVariant(b, offset2)) {
            throw new Error("variant mismatch");
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout) {
            dest[this.property] = this.layout.decode(b, offset2 + contentOffset);
          } else if (this.property) {
            dest[this.property] = true;
          } else if (this.union.usesPrefixDiscriminator) {
            dest[this.union.discriminator.property] = this.variant;
          }
          return dest;
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout && !src.hasOwnProperty(this.property)) {
            throw new TypeError("variant lacks property " + this.property);
          }
          this.union.discriminator.encode(this.variant, b, offset2);
          let span = contentOffset;
          if (this.layout) {
            this.layout.encode(src[this.property], b, offset2 + contentOffset);
            span += this.layout.getSpan(b, offset2 + contentOffset);
            if (0 <= this.union.span && span > this.union.span) {
              throw new Error("encoded variant overruns containing union");
            }
          }
          return span;
        }
        /** Delegate {@link Layout#fromArray|fromArray} to {@link
         * VariantLayout#layout|layout}. */
        fromArray(values) {
          if (this.layout) {
            return this.layout.fromArray(values);
          }
        }
      };
      function fixBitwiseResult(v) {
        if (0 > v) {
          v += 4294967296;
        }
        return v;
      }
      var BitStructure = class extends Layout2 {
        constructor(word, msb, property) {
          if (!(word instanceof UInt2 || word instanceof UIntBE2)) {
            throw new TypeError("word must be a UInt or UIntBE layout");
          }
          if ("string" === typeof msb && void 0 === property) {
            property = msb;
            msb = void 0;
          }
          if (4 < word.span) {
            throw new RangeError("word cannot exceed 32 bits");
          }
          super(word.span, property);
          this.word = word;
          this.msb = !!msb;
          this.fields = [];
          let value = 0;
          this._packedSetValue = function(v) {
            value = fixBitwiseResult(v);
            return this;
          };
          this._packedGetValue = function() {
            return value;
          };
        }
        /** @override */
        decode(b, offset2) {
          const dest = this.makeDestinationObject();
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const value = this.word.decode(b, offset2);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(value);
            }
          }
          return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
         *
         * If `src` is missing a property for a member with a defined {@link
         * Layout#property|property} the corresponding region of the packed
         * value is left unmodified.  Unused bits are also left unmodified. */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const value = this.word.decode(b, offset2);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                fd.encode(fv);
              }
            }
          }
          return this.word.encode(this._packedGetValue(), b, offset2);
        }
        /** Register a new bitfield with a containing bit structure.  The
         * resulting bitfield is returned.
         *
         * @param {Number} bits - initializer for {@link BitField#bits|bits}.
         *
         * @param {string} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {BitField} */
        addField(bits, property) {
          const bf = new BitField(this, bits, property);
          this.fields.push(bf);
          return bf;
        }
        /** As with {@link BitStructure#addField|addField} for single-bit
         * fields with `boolean` value representation.
         *
         * @param {string} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {Boolean} */
        addBoolean(property) {
          const bf = new Boolean2(this, property);
          this.fields.push(bf);
          return bf;
        }
        /**
         * Get access to the bit field for a given property.
         *
         * @param {String} property - the bit field of interest.
         *
         * @return {BitField} - the field associated with `property`, or
         * undefined if there is no such property.
         */
        fieldFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
        }
      };
      var BitField = class {
        constructor(container, bits, property) {
          if (!(container instanceof BitStructure)) {
            throw new TypeError("container must be a BitStructure");
          }
          if (!Number.isInteger(bits) || 0 >= bits) {
            throw new TypeError("bits must be positive integer");
          }
          const totalBits = 8 * container.span;
          const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
          if (bits + usedBits > totalBits) {
            throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
          }
          this.container = container;
          this.bits = bits;
          this.valueMask = (1 << bits) - 1;
          if (32 === bits) {
            this.valueMask = 4294967295;
          }
          this.start = usedBits;
          if (this.container.msb) {
            this.start = totalBits - usedBits - bits;
          }
          this.wordMask = fixBitwiseResult(this.valueMask << this.start);
          this.property = property;
        }
        /** Store a value into the corresponding subsequence of the containing
         * bit field. */
        decode() {
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult(word & this.wordMask);
          const value = wordValue >>> this.start;
          return value;
        }
        /** Store a value into the corresponding subsequence of the containing
         * bit field.
         *
         * **NOTE** This is not a specialization of {@link
         * Layout#encode|Layout.encode} and there is no return value. */
        encode(value) {
          if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
            throw new TypeError(nameWithProperty2("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
          }
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult(value << this.start);
          this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
        }
      };
      var Boolean2 = class extends BitField {
        constructor(container, property) {
          super(container, 1, property);
        }
        /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
         *
         * @returns {boolean} */
        decode(b, offset2) {
          return !!BitField.prototype.decode.call(this, b, offset2);
        }
        /** @override */
        encode(value) {
          if ("boolean" === typeof value) {
            value = +value;
          }
          return BitField.prototype.encode.call(this, value);
        }
      };
      var Blob2 = class extends Layout2 {
        constructor(length, property) {
          if (!(length instanceof ExternalLayout2 && length.isCount() || Number.isInteger(length) && 0 <= length)) {
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(length instanceof ExternalLayout2)) {
            span = length;
          }
          super(span, property);
          this.length = length;
        }
        /** @override */
        getSpan(b, offset2) {
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b, offset2);
          }
          return span;
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b, offset2);
          }
          return b.slice(offset2, offset2 + span);
        }
        /** Implement {@link Layout#encode|encode} for {@link Blob}.
         *
         * **NOTE** If {@link Layout#count|count} is an instance of {@link
         * ExternalLayout} then the length of `src` will be encoded as the
         * count after `src` is encoded. */
        encode(src, b, offset2) {
          let span = this.length;
          if (this.length instanceof ExternalLayout2) {
            span = src.length;
          }
          if (!(Buffer.isBuffer(src) && span === src.length)) {
            throw new TypeError(nameWithProperty2("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
          }
          if (offset2 + span > b.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          b.write(src.toString("hex"), offset2, span, "hex");
          if (this.length instanceof ExternalLayout2) {
            this.length.encode(span, b, offset2);
          }
          return span;
        }
      };
      var CString = class extends Layout2 {
        constructor(property) {
          super(-1, property);
        }
        /** @override */
        getSpan(b, offset2) {
          if (!Buffer.isBuffer(b)) {
            throw new TypeError("b must be a Buffer");
          }
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let idx = offset2;
          while (idx < b.length && 0 !== b[idx]) {
            idx += 1;
          }
          return 1 + idx - offset2;
        }
        /** @override */
        decode(b, offset2, dest) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let span = this.getSpan(b, offset2);
          return b.slice(offset2, offset2 + span - 1).toString("utf-8");
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          if ("string" !== typeof src) {
            src = src.toString();
          }
          const srcb = new Buffer(src, "utf8");
          const span = srcb.length;
          if (offset2 + span > b.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          srcb.copy(b, offset2);
          b[offset2 + span] = 0;
          return span + 1;
        }
      };
      var UTF8 = class extends Layout2 {
        constructor(maxSpan, property) {
          if ("string" === typeof maxSpan && void 0 === property) {
            property = maxSpan;
            maxSpan = void 0;
          }
          if (void 0 === maxSpan) {
            maxSpan = -1;
          } else if (!Number.isInteger(maxSpan)) {
            throw new TypeError("maxSpan must be an integer");
          }
          super(-1, property);
          this.maxSpan = maxSpan;
        }
        /** @override */
        getSpan(b, offset2) {
          if (!Buffer.isBuffer(b)) {
            throw new TypeError("b must be a Buffer");
          }
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.length - offset2;
        }
        /** @override */
        decode(b, offset2, dest) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let span = this.getSpan(b, offset2);
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          return b.slice(offset2, offset2 + span).toString("utf-8");
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          if ("string" !== typeof src) {
            src = src.toString();
          }
          const srcb = new Buffer(src, "utf8");
          const span = srcb.length;
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          if (offset2 + span > b.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          srcb.copy(b, offset2);
          return span;
        }
      };
      var Constant = class extends Layout2 {
        constructor(value, property) {
          super(0, property);
          this.value = value;
        }
        /** @override */
        decode(b, offset2, dest) {
          return this.value;
        }
        /** @override */
        encode(src, b, offset2) {
          return 0;
        }
      };
      exports.ExternalLayout = ExternalLayout2;
      exports.GreedyCount = GreedyCount;
      exports.OffsetLayout = OffsetLayout2;
      exports.UInt = UInt2;
      exports.UIntBE = UIntBE2;
      exports.Int = Int;
      exports.IntBE = IntBE;
      exports.Float = Float;
      exports.FloatBE = FloatBE;
      exports.Double = Double;
      exports.DoubleBE = DoubleBE;
      exports.Sequence = Sequence;
      exports.Structure = Structure2;
      exports.UnionDiscriminator = UnionDiscriminator2;
      exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator2;
      exports.Union = Union2;
      exports.VariantLayout = VariantLayout2;
      exports.BitStructure = BitStructure;
      exports.BitField = BitField;
      exports.Boolean = Boolean2;
      exports.Blob = Blob2;
      exports.CString = CString;
      exports.UTF8 = UTF8;
      exports.Constant = Constant;
      exports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));
      exports.offset = ((layout, offset2, property) => new OffsetLayout2(layout, offset2, property));
      exports.u8 = ((property) => new UInt2(1, property));
      exports.u16 = ((property) => new UInt2(2, property));
      exports.u24 = ((property) => new UInt2(3, property));
      exports.u32 = ((property) => new UInt2(4, property));
      exports.u40 = ((property) => new UInt2(5, property));
      exports.u48 = ((property) => new UInt2(6, property));
      exports.nu64 = ((property) => new NearUInt642(property));
      exports.u16be = ((property) => new UIntBE2(2, property));
      exports.u24be = ((property) => new UIntBE2(3, property));
      exports.u32be = ((property) => new UIntBE2(4, property));
      exports.u40be = ((property) => new UIntBE2(5, property));
      exports.u48be = ((property) => new UIntBE2(6, property));
      exports.nu64be = ((property) => new NearUInt64BE(property));
      exports.s8 = ((property) => new Int(1, property));
      exports.s16 = ((property) => new Int(2, property));
      exports.s24 = ((property) => new Int(3, property));
      exports.s32 = ((property) => new Int(4, property));
      exports.s40 = ((property) => new Int(5, property));
      exports.s48 = ((property) => new Int(6, property));
      exports.ns64 = ((property) => new NearInt642(property));
      exports.s16be = ((property) => new IntBE(2, property));
      exports.s24be = ((property) => new IntBE(3, property));
      exports.s32be = ((property) => new IntBE(4, property));
      exports.s40be = ((property) => new IntBE(5, property));
      exports.s48be = ((property) => new IntBE(6, property));
      exports.ns64be = ((property) => new NearInt64BE(property));
      exports.f32 = ((property) => new Float(property));
      exports.f32be = ((property) => new FloatBE(property));
      exports.f64 = ((property) => new Double(property));
      exports.f64be = ((property) => new DoubleBE(property));
      exports.struct = ((fields, property, decodePrefixes) => new Structure2(fields, property, decodePrefixes));
      exports.bits = ((word, msb, property) => new BitStructure(word, msb, property));
      exports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));
      exports.union = ((discr, defaultLayout, property) => new Union2(discr, defaultLayout, property));
      exports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator2(layout, property));
      exports.blob = ((length, property) => new Blob2(length, property));
      exports.cstr = ((property) => new CString(property));
      exports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));
      exports.const = ((value, property) => new Constant(value, property));
    }
  });

  // node_modules/@coral-xyz/borsh/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/@coral-xyz/borsh/dist/index.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.map = exports.array = exports.rustEnum = exports.str = exports.vecU8 = exports.tagged = exports.vec = exports.bool = exports.option = exports.publicKey = exports.i256 = exports.u256 = exports.i128 = exports.u128 = exports.i64 = exports.u64 = exports.struct = exports.f64 = exports.f32 = exports.i32 = exports.u32 = exports.i16 = exports.u16 = exports.i8 = exports.u8 = void 0;
      var buffer_layout_1 = require_Layout2();
      var web3_js_1 = require_index_browser_cjs();
      var bn_js_1 = __importDefault(require_bn());
      var buffer_layout_2 = require_Layout2();
      Object.defineProperty(exports, "u8", { enumerable: true, get: function() {
        return buffer_layout_2.u8;
      } });
      Object.defineProperty(exports, "i8", { enumerable: true, get: function() {
        return buffer_layout_2.s8;
      } });
      Object.defineProperty(exports, "u16", { enumerable: true, get: function() {
        return buffer_layout_2.u16;
      } });
      Object.defineProperty(exports, "i16", { enumerable: true, get: function() {
        return buffer_layout_2.s16;
      } });
      Object.defineProperty(exports, "u32", { enumerable: true, get: function() {
        return buffer_layout_2.u32;
      } });
      Object.defineProperty(exports, "i32", { enumerable: true, get: function() {
        return buffer_layout_2.s32;
      } });
      Object.defineProperty(exports, "f32", { enumerable: true, get: function() {
        return buffer_layout_2.f32;
      } });
      Object.defineProperty(exports, "f64", { enumerable: true, get: function() {
        return buffer_layout_2.f64;
      } });
      Object.defineProperty(exports, "struct", { enumerable: true, get: function() {
        return buffer_layout_2.struct;
      } });
      var BNLayout = class extends buffer_layout_1.Layout {
        constructor(span, signed, property) {
          super(span, property);
          this.blob = (0, buffer_layout_1.blob)(span);
          this.signed = signed;
        }
        decode(b, offset2 = 0) {
          const num = new bn_js_1.default(this.blob.decode(b, offset2), 10, "le");
          if (this.signed) {
            return num.fromTwos(this.span * 8).clone();
          }
          return num;
        }
        encode(src, b, offset2 = 0) {
          if (this.signed) {
            src = src.toTwos(this.span * 8);
          }
          return this.blob.encode(src.toArrayLike(Buffer, "le", this.span), b, offset2);
        }
      };
      function u643(property) {
        return new BNLayout(8, false, property);
      }
      exports.u64 = u643;
      function i642(property) {
        return new BNLayout(8, true, property);
      }
      exports.i64 = i642;
      function u1282(property) {
        return new BNLayout(16, false, property);
      }
      exports.u128 = u1282;
      function i1282(property) {
        return new BNLayout(16, true, property);
      }
      exports.i128 = i1282;
      function u2562(property) {
        return new BNLayout(32, false, property);
      }
      exports.u256 = u2562;
      function i2562(property) {
        return new BNLayout(32, true, property);
      }
      exports.i256 = i2562;
      var WrappedLayout2 = class extends buffer_layout_1.Layout {
        constructor(layout, decoder, encoder, property) {
          super(layout.span, property);
          this.layout = layout;
          this.decoder = decoder;
          this.encoder = encoder;
        }
        decode(b, offset2) {
          return this.decoder(this.layout.decode(b, offset2));
        }
        encode(src, b, offset2) {
          return this.layout.encode(this.encoder(src), b, offset2);
        }
        getSpan(b, offset2) {
          return this.layout.getSpan(b, offset2);
        }
      };
      function publicKey3(property) {
        return new WrappedLayout2((0, buffer_layout_1.blob)(32), (b) => new web3_js_1.PublicKey(b), (key) => key.toBuffer(), property);
      }
      exports.publicKey = publicKey3;
      var OptionLayout = class extends buffer_layout_1.Layout {
        constructor(layout, property) {
          super(-1, property);
          this.layout = layout;
          this.discriminator = (0, buffer_layout_1.u8)();
        }
        encode(src, b, offset2 = 0) {
          if (src === null || src === void 0) {
            return this.discriminator.encode(0, b, offset2);
          }
          this.discriminator.encode(1, b, offset2);
          return this.layout.encode(src, b, offset2 + 1) + 1;
        }
        decode(b, offset2 = 0) {
          const discriminator = this.discriminator.decode(b, offset2);
          if (discriminator === 0) {
            return null;
          } else if (discriminator === 1) {
            return this.layout.decode(b, offset2 + 1);
          }
          throw new Error("Invalid option " + this.property);
        }
        getSpan(b, offset2 = 0) {
          const discriminator = this.discriminator.decode(b, offset2);
          if (discriminator === 0) {
            return 1;
          } else if (discriminator === 1) {
            return this.layout.getSpan(b, offset2 + 1) + 1;
          }
          throw new Error("Invalid option " + this.property);
        }
      };
      function option2(layout, property) {
        return new OptionLayout(layout, property);
      }
      exports.option = option2;
      function bool2(property) {
        return new WrappedLayout2((0, buffer_layout_1.u8)(), decodeBool, encodeBool, property);
      }
      exports.bool = bool2;
      function decodeBool(value) {
        if (value === 0) {
          return false;
        } else if (value === 1) {
          return true;
        }
        throw new Error("Invalid bool: " + value);
      }
      function encodeBool(value) {
        return value ? 1 : 0;
      }
      function vec2(elementLayout, property) {
        const length = (0, buffer_layout_1.u32)("length");
        const layout = (0, buffer_layout_1.struct)([
          length,
          (0, buffer_layout_1.seq)(elementLayout, (0, buffer_layout_1.offset)(length, -length.span), "values")
        ]);
        return new WrappedLayout2(layout, ({ values }) => values, (values) => ({ values }), property);
      }
      exports.vec = vec2;
      function tagged(tag, layout, property) {
        const wrappedLayout = (0, buffer_layout_1.struct)([
          u643("tag"),
          layout.replicate("data")
        ]);
        function decodeTag({ tag: receivedTag, data }) {
          if (!receivedTag.eq(tag)) {
            throw new Error("Invalid tag, expected: " + tag.toString("hex") + ", got: " + receivedTag.toString("hex"));
          }
          return data;
        }
        return new WrappedLayout2(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);
      }
      exports.tagged = tagged;
      function vecU82(property) {
        const length = (0, buffer_layout_1.u32)("length");
        const layout = (0, buffer_layout_1.struct)([
          length,
          (0, buffer_layout_1.blob)((0, buffer_layout_1.offset)(length, -length.span), "data")
        ]);
        return new WrappedLayout2(layout, ({ data }) => data, (data) => ({ data }), property);
      }
      exports.vecU8 = vecU82;
      function str2(property) {
        return new WrappedLayout2(vecU82(), (data) => data.toString("utf-8"), (s) => Buffer.from(s, "utf-8"), property);
      }
      exports.str = str2;
      function rustEnum2(variants, property, discriminant) {
        const unionLayout = (0, buffer_layout_1.union)(discriminant !== null && discriminant !== void 0 ? discriminant : (0, buffer_layout_1.u8)(), property);
        variants.forEach((variant, index2) => unionLayout.addVariant(index2, variant, variant.property));
        return unionLayout;
      }
      exports.rustEnum = rustEnum2;
      function array3(elementLayout, length, property) {
        const layout = (0, buffer_layout_1.struct)([
          (0, buffer_layout_1.seq)(elementLayout, length, "values")
        ]);
        return new WrappedLayout2(layout, ({ values }) => values, (values) => ({ values }), property);
      }
      exports.array = array3;
      var MapEntryLayout = class extends buffer_layout_1.Layout {
        constructor(keyLayout, valueLayout, property) {
          super(keyLayout.span + valueLayout.span, property);
          this.keyLayout = keyLayout;
          this.valueLayout = valueLayout;
        }
        decode(b, offset2) {
          offset2 = offset2 || 0;
          const key = this.keyLayout.decode(b, offset2);
          const value = this.valueLayout.decode(b, offset2 + this.keyLayout.getSpan(b, offset2));
          return [key, value];
        }
        encode(src, b, offset2) {
          offset2 = offset2 || 0;
          const keyBytes = this.keyLayout.encode(src[0], b, offset2);
          const valueBytes = this.valueLayout.encode(src[1], b, offset2 + keyBytes);
          return keyBytes + valueBytes;
        }
        getSpan(b, offset2) {
          return this.keyLayout.getSpan(b, offset2) + this.valueLayout.getSpan(b, offset2);
        }
      };
      function map(keyLayout, valueLayout, property) {
        const length = (0, buffer_layout_1.u32)("length");
        const layout = (0, buffer_layout_1.struct)([
          length,
          (0, buffer_layout_1.seq)(new MapEntryLayout(keyLayout, valueLayout), (0, buffer_layout_1.offset)(length, -length.span), "values")
        ]);
        return new WrappedLayout2(layout, ({ values }) => new Map(values), (values) => ({ values: Array.from(values.entries()) }), property);
      }
      exports.map = map;
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter32 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0) return names;
        for (name in events = this._events) {
          if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // node_modules/@coral-xyz/anchor/dist/browser/index.js
  var index_exports = {};
  __export(index_exports, {
    AccountClient: () => AccountClient,
    AnchorError: () => AnchorError,
    AnchorProvider: () => AnchorProvider,
    BN: () => import_bn2.default,
    BorshAccountsCoder: () => BorshAccountsCoder,
    BorshCoder: () => BorshCoder,
    BorshEventCoder: () => BorshEventCoder,
    BorshInstructionCoder: () => BorshInstructionCoder,
    DISCRIMINATOR_SIZE: () => DISCRIMINATOR_SIZE,
    EventManager: () => EventManager,
    EventParser: () => EventParser,
    IdlError: () => IdlError,
    LangErrorCode: () => LangErrorCode,
    LangErrorMessage: () => LangErrorMessage,
    MethodsBuilderFactory: () => MethodsBuilderFactory,
    Native: () => Native,
    Program: () => Program,
    ProgramError: () => ProgramError,
    ProgramErrorStack: () => ProgramErrorStack,
    SystemCoder: () => SystemCoder,
    getProvider: () => getProvider,
    parseIdlErrors: () => parseIdlErrors,
    setProvider: () => setProvider,
    splitArgsAndCtx: () => splitArgsAndCtx,
    toInstruction: () => toInstruction,
    translateAddress: () => translateAddress,
    translateError: () => translateError,
    utils: () => index,
    validateAccounts: () => validateAccounts,
    web3: () => web3_js
  });
  var import_buffer = __toESM(require_buffer());
  var import_web3 = __toESM(require_index_browser_cjs());
  var web3_js = __toESM(require_index_browser_cjs());
  var import_bn = __toESM(require_bn());
  var import_bn2 = __toESM(require_bn());
  var import_bs58 = __toESM(require_bs58());
  var import_camelcase = __toESM(require_camelcase());
  var borsh = __toESM(require_dist2());

  // node_modules/@noble/hashes/esm/utils.js
  function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abytes(b, ...lengths) {
    if (!isBytes(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
  }
  function utf8ToBytes(str2) {
    if (typeof str2 !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str2));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    abytes(data);
    return data;
  }
  var Hash = class {
  };
  function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }

  // node_modules/@noble/hashes/esm/_md.js
  function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
  }
  function Chi(a, b, c) {
    return a & b ^ ~a & c;
  }
  function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }
  var HashMD = class extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      aexists(this);
      data = toBytes(data);
      abytes(data);
      const { view, buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      clean(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length;
      to.pos = pos;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);

  // node_modules/@noble/hashes/esm/sha2.js
  var SHA256_K = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA256 = class extends HashMD {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset2) {
      for (let i = 0; i < 16; i++, offset2 += 4)
        SHA256_W[i] = view.getUint32(offset2, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      clean(SHA256_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      clean(this.buffer);
    }
  };
  var sha256 = /* @__PURE__ */ createHasher(() => new SHA256());

  // node_modules/@noble/hashes/esm/sha256.js
  var sha2562 = sha256;

  // node_modules/pako/dist/pako.esm.mjs
  var Z_FIXED$1 = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN$1 = 2;
  function zero$1(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH$1 = 3;
  var MAX_MATCH$1 = 258;
  var LENGTH_CODES$1 = 29;
  var LITERALS$1 = 256;
  var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
  var D_CODES$1 = 30;
  var BL_CODES$1 = 19;
  var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
  var MAX_BITS$1 = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = (
    /* extra bits for each length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
  );
  var extra_dbits = (
    /* extra bits for each distance code */
    new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
  );
  var extra_blbits = (
    /* extra bits for each bit length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
  );
  var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES$1 + 2) * 2);
  zero$1(static_ltree);
  var static_dtree = new Array(D_CODES$1 * 2);
  zero$1(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero$1(_dist_code);
  var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
  zero$1(_length_code);
  var base_length = new Array(LENGTH_CODES$1);
  zero$1(base_length);
  var base_dist = new Array(D_CODES$1);
  zero$1(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  var d_code = (dist2) => {
    return dist2 < 256 ? _dist_code[dist2] : _dist_code[256 + (dist2 >>> 7)];
  };
  var put_short = (s, w) => {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  };
  var send_bits = (s, value, length) => {
    if (s.bi_valid > Buf_size - length) {
      s.bi_buf |= value << s.bi_valid & 65535;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> Buf_size - s.bi_valid;
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= value << s.bi_valid & 65535;
      s.bi_valid += length;
    }
  };
  var send_code = (s, c, tree) => {
    send_bits(
      s,
      tree[c * 2],
      tree[c * 2 + 1]
      /*.Len*/
    );
  };
  var bi_reverse = (code, len) => {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  };
  var bi_flush = (s) => {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  };
  var gen_bitlen = (s, desc) => {
    const tree = desc.dyn_tree;
    const max_code = desc.max_code;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const extra = desc.stat_desc.extra_bits;
    const base = desc.stat_desc.extra_base;
    const max_length = desc.stat_desc.max_length;
    let h;
    let n, m;
    let bits;
    let xbits;
    let f2;
    let overflow = 0;
    for (bits = 0; bits <= MAX_BITS$1; bits++) {
      s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > max_code) {
        continue;
      }
      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base) {
        xbits = extra[n - base];
      }
      f2 = tree[n * 2];
      s.opt_len += f2 * (bits + xbits);
      if (has_stree) {
        s.static_len += f2 * (stree[n * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0) {
        bits--;
      }
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > max_code) {
          continue;
        }
        if (tree[m * 2 + 1] !== bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n--;
      }
    }
  };
  var gen_codes = (tree, max_code, bl_count) => {
    const next_code = new Array(MAX_BITS$1 + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= MAX_BITS$1; bits++) {
      code = code + bl_count[bits - 1] << 1;
      next_code[bits] = code;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  };
  var tr_static_init = () => {
    let n;
    let bits;
    let length;
    let code;
    let dist2;
    const bl_count = new Array(MAX_BITS$1 + 1);
    length = 0;
    for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
      base_length[code] = length;
      for (n = 0; n < 1 << extra_lbits[code]; n++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist2 = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist2;
      for (n = 0; n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist2++] = code;
      }
    }
    dist2 >>= 7;
    for (; code < D_CODES$1; code++) {
      base_dist[code] = dist2 << 7;
      for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist2++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS$1; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
    for (n = 0; n < D_CODES$1; n++) {
      static_dtree[n * 2 + 1] = 5;
      static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
  };
  var init_block = (s) => {
    let n;
    for (n = 0; n < L_CODES$1; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < D_CODES$1; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < BL_CODES$1; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.sym_next = s.matches = 0;
  };
  var bi_windup = (s) => {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  };
  var smaller = (tree, n, m, depth) => {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  };
  var pqdownheap = (s, tree, k) => {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  };
  var compress_block = (s, ltree, dtree) => {
    let dist2;
    let lc;
    let sx = 0;
    let code;
    let extra;
    if (s.sym_next !== 0) {
      do {
        dist2 = s.pending_buf[s.sym_buf + sx++] & 255;
        dist2 += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
        lc = s.pending_buf[s.sym_buf + sx++];
        if (dist2 === 0) {
          send_code(s, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s, code + LITERALS$1 + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
          }
          dist2--;
          code = d_code(dist2);
          send_code(s, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist2 -= base_dist[code];
            send_bits(s, dist2, extra);
          }
        }
      } while (sx < s.sym_next);
    }
    send_code(s, END_BLOCK, ltree);
  };
  var build_tree = (s, desc) => {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE$1;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[
        1
        /*SMALLEST*/
      ] = s.heap[s.heap_len--];
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
      m = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[
        1
        /*SMALLEST*/
      ] = node++;
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[
      1
      /*SMALLEST*/
    ];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
  };
  var scan_tree = (s, tree, max_code) => {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };
  var send_tree = (s, tree, max_code) => {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count--;
        }
        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };
  var build_bl_tree = (s) => {
    let max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  };
  var send_all_trees = (s, lcodes, dcodes, blcodes) => {
    let rank2;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for (rank2 = 0; rank2 < blcodes; rank2++) {
      send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
  };
  var detect_data_type = (s) => {
    let block_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, block_mask >>>= 1) {
      if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n = 32; n < LITERALS$1; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  };
  var static_init_done = false;
  var _tr_init$1 = (s) => {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
  };
  var _tr_stored_block$1 = (s, buf, stored_len, last) => {
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    bi_windup(s);
    put_short(s, stored_len);
    put_short(s, ~stored_len);
    if (stored_len) {
      s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
    }
    s.pending += stored_len;
  };
  var _tr_align$1 = (s) => {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  };
  var _tr_flush_block$1 = (s, buf, stored_len, last) => {
    let opt_lenb, static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === Z_UNKNOWN$1) {
        s.strm.data_type = detect_data_type(s);
      }
      build_tree(s, s.l_desc);
      build_tree(s, s.d_desc);
      max_blindex = build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block$1(s, buf, stored_len, last);
    } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last) {
      bi_windup(s);
    }
  };
  var _tr_tally$1 = (s, dist2, lc) => {
    s.pending_buf[s.sym_buf + s.sym_next++] = dist2;
    s.pending_buf[s.sym_buf + s.sym_next++] = dist2 >> 8;
    s.pending_buf[s.sym_buf + s.sym_next++] = lc;
    if (dist2 === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist2--;
      s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
      s.dyn_dtree[d_code(dist2) * 2]++;
    }
    return s.sym_next === s.sym_end;
  };
  var _tr_init_1 = _tr_init$1;
  var _tr_stored_block_1 = _tr_stored_block$1;
  var _tr_flush_block_1 = _tr_flush_block$1;
  var _tr_tally_1 = _tr_tally$1;
  var _tr_align_1 = _tr_align$1;
  var trees = {
    _tr_init: _tr_init_1,
    _tr_stored_block: _tr_stored_block_1,
    _tr_flush_block: _tr_flush_block_1,
    _tr_tally: _tr_tally_1,
    _tr_align: _tr_align_1
  };
  var adler32 = (adler, buf, len, pos) => {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  };
  var adler32_1 = adler32;
  var makeTable = () => {
    let c, table = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  };
  var crcTable = new Uint32Array(makeTable());
  var crc32 = (crc, buf, len, pos) => {
    const t = crcTable;
    const end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  };
  var crc32_1 = crc32;
  var messages = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  var constants$2 = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
  var {
    Z_NO_FLUSH: Z_NO_FLUSH$2,
    Z_PARTIAL_FLUSH,
    Z_FULL_FLUSH: Z_FULL_FLUSH$1,
    Z_FINISH: Z_FINISH$3,
    Z_BLOCK: Z_BLOCK$1,
    Z_OK: Z_OK$3,
    Z_STREAM_END: Z_STREAM_END$3,
    Z_STREAM_ERROR: Z_STREAM_ERROR$2,
    Z_DATA_ERROR: Z_DATA_ERROR$2,
    Z_BUF_ERROR: Z_BUF_ERROR$1,
    Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
    Z_FILTERED,
    Z_HUFFMAN_ONLY,
    Z_RLE,
    Z_FIXED,
    Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
    Z_UNKNOWN,
    Z_DEFLATED: Z_DEFLATED$2
  } = constants$2;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS$1 = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var GZIP_STATE = 57;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  var err = (strm, errorCode) => {
    strm.msg = messages[errorCode];
    return errorCode;
  };
  var rank = (f2) => {
    return f2 * 2 - (f2 > 4 ? 9 : 0);
  };
  var zero = (buf) => {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  };
  var slide_hash = (s) => {
    let n, m;
    let p;
    let wsize = s.w_size;
    n = s.hash_size;
    p = n;
    do {
      m = s.head[--p];
      s.head[p] = m >= wsize ? m - wsize : 0;
    } while (--n);
    n = wsize;
    p = n;
    do {
      m = s.prev[--p];
      s.prev[p] = m >= wsize ? m - wsize : 0;
    } while (--n);
  };
  var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
  var HASH = HASH_ZLIB;
  var flush_pending = (strm) => {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  };
  var flush_block_only = (s, last) => {
    _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
  };
  var put_byte = (s, b) => {
    s.pending_buf[s.pending++] = b;
  };
  var putShortMSB = (s, b) => {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  };
  var read_buf = (strm, buf, start, size) => {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32_1(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32_1(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  };
  var longest_match = (s, cur_match) => {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  };
  var fill_window = (s) => {
    const _w_size = s.w_size;
    let n, more, str2;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
        slide_hash(s);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= MIN_MATCH) {
        str2 = s.strstart - s.insert;
        s.ins_h = s.window[str2];
        s.ins_h = HASH(s, s.ins_h, s.window[str2 + 1]);
        while (s.insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[str2 + MIN_MATCH - 1]);
          s.prev[str2 & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str2;
          str2++;
          s.insert--;
          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  };
  var deflate_stored = (s, flush) => {
    let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
    let len, left, have, last = 0;
    let used = s.strm.avail_in;
    do {
      len = 65535;
      have = s.bi_valid + 42 >> 3;
      if (s.strm.avail_out < have) {
        break;
      }
      have = s.strm.avail_out - have;
      left = s.strstart - s.block_start;
      if (len > left + s.strm.avail_in) {
        len = left + s.strm.avail_in;
      }
      if (len > have) {
        len = have;
      }
      if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
        break;
      }
      last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
      _tr_stored_block(s, 0, 0, last);
      s.pending_buf[s.pending - 4] = len;
      s.pending_buf[s.pending - 3] = len >> 8;
      s.pending_buf[s.pending - 2] = ~len;
      s.pending_buf[s.pending - 1] = ~len >> 8;
      flush_pending(s.strm);
      if (left) {
        if (left > len) {
          left = len;
        }
        s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
        s.strm.next_out += left;
        s.strm.avail_out -= left;
        s.strm.total_out += left;
        s.block_start += left;
        len -= left;
      }
      if (len) {
        read_buf(s.strm, s.strm.output, s.strm.next_out, len);
        s.strm.next_out += len;
        s.strm.avail_out -= len;
        s.strm.total_out += len;
      }
    } while (last === 0);
    used -= s.strm.avail_in;
    if (used) {
      if (used >= s.w_size) {
        s.matches = 2;
        s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
        s.strstart = s.w_size;
        s.insert = s.strstart;
      } else {
        if (s.window_size - s.strstart <= used) {
          s.strstart -= s.w_size;
          s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
          if (s.matches < 2) {
            s.matches++;
          }
          if (s.insert > s.strstart) {
            s.insert = s.strstart;
          }
        }
        s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
        s.strstart += used;
        s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
      }
      s.block_start = s.strstart;
    }
    if (s.high_water < s.strstart) {
      s.high_water = s.strstart;
    }
    if (last) {
      return BS_FINISH_DONE;
    }
    if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
      return BS_BLOCK_DONE;
    }
    have = s.window_size - s.strstart;
    if (s.strm.avail_in > have && s.block_start >= s.w_size) {
      s.block_start -= s.w_size;
      s.strstart -= s.w_size;
      s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
      if (s.matches < 2) {
        s.matches++;
      }
      have += s.w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
    }
    if (have > s.strm.avail_in) {
      have = s.strm.avail_in;
    }
    if (have) {
      read_buf(s.strm, s.window, s.strstart, have);
      s.strstart += have;
      s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
    }
    if (s.high_water < s.strstart) {
      s.high_water = s.strstart;
    }
    have = s.bi_valid + 42 >> 3;
    have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
    min_block = have > s.w_size ? s.w_size : have;
    left = s.strstart - s.block_start;
    if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
      len = left > have ? have : left;
      last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
      _tr_stored_block(s, s.block_start, len, last);
      s.block_start += len;
      flush_pending(s.strm);
    }
    return last ? BS_FINISH_STARTED : BS_NEED_MORE;
  };
  var deflate_fast = (s, flush) => {
    let hash_head;
    let bflush;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
          s.match_length--;
          do {
            s.strstart++;
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          } while (--s.match_length !== 0);
          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
        }
      } else {
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH$3) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.sym_next) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var deflate_slow = (s, flush) => {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH$3) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.sym_next) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var deflate_rle = (s, flush) => {
    let bflush;
    let prev;
    let scan, strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);
        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH$3) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.sym_next) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var deflate_huff = (s, flush) => {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        fill_window(s);
        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH$3) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.sym_next) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  var lm_init = (s) => {
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  };
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED$2;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(MAX_BITS + 1);
    this.heap = new Uint16Array(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * L_CODES + 1);
    zero(this.depth);
    this.sym_buf = 0;
    this.lit_bufsize = 0;
    this.sym_next = 0;
    this.sym_end = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  var deflateStateCheck = (strm) => {
    if (!strm) {
      return 1;
    }
    const s = strm.state;
    if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
    s.status !== GZIP_STATE && //#endif
    s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
      return 1;
    }
    return 0;
  };
  var deflateResetKeep = (strm) => {
    if (deflateStateCheck(strm)) {
      return err(strm, Z_STREAM_ERROR$2);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    const s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = //#ifdef GZIP
    s.wrap === 2 ? GZIP_STATE : (
      //#endif
      s.wrap ? INIT_STATE : BUSY_STATE
    );
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = -2;
    _tr_init(s);
    return Z_OK$3;
  };
  var deflateReset = (strm) => {
    const ret = deflateResetKeep(strm);
    if (ret === Z_OK$3) {
      lm_init(strm.state);
    }
    return ret;
  };
  var deflateSetHeader = (strm, head) => {
    if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
      return Z_STREAM_ERROR$2;
    }
    strm.state.gzhead = head;
    return Z_OK$3;
  };
  var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
    if (!strm) {
      return Z_STREAM_ERROR$2;
    }
    let wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION$1) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
      return err(strm, Z_STREAM_ERROR$2);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new DeflateState();
    strm.state = s;
    s.strm = strm;
    s.status = INIT_STATE;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.sym_buf = s.lit_bufsize;
    s.sym_end = (s.lit_bufsize - 1) * 3;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
  };
  var deflateInit = (strm, level) => {
    return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
  };
  var deflate$2 = (strm, flush) => {
    if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
    }
    const s = strm.state;
    if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
    }
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
      return err(strm, Z_BUF_ERROR$1);
    }
    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR$1);
    }
    if (s.status === INIT_STATE && s.wrap === 0) {
      s.status = BUSY_STATE;
    }
    if (s.status === INIT_STATE) {
      let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
      let level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      putShortMSB(s, header);
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      strm.adler = 1;
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
    if (s.status === GZIP_STATE) {
      strm.adler = 0;
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      } else {
        put_byte(
          s,
          (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 255);
        put_byte(s, s.gzhead.time >> 8 & 255);
        put_byte(s, s.gzhead.time >> 16 & 255);
        put_byte(s, s.gzhead.time >> 24 & 255);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 255);
          put_byte(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra) {
        let beg = s.pending;
        let left = (s.gzhead.extra.length & 65535) - s.gzindex;
        while (s.pending + left > s.pending_buf_size) {
          let copy = s.pending_buf_size - s.pending;
          s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
          s.pending = s.pending_buf_size;
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex += copy;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
          left -= copy;
        }
        let gzhead_extra = new Uint8Array(s.gzhead.extra);
        s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
        s.pending += left;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex = 0;
      }
      s.status = NAME_STATE;
    }
    if (s.status === NAME_STATE) {
      if (s.gzhead.name) {
        let beg = s.pending;
        let val;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK$3;
            }
            beg = 0;
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex = 0;
      }
      s.status = COMMENT_STATE;
    }
    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment) {
        let beg = s.pending;
        let val;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK$3;
            }
            beg = 0;
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
      }
      s.status = HCRC_STATE;
    }
    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
        }
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        strm.adler = 0;
      }
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
      let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return Z_OK$3;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          _tr_align(s);
        } else if (flush !== Z_BLOCK$1) {
          _tr_stored_block(s, 0, 0, false);
          if (flush === Z_FULL_FLUSH$1) {
            zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
    }
    if (flush !== Z_FINISH$3) {
      return Z_OK$3;
    }
    if (s.wrap <= 0) {
      return Z_STREAM_END$3;
    }
    if (s.wrap === 2) {
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      put_byte(s, strm.adler >> 16 & 255);
      put_byte(s, strm.adler >> 24 & 255);
      put_byte(s, strm.total_in & 255);
      put_byte(s, strm.total_in >> 8 & 255);
      put_byte(s, strm.total_in >> 16 & 255);
      put_byte(s, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
  };
  var deflateEnd = (strm) => {
    if (deflateStateCheck(strm)) {
      return Z_STREAM_ERROR$2;
    }
    const status = strm.state.status;
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
  };
  var deflateSetDictionary = (strm, dictionary) => {
    let dictLength = dictionary.length;
    if (deflateStateCheck(strm)) {
      return Z_STREAM_ERROR$2;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR$2;
    }
    if (wrap === 1) {
      strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while (s.lookahead >= MIN_MATCH) {
      let str2 = s.strstart;
      let n = s.lookahead - (MIN_MATCH - 1);
      do {
        s.ins_h = HASH(s, s.ins_h, s.window[str2 + MIN_MATCH - 1]);
        s.prev[str2 & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str2;
        str2++;
      } while (--n);
      s.strstart = str2;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK$3;
  };
  var deflateInit_1 = deflateInit;
  var deflateInit2_1 = deflateInit2;
  var deflateReset_1 = deflateReset;
  var deflateResetKeep_1 = deflateResetKeep;
  var deflateSetHeader_1 = deflateSetHeader;
  var deflate_2$1 = deflate$2;
  var deflateEnd_1 = deflateEnd;
  var deflateSetDictionary_1 = deflateSetDictionary;
  var deflateInfo = "pako deflate (from Nodeca project)";
  var deflate_1$2 = {
    deflateInit: deflateInit_1,
    deflateInit2: deflateInit2_1,
    deflateReset: deflateReset_1,
    deflateResetKeep: deflateResetKeep_1,
    deflateSetHeader: deflateSetHeader_1,
    deflate: deflate_2$1,
    deflateEnd: deflateEnd_1,
    deflateSetDictionary: deflateSetDictionary_1,
    deflateInfo
  };
  var _has = (obj, key) => {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };
  var assign = function(obj) {
    const sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      const source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (const p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  var flattenChunks = (chunks2) => {
    let len = 0;
    for (let i = 0, l = chunks2.length; i < l; i++) {
      len += chunks2[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks2.length; i < l; i++) {
      let chunk = chunks2[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  };
  var common = {
    assign,
    flattenChunks
  };
  var STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  var _utf8len = new Uint8Array(256);
  for (let q = 0; q < 256; q++) {
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  _utf8len[254] = _utf8len[254] = 1;
  var string2buf = (str2) => {
    if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
      return new TextEncoder().encode(str2);
    }
    let buf, c, c2, m_pos, i, str_len = str2.length, buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str2.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str2.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str2.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str2.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  };
  var buf2binstring = (buf, len) => {
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK) {
        return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
      }
    }
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  };
  var buf2string = (buf, max) => {
    const len = max || buf.length;
    if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
      return new TextDecoder().decode(buf.subarray(0, max));
    }
    let i, out;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = _utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  var utf8border = (buf, max) => {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + _utf8len[buf[pos]] > max ? pos : max;
  };
  var strings = {
    string2buf,
    buf2string,
    utf8border
  };
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  var zstream = ZStream;
  var toString$1 = Object.prototype.toString;
  var {
    Z_NO_FLUSH: Z_NO_FLUSH$1,
    Z_SYNC_FLUSH,
    Z_FULL_FLUSH,
    Z_FINISH: Z_FINISH$2,
    Z_OK: Z_OK$2,
    Z_STREAM_END: Z_STREAM_END$2,
    Z_DEFAULT_COMPRESSION,
    Z_DEFAULT_STRATEGY,
    Z_DEFLATED: Z_DEFLATED$1
  } = constants$2;
  function Deflate$1(options) {
    this.options = common.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED$1,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY
    }, options || {});
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    let status = deflate_1$2.deflateInit2(
      this.strm,
      opt.level,
      opt.method,
      opt.windowBits,
      opt.memLevel,
      opt.strategy
    );
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    if (opt.header) {
      deflate_1$2.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = strings.string2buf(opt.dictionary);
      } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = deflate_1$2.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK$2) {
        throw new Error(messages[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate$1.prototype.push = function(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status, _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
    if (typeof data === "string") {
      strm.input = strings.string2buf(data);
    } else if (toString$1.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = deflate_1$2.deflate(strm, _flush_mode);
      if (status === Z_STREAM_END$2) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = deflate_1$2.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK$2;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0) break;
    }
    return true;
  };
  Deflate$1.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate$1.prototype.onEnd = function(status) {
    if (status === Z_OK$2) {
      this.result = common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate$1(input, options) {
    const deflator = new Deflate$1(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || messages[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return deflate$1(input, options);
  }
  function gzip$1(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate$1(input, options);
  }
  var Deflate_1$1 = Deflate$1;
  var deflate_2 = deflate$1;
  var deflateRaw_1$1 = deflateRaw$1;
  var gzip_1$1 = gzip$1;
  var constants$1 = constants$2;
  var deflate_1$1 = {
    Deflate: Deflate_1$1,
    deflate: deflate_2,
    deflateRaw: deflateRaw_1$1,
    gzip: gzip_1$1,
    constants: constants$1
  };
  var BAD$1 = 16209;
  var TYPE$1 = 16191;
  var inffast = function inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let dmax;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist2;
    let from;
    let from_source;
    let input, output;
    const state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist2 = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist2 += hold & (1 << op) - 1;
                    if (dist2 > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD$1;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist2 > op) {
                      op = dist2 - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD$1;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist2;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist2;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist2;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist2;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD$1;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE$1;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD$1;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
  var MAXBITS = 15;
  var ENOUGH_LENS$1 = 852;
  var ENOUGH_DISTS$1 = 592;
  var CODES$1 = 0;
  var LENS$1 = 1;
  var DISTS$1 = 2;
  var lbase = new Uint16Array([
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ]);
  var lext = new Uint8Array([
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ]);
  var dbase = new Uint16Array([
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ]);
  var dext = new Uint8Array([
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ]);
  var inflate_table = (type2, lens, lens_index, codes, table, table_index, work, opts) => {
    const bits = opts.bits;
    let len = 0;
    let sym = 0;
    let min = 0, max = 0;
    let root = 0;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask2;
    let next;
    let base = null;
    let match;
    const count = new Uint16Array(MAXBITS + 1);
    const offs = new Uint16Array(MAXBITS + 1);
    let extra = null;
    let here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type2 === CODES$1 || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type2 === CODES$1) {
      base = extra = work;
      match = 20;
    } else if (type2 === LENS$1) {
      base = lbase;
      extra = lext;
      match = 257;
    } else {
      base = dbase;
      extra = dext;
      match = 0;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask2 = used - 1;
    if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] + 1 < match) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] >= match) {
        here_op = extra[work[sym] - match];
        here_val = base[work[sym] - match];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask2) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
          return 1;
        }
        low = huff & mask2;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
  var inftrees = inflate_table;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var {
    Z_FINISH: Z_FINISH$1,
    Z_BLOCK,
    Z_TREES,
    Z_OK: Z_OK$1,
    Z_STREAM_END: Z_STREAM_END$1,
    Z_NEED_DICT: Z_NEED_DICT$1,
    Z_STREAM_ERROR: Z_STREAM_ERROR$1,
    Z_DATA_ERROR: Z_DATA_ERROR$1,
    Z_MEM_ERROR: Z_MEM_ERROR$1,
    Z_BUF_ERROR,
    Z_DEFLATED
  } = constants$2;
  var HEAD = 16180;
  var FLAGS = 16181;
  var TIME = 16182;
  var OS = 16183;
  var EXLEN = 16184;
  var EXTRA = 16185;
  var NAME = 16186;
  var COMMENT = 16187;
  var HCRC = 16188;
  var DICTID = 16189;
  var DICT = 16190;
  var TYPE = 16191;
  var TYPEDO = 16192;
  var STORED = 16193;
  var COPY_ = 16194;
  var COPY = 16195;
  var TABLE = 16196;
  var LENLENS = 16197;
  var CODELENS = 16198;
  var LEN_ = 16199;
  var LEN = 16200;
  var LENEXT = 16201;
  var DIST = 16202;
  var DISTEXT = 16203;
  var MATCH = 16204;
  var LIT = 16205;
  var CHECK = 16206;
  var LENGTH = 16207;
  var DONE = 16208;
  var BAD = 16209;
  var MEM = 16210;
  var SYNC = 16211;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  var zswap32 = (q) => {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  };
  function InflateState() {
    this.strm = null;
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  var inflateStateCheck = (strm) => {
    if (!strm) {
      return 1;
    }
    const state = strm.state;
    if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
      return 1;
    }
    return 0;
  };
  var inflateResetKeep = (strm) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.flags = -1;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK$1;
  };
  var inflateReset = (strm) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  };
  var inflateReset2 = (strm, windowBits) => {
    let wrap;
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 5;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR$1;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  };
  var inflateInit2 = (strm, windowBits) => {
    if (!strm) {
      return Z_STREAM_ERROR$1;
    }
    const state = new InflateState();
    strm.state = state;
    state.strm = strm;
    state.window = null;
    state.mode = HEAD;
    const ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK$1) {
      strm.state = null;
    }
    return ret;
  };
  var inflateInit = (strm) => {
    return inflateInit2(strm, DEF_WBITS);
  };
  var virgin = true;
  var lenfix;
  var distfix;
  var fixedtables = (state) => {
    if (virgin) {
      lenfix = new Int32Array(512);
      distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  };
  var updatewindow = (strm, src, end, copy) => {
    let dist2;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist2 = state.wsize - state.wnext;
      if (dist2 > copy) {
        dist2 = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist2), state.wnext);
      copy -= dist2;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist2;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist2;
        }
      }
    }
    return 0;
  };
  var inflate$2 = (strm, flush) => {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in, _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits, here_op, here_val;
    let last_bits, last_op, last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    const order = (
      /* permutation of code lengths */
      new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
    );
    if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR$1;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK$1;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              if (state.wbits === 0) {
                state.wbits = 15;
              }
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            }
            if (len > 15 || len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            state.flags = 0;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          /* falls through */
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32_1(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          /* falls through */
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          /* falls through */
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          /* falls through */
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(
                    input.subarray(
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      next + copy
                    ),
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32_1(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          /* falls through */
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          /* falls through */
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          /* falls through */
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 4 && hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          /* falls through */
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT$1;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          /* falls through */
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case COPY_:
            state.mode = COPY;
          /* falls through */
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          /* falls through */
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          /* falls through */
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case LEN_:
            state.mode = LEN;
          /* falls through */
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inffast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          /* falls through */
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          /* falls through */
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          /* falls through */
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          /* falls through */
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (state.wrap & 4 && _out) {
                strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
              }
              _out = left;
              if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          /* falls through */
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          /* falls through */
          case DONE:
            ret = Z_STREAM_END$1;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR$1;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR$1;
          case SYNC:
          /* falls through */
          default:
            return Z_STREAM_ERROR$1;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap & 4 && _out) {
      strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
      state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  };
  var inflateEnd = (strm) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK$1;
  };
  var inflateGetHeader = (strm, head) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR$1;
    }
    state.head = head;
    head.done = false;
    return Z_OK$1;
  };
  var inflateSetDictionary = (strm, dictionary) => {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR$1;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32_1(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR$1;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR$1;
    }
    state.havedict = 1;
    return Z_OK$1;
  };
  var inflateReset_1 = inflateReset;
  var inflateReset2_1 = inflateReset2;
  var inflateResetKeep_1 = inflateResetKeep;
  var inflateInit_1 = inflateInit;
  var inflateInit2_1 = inflateInit2;
  var inflate_2$1 = inflate$2;
  var inflateEnd_1 = inflateEnd;
  var inflateGetHeader_1 = inflateGetHeader;
  var inflateSetDictionary_1 = inflateSetDictionary;
  var inflateInfo = "pako inflate (from Nodeca project)";
  var inflate_1$2 = {
    inflateReset: inflateReset_1,
    inflateReset2: inflateReset2_1,
    inflateResetKeep: inflateResetKeep_1,
    inflateInit: inflateInit_1,
    inflateInit2: inflateInit2_1,
    inflate: inflate_2$1,
    inflateEnd: inflateEnd_1,
    inflateGetHeader: inflateGetHeader_1,
    inflateSetDictionary: inflateSetDictionary_1,
    inflateInfo
  };
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  var gzheader = GZheader;
  var toString = Object.prototype.toString;
  var {
    Z_NO_FLUSH,
    Z_FINISH,
    Z_OK,
    Z_STREAM_END,
    Z_NEED_DICT,
    Z_STREAM_ERROR,
    Z_DATA_ERROR,
    Z_MEM_ERROR
  } = constants$2;
  function Inflate$1(options) {
    this.options = common.assign({
      chunkSize: 1024 * 64,
      windowBits: 15,
      to: ""
    }, options || {});
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    let status = inflate_1$2.inflateInit2(
      this.strm,
      opt.windowBits
    );
    if (status !== Z_OK) {
      throw new Error(messages[status]);
    }
    this.header = new gzheader();
    inflate_1$2.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== Z_OK) {
          throw new Error(messages[status]);
        }
      }
    }
  }
  Inflate$1.prototype.push = function(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status, _flush_mode, last_avail_out;
    if (this.ended) return false;
    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = inflate_1$2.inflate(strm, _flush_mode);
      if (status === Z_NEED_DICT && dictionary) {
        status = inflate_1$2.inflateSetDictionary(strm, dictionary);
        if (status === Z_OK) {
          status = inflate_1$2.inflate(strm, _flush_mode);
        } else if (status === Z_DATA_ERROR) {
          status = Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        inflate_1$2.inflateReset(strm);
        status = inflate_1$2.inflate(strm, _flush_mode);
      }
      switch (status) {
        case Z_STREAM_ERROR:
        case Z_DATA_ERROR:
        case Z_NEED_DICT:
        case Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === Z_OK && last_avail_out === 0) continue;
      if (status === Z_STREAM_END) {
        status = inflate_1$2.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0) break;
    }
    return true;
  };
  Inflate$1.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate$1.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function inflate$1(input, options) {
    const inflator = new Inflate$1(options);
    inflator.push(input);
    if (inflator.err) throw inflator.msg || messages[inflator.err];
    return inflator.result;
  }
  function inflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return inflate$1(input, options);
  }
  var Inflate_1$1 = Inflate$1;
  var inflate_2 = inflate$1;
  var inflateRaw_1$1 = inflateRaw$1;
  var ungzip$1 = inflate$1;
  var constants = constants$2;
  var inflate_1$1 = {
    Inflate: Inflate_1$1,
    inflate: inflate_2,
    inflateRaw: inflateRaw_1$1,
    ungzip: ungzip$1,
    constants
  };
  var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
  var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
  var inflate_1 = inflate;

  // node_modules/@coral-xyz/anchor/dist/browser/index.js
  var import_eventemitter3 = __toESM(require_eventemitter32());
  function chunks(array3, size) {
    return Array.apply(0, new Array(Math.ceil(array3.length / size))).map((_, index2) => array3.slice(index2 * size, (index2 + 1) * size));
  }
  var isVersionedTransaction = (tx) => {
    return "version" in tx;
  };
  function encode$3(data) {
    return data.reduce((str2, byte) => str2 + byte.toString(16).padStart(2, "0"), "0x");
  }
  function decode$3(data) {
    if (data.indexOf("0x") === 0) {
      data = data.substr(2);
    }
    if (data.length % 2 === 1) {
      data = "0" + data;
    }
    let key = data.match(/.{2}/g);
    if (key === null) {
      return import_buffer.Buffer.from([]);
    }
    return import_buffer.Buffer.from(key.map((byte) => parseInt(byte, 16)));
  }
  var hex = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    encode: encode$3,
    decode: decode$3
  });
  function decode$2(array3) {
    const decoder = new TextDecoder("utf-8");
    return decoder.decode(array3);
  }
  function encode$2(input) {
    const encoder = new TextEncoder();
    return encoder.encode(input);
  }
  var utf8 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    decode: decode$2,
    encode: encode$2
  });
  function encode$1(data) {
    return import_bs58.default.encode(data);
  }
  function decode$1(data) {
    return import_bs58.default.decode(data);
  }
  var bs58 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    encode: encode$1,
    decode: decode$1
  });
  function encode(data) {
    return data.toString("base64");
  }
  function decode(data) {
    return import_buffer.Buffer.from(data, "base64");
  }
  var base64 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    encode,
    decode
  });
  var index$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    hex,
    utf8,
    bs58,
    base64
  });
  function isCompositeAccounts(accountItem) {
    return "accounts" in accountItem;
  }
  async function idlAddress(programId) {
    const base = (await import_web3.PublicKey.findProgramAddress([], programId))[0];
    return await import_web3.PublicKey.createWithSeed(base, seed(), programId);
  }
  function seed() {
    return "anchor:idl";
  }
  var IDL_ACCOUNT_LAYOUT = borsh.struct([
    borsh.publicKey("authority"),
    borsh.vecU8("data")
  ]);
  function decodeIdlAccount(data) {
    return IDL_ACCOUNT_LAYOUT.decode(data);
  }
  function convertIdlToCamelCase(idl) {
    const KEYS_TO_CONVERT = ["name", "path", "account", "relations", "generic"];
    const toCamelCase = (s) => s.split(".").map(import_camelcase.default).join(".");
    const recursivelyConvertNamesToCamelCase = (obj) => {
      for (const key in obj) {
        const val = obj[key];
        if (KEYS_TO_CONVERT.includes(key)) {
          obj[key] = Array.isArray(val) ? val.map(toCamelCase) : toCamelCase(val);
        } else if (typeof val === "object") {
          recursivelyConvertNamesToCamelCase(val);
        }
      }
    };
    const camelCasedIdl = structuredClone(idl);
    recursivelyConvertNamesToCamelCase(camelCasedIdl);
    return camelCasedIdl;
  }
  function handleDefinedFields(fields, unitCb, namedCb, tupleCb) {
    if (!(fields === null || fields === void 0 ? void 0 : fields.length))
      return unitCb();
    if (fields[0].name) {
      return namedCb(fields);
    }
    return tupleCb(fields);
  }
  function parseIdlErrors(idl) {
    const errors = /* @__PURE__ */ new Map();
    if (idl.errors) {
      idl.errors.forEach((e) => {
        var _a;
        let msg = (_a = e.msg) !== null && _a !== void 0 ? _a : e.name;
        errors.set(e.code, msg);
      });
    }
    return errors;
  }
  function toInstruction(idlIx, ...args) {
    if (idlIx.args.length != args.length) {
      throw new Error("Invalid argument length");
    }
    const ix = {};
    let idx = 0;
    idlIx.args.forEach((ixArg) => {
      ix[ixArg.name] = args[idx];
      idx += 1;
    });
    return ix;
  }
  function validateAccounts(ixAccounts, accounts = {}) {
    ixAccounts.forEach((acc) => {
      if (isCompositeAccounts(acc)) {
        validateAccounts(acc.accounts, accounts[acc.name]);
      } else {
        if (!accounts[acc.name]) {
          throw new Error(`Account \`${acc.name}\` not provided.`);
        }
      }
    });
  }
  function translateAddress(address) {
    return address instanceof import_web3.PublicKey ? address : new import_web3.PublicKey(address);
  }
  var StructError = class extends TypeError {
    constructor(failure, failures) {
      let cached;
      const {
        message,
        ...rest
      } = failure;
      const {
        path
      } = failure;
      const msg = path.length === 0 ? message : "At path: " + path.join(".") + " -- " + message;
      super(msg);
      this.value = void 0;
      this.key = void 0;
      this.type = void 0;
      this.refinement = void 0;
      this.path = void 0;
      this.branch = void 0;
      this.failures = void 0;
      Object.assign(this, rest);
      this.name = this.constructor.name;
      this.failures = () => {
        var _cached;
        return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
      };
    }
  };
  function isIterable(x) {
    return isObject(x) && typeof x[Symbol.iterator] === "function";
  }
  function isObject(x) {
    return typeof x === "object" && x != null;
  }
  function print(value) {
    return typeof value === "string" ? JSON.stringify(value) : "" + value;
  }
  function shiftIterator(input) {
    const {
      done,
      value
    } = input.next();
    return done ? void 0 : value;
  }
  function toFailure(result, context, struct3, value) {
    if (result === true) {
      return;
    } else if (result === false) {
      result = {};
    } else if (typeof result === "string") {
      result = {
        message: result
      };
    }
    const {
      path,
      branch
    } = context;
    const {
      type: type2
    } = struct3;
    const {
      refinement,
      message = "Expected a value of type `" + type2 + "`" + (refinement ? " with refinement `" + refinement + "`" : "") + ", but received: `" + print(value) + "`"
    } = result;
    return {
      value,
      type: type2,
      refinement,
      key: path[path.length - 1],
      path,
      branch,
      ...result,
      message
    };
  }
  function* toFailures(result, context, struct3, value) {
    if (!isIterable(result)) {
      result = [result];
    }
    for (const r of result) {
      const failure = toFailure(r, context, struct3, value);
      if (failure) {
        yield failure;
      }
    }
  }
  function* run(value, struct3, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      path = [],
      branch = [value],
      coerce: coerce2 = false,
      mask: mask2 = false
    } = options;
    const ctx = {
      path,
      branch
    };
    if (coerce2) {
      value = struct3.coercer(value, ctx);
      if (mask2 && struct3.type !== "type" && isObject(struct3.schema) && isObject(value) && !Array.isArray(value)) {
        for (const key in value) {
          if (struct3.schema[key] === void 0) {
            delete value[key];
          }
        }
      }
    }
    let valid = true;
    for (const failure of struct3.validator(value, ctx)) {
      valid = false;
      yield [failure, void 0];
    }
    for (let [k, v, s] of struct3.entries(value, ctx)) {
      const ts = run(v, s, {
        path: k === void 0 ? path : [...path, k],
        branch: k === void 0 ? branch : [...branch, v],
        coerce: coerce2,
        mask: mask2
      });
      for (const t of ts) {
        if (t[0]) {
          valid = false;
          yield [t[0], void 0];
        } else if (coerce2) {
          v = t[1];
          if (k === void 0) {
            value = v;
          } else if (value instanceof Map) {
            value.set(k, v);
          } else if (value instanceof Set) {
            value.add(v);
          } else if (isObject(value)) {
            value[k] = v;
          }
        }
      }
    }
    if (valid) {
      for (const failure of struct3.refiner(value, ctx)) {
        valid = false;
        yield [failure, void 0];
      }
    }
    if (valid) {
      yield [void 0, value];
    }
  }
  var Struct = class {
    constructor(props) {
      this.TYPE = void 0;
      this.type = void 0;
      this.schema = void 0;
      this.coercer = void 0;
      this.validator = void 0;
      this.refiner = void 0;
      this.entries = void 0;
      const {
        type: type2,
        schema,
        validator,
        refiner,
        coercer = (value) => value,
        entries = function* () {
        }
      } = props;
      this.type = type2;
      this.schema = schema;
      this.entries = entries;
      this.coercer = coercer;
      if (validator) {
        this.validator = (value, context) => {
          const result = validator(value, context);
          return toFailures(result, context, this, value);
        };
      } else {
        this.validator = () => [];
      }
      if (refiner) {
        this.refiner = (value, context) => {
          const result = refiner(value, context);
          return toFailures(result, context, this, value);
        };
      } else {
        this.refiner = () => [];
      }
    }
    /**
     * Assert that a value passes the struct's validation, throwing if it doesn't.
     */
    assert(value) {
      return assert(value, this);
    }
    /**
     * Create a value with the struct's coercion logic, then validate it.
     */
    create(value) {
      return create(value, this);
    }
    /**
     * Check if a value passes the struct's validation.
     */
    is(value) {
      return is(value, this);
    }
    /**
     * Mask a value, coercing and validating it, but returning only the subset of
     * properties defined by the struct's schema.
     */
    mask(value) {
      return mask(value, this);
    }
    /**
     * Validate a value with the struct's validation logic, returning a tuple
     * representing the result.
     *
     * You may optionally pass `true` for the `withCoercion` argument to coerce
     * the value before attempting to validate it. If you do, the result will
     * contain the coerced result when successful.
     */
    validate(value, options) {
      if (options === void 0) {
        options = {};
      }
      return validate2(value, this, options);
    }
  };
  function assert(value, struct3) {
    const result = validate2(value, struct3);
    if (result[0]) {
      throw result[0];
    }
  }
  function create(value, struct3) {
    const result = validate2(value, struct3, {
      coerce: true
    });
    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  }
  function mask(value, struct3) {
    const result = validate2(value, struct3, {
      coerce: true,
      mask: true
    });
    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  }
  function is(value, struct3) {
    const result = validate2(value, struct3);
    return !result[0];
  }
  function validate2(value, struct3, options) {
    if (options === void 0) {
      options = {};
    }
    const tuples = run(value, struct3, options);
    const tuple = shiftIterator(tuples);
    if (tuple[0]) {
      const error = new StructError(tuple[0], function* () {
        for (const t of tuples) {
          if (t[0]) {
            yield t[0];
          }
        }
      });
      return [error, void 0];
    } else {
      const v = tuple[1];
      return [void 0, v];
    }
  }
  function define2(name, validator) {
    return new Struct({
      type: name,
      schema: null,
      validator
    });
  }
  function any() {
    return define2("any", () => true);
  }
  function array2(Element) {
    return new Struct({
      type: "array",
      schema: Element,
      *entries(value) {
        if (Element && Array.isArray(value)) {
          for (const [i, v] of value.entries()) {
            yield [i, v, Element];
          }
        }
      },
      coercer(value) {
        return Array.isArray(value) ? value.slice() : value;
      },
      validator(value) {
        return Array.isArray(value) || "Expected an array value, but received: " + print(value);
      }
    });
  }
  function boolean() {
    return define2("boolean", (value) => {
      return typeof value === "boolean";
    });
  }
  function literal(constant) {
    const description = print(constant);
    const t = typeof constant;
    return new Struct({
      type: "literal",
      schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
      validator(value) {
        return value === constant || "Expected the literal `" + description + "`, but received: " + print(value);
      }
    });
  }
  function nullable(struct3) {
    return new Struct({
      ...struct3,
      validator: (value, ctx) => value === null || struct3.validator(value, ctx),
      refiner: (value, ctx) => value === null || struct3.refiner(value, ctx)
    });
  }
  function number() {
    return define2("number", (value) => {
      return typeof value === "number" && !isNaN(value) || "Expected a number, but received: " + print(value);
    });
  }
  function optional(struct3) {
    return new Struct({
      ...struct3,
      validator: (value, ctx) => value === void 0 || struct3.validator(value, ctx),
      refiner: (value, ctx) => value === void 0 || struct3.refiner(value, ctx)
    });
  }
  function string() {
    return define2("string", (value) => {
      return typeof value === "string" || "Expected a string, but received: " + print(value);
    });
  }
  function type(schema) {
    const keys = Object.keys(schema);
    return new Struct({
      type: "type",
      schema,
      *entries(value) {
        if (isObject(value)) {
          for (const k of keys) {
            yield [k, value[k], schema[k]];
          }
        }
      },
      validator(value) {
        return isObject(value) || "Expected an object, but received: " + print(value);
      }
    });
  }
  function union$1(Structs) {
    const description = Structs.map((s) => s.type).join(" | ");
    return new Struct({
      type: "union",
      schema: null,
      coercer(value, ctx) {
        const firstMatch = Structs.find((s) => {
          const [e] = s.validate(value, {
            coerce: true
          });
          return !e;
        }) || unknown();
        return firstMatch.coercer(value, ctx);
      },
      validator(value, ctx) {
        const failures = [];
        for (const S of Structs) {
          const [...tuples] = run(value, S, ctx);
          const [first] = tuples;
          if (!first[0]) {
            return [];
          } else {
            for (const [failure] of tuples) {
              if (failure) {
                failures.push(failure);
              }
            }
          }
        }
        return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print(value), ...failures];
      }
    });
  }
  function unknown() {
    return define2("unknown", () => true);
  }
  function coerce(struct3, condition, coercer) {
    return new Struct({
      ...struct3,
      coercer: (value, ctx) => {
        return is(value, condition) ? struct3.coercer(coercer(value, ctx), ctx) : struct3.coercer(value, ctx);
      }
    });
  }
  async function invoke(programId, accounts, data, provider) {
    programId = translateAddress(programId);
    if (!provider) {
      provider = getProvider();
    }
    const tx = new import_web3.Transaction();
    tx.add(new import_web3.TransactionInstruction({
      programId,
      keys: accounts !== null && accounts !== void 0 ? accounts : [],
      data
    }));
    if (provider.sendAndConfirm === void 0) {
      throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
    }
    return await provider.sendAndConfirm(tx, []);
  }
  var GET_MULTIPLE_ACCOUNTS_LIMIT = 99;
  async function getMultipleAccounts(connection, publicKeys, commitment) {
    const results = await getMultipleAccountsAndContext(connection, publicKeys, commitment);
    return results.map((result) => {
      return result ? { publicKey: result.publicKey, account: result.account } : null;
    });
  }
  async function getMultipleAccountsAndContext(connection, publicKeys, commitment) {
    if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {
      return await getMultipleAccountsAndContextCore(connection, publicKeys, commitment);
    } else {
      const batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);
      const results = await Promise.all(batches.map((batch) => getMultipleAccountsAndContextCore(connection, batch, commitment)));
      return results.flat();
    }
  }
  async function getMultipleAccountsAndContextCore(connection, publicKeys, commitmentOverride) {
    const commitment = commitmentOverride !== null && commitmentOverride !== void 0 ? commitmentOverride : connection.commitment;
    const { value: accountInfos, context } = await connection.getMultipleAccountsInfoAndContext(publicKeys, commitment);
    const accounts = accountInfos.map((account, idx) => {
      if (account === null) {
        return null;
      }
      return {
        publicKey: publicKeys[idx],
        account,
        context
      };
    });
    return accounts;
  }
  async function simulateTransaction(connection, transaction, signers, commitment, includeAccounts) {
    var _a;
    if (signers && signers.length > 0) {
      transaction.sign(...signers);
    }
    const message = transaction._compile();
    const signData = message.serialize();
    const wireTransaction = transaction._serialize(signData);
    const encodedTransaction = wireTransaction.toString("base64");
    const config = {
      encoding: "base64",
      commitment: commitment !== null && commitment !== void 0 ? commitment : connection.commitment
    };
    if (includeAccounts) {
      const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
      config["accounts"] = {
        encoding: "base64",
        addresses
      };
    }
    if (signers && signers.length > 0) {
      config.sigVerify = true;
    }
    const args = [encodedTransaction, config];
    const unsafeRes = await connection._rpcRequest("simulateTransaction", args);
    const res = create(unsafeRes, SimulatedTransactionResponseStruct);
    if ("error" in res) {
      let logs;
      if ("data" in res.error) {
        logs = (_a = res.error.data) === null || _a === void 0 ? void 0 : _a.logs;
        if (logs && Array.isArray(logs)) {
          const traceIndent = "\n    ";
          const logTrace = traceIndent + logs.join(traceIndent);
          console.error(res.error.message, logTrace);
        }
      }
      throw new import_web3.SendTransactionError("failed to simulate transaction: " + res.error.message, logs);
    }
    return res.result;
  }
  function jsonRpcResult(schema) {
    return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {
      if ("error" in value) {
        return value;
      } else {
        return {
          ...value,
          result: create(value.result, schema)
        };
      }
    });
  }
  var UnknownRpcResult = createRpcResult(unknown());
  function createRpcResult(result) {
    return union$1([
      type({
        jsonrpc: literal("2.0"),
        id: string(),
        result
      }),
      type({
        jsonrpc: literal("2.0"),
        id: string(),
        error: type({
          code: unknown(),
          message: string(),
          data: optional(any())
        })
      })
    ]);
  }
  function jsonRpcResultAndContext(value) {
    return jsonRpcResult(type({
      context: type({
        slot: number()
      }),
      value
    }));
  }
  var SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
    err: nullable(union$1([type({}), string()])),
    logs: nullable(array2(string())),
    accounts: optional(nullable(array2(nullable(type({
      executable: boolean(),
      owner: string(),
      lamports: number(),
      data: array2(string()),
      rentEpoch: optional(number())
    }))))),
    unitsConsumed: optional(number())
  }));
  var rpc = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    invoke,
    getMultipleAccounts,
    getMultipleAccountsAndContext,
    simulateTransaction
  });
  var AnchorProvider = class _AnchorProvider {
    /**
     * @param connection The cluster connection where the program is deployed.
     * @param wallet     The wallet used to pay for and sign all transactions.
     * @param opts       Transaction confirmation options to use by default.
     */
    constructor(connection, wallet, opts = _AnchorProvider.defaultOptions()) {
      this.connection = connection;
      this.wallet = wallet;
      this.opts = opts;
      this.publicKey = wallet === null || wallet === void 0 ? void 0 : wallet.publicKey;
    }
    static defaultOptions() {
      return {
        preflightCommitment: "processed",
        commitment: "processed"
      };
    }
    /**
     * Returns a `Provider` with a wallet read from the local filesystem.
     *
     * @param url  The network cluster url.
     * @param opts The default transaction confirmation options.
     *
     * (This api is for Node only.)
     */
    static local(url, opts = _AnchorProvider.defaultOptions()) {
      {
        throw new Error(`Provider local is not available on browser.`);
      }
    }
    /**
     * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment
     * variable
     *
     * (This api is for Node only.)
     */
    static env() {
      {
        throw new Error(`Provider env is not available on browser.`);
      }
    }
    /**
     * Sends the given transaction, paid for and signed by the provider's wallet.
     *
     * @param tx      The transaction to send.
     * @param signers The signers of the transaction.
     * @param opts    Transaction confirmation options.
     */
    async sendAndConfirm(tx, signers, opts) {
      var _a, _b, _c, _d;
      if (opts === void 0) {
        opts = this.opts;
      }
      if (isVersionedTransaction(tx)) {
        if (signers) {
          tx.sign(signers);
        }
      } else {
        tx.feePayer = (_a = tx.feePayer) !== null && _a !== void 0 ? _a : this.wallet.publicKey;
        tx.recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;
        if (signers) {
          for (const signer of signers) {
            tx.partialSign(signer);
          }
        }
      }
      tx = await this.wallet.signTransaction(tx);
      const rawTx = tx.serialize();
      try {
        return await sendAndConfirmRawTransaction(this.connection, rawTx, opts);
      } catch (err2) {
        if (err2 instanceof ConfirmError) {
          const txSig = encode$1(isVersionedTransaction(tx) ? ((_b = tx.signatures) === null || _b === void 0 ? void 0 : _b[0]) || new Uint8Array() : (_c = tx.signature) !== null && _c !== void 0 ? _c : new Uint8Array());
          const maxVer = isVersionedTransaction(tx) ? 0 : void 0;
          const failedTx = await this.connection.getTransaction(txSig, {
            commitment: "confirmed",
            maxSupportedTransactionVersion: maxVer
          });
          if (!failedTx) {
            throw err2;
          } else {
            const logs = (_d = failedTx.meta) === null || _d === void 0 ? void 0 : _d.logMessages;
            throw !logs ? err2 : new import_web3.SendTransactionError(err2.message, logs);
          }
        } else {
          throw err2;
        }
      }
    }
    /**
     * Similar to `send`, but for an array of transactions and signers.
     * All transactions need to be of the same type, it doesn't support a mix of `VersionedTransaction`s and `Transaction`s.
     *
     * @param txWithSigners Array of transactions and signers.
     * @param opts          Transaction confirmation options.
     */
    async sendAll(txWithSigners, opts) {
      var _a, _b, _c;
      if (opts === void 0) {
        opts = this.opts;
      }
      const recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;
      let txs = txWithSigners.map((r) => {
        var _a2, _b2;
        if (isVersionedTransaction(r.tx)) {
          let tx = r.tx;
          if (r.signers) {
            tx.sign(r.signers);
          }
          return tx;
        } else {
          let tx = r.tx;
          let signers = (_a2 = r.signers) !== null && _a2 !== void 0 ? _a2 : [];
          tx.feePayer = (_b2 = tx.feePayer) !== null && _b2 !== void 0 ? _b2 : this.wallet.publicKey;
          tx.recentBlockhash = recentBlockhash;
          signers.forEach((kp) => {
            tx.partialSign(kp);
          });
          return tx;
        }
      });
      const signedTxs = await this.wallet.signAllTransactions(txs);
      const sigs = [];
      for (let k = 0; k < txs.length; k += 1) {
        const tx = signedTxs[k];
        const rawTx = tx.serialize();
        try {
          sigs.push(await sendAndConfirmRawTransaction(this.connection, rawTx, opts));
        } catch (err2) {
          if (err2 instanceof ConfirmError) {
            const txSig = encode$1(isVersionedTransaction(tx) ? ((_a = tx.signatures) === null || _a === void 0 ? void 0 : _a[0]) || new Uint8Array() : (_b = tx.signature) !== null && _b !== void 0 ? _b : new Uint8Array());
            const maxVer = isVersionedTransaction(tx) ? 0 : void 0;
            const failedTx = await this.connection.getTransaction(txSig, {
              commitment: "confirmed",
              maxSupportedTransactionVersion: maxVer
            });
            if (!failedTx) {
              throw err2;
            } else {
              const logs = (_c = failedTx.meta) === null || _c === void 0 ? void 0 : _c.logMessages;
              throw !logs ? err2 : new import_web3.SendTransactionError(err2.message, logs);
            }
          } else {
            throw err2;
          }
        }
      }
      return sigs;
    }
    /**
     * Simulates the given transaction, returning emitted logs from execution.
     *
     * @param tx      The transaction to send.
     * @param signers The signers of the transaction. If unset, the transaction
     *                will be simulated with the "sigVerify: false" option. This
     *                allows for simulation of transactions without asking the
     *                wallet for a signature.
     * @param opts    Transaction confirmation options.
     */
    async simulate(tx, signers, commitment, includeAccounts) {
      let recentBlockhash = (await this.connection.getLatestBlockhash(commitment !== null && commitment !== void 0 ? commitment : this.connection.commitment)).blockhash;
      let result;
      if (isVersionedTransaction(tx)) {
        if (signers && signers.length > 0) {
          tx.sign(signers);
          tx = await this.wallet.signTransaction(tx);
        }
        result = await this.connection.simulateTransaction(tx, { commitment });
      } else {
        tx.feePayer = tx.feePayer || this.wallet.publicKey;
        tx.recentBlockhash = recentBlockhash;
        if (signers && signers.length > 0) {
          tx = await this.wallet.signTransaction(tx);
        }
        result = await simulateTransaction(this.connection, tx, signers, commitment, includeAccounts);
      }
      if (result.value.err) {
        throw new SimulateError(result.value);
      }
      return result.value;
    }
  };
  var SimulateError = class extends Error {
    constructor(simulationResponse, message) {
      super(message);
      this.simulationResponse = simulationResponse;
    }
  };
  async function sendAndConfirmRawTransaction(connection, rawTransaction, options) {
    const sendOptions = options && {
      skipPreflight: options.skipPreflight,
      preflightCommitment: options.preflightCommitment || options.commitment
    };
    const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);
    const status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
    if (status.err) {
      throw new ConfirmError(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);
    }
    return signature;
  }
  var ConfirmError = class extends Error {
    constructor(message) {
      super(message);
    }
  };
  function setProvider(provider) {
    _provider = provider;
  }
  function getProvider() {
    if (_provider === null) {
      return AnchorProvider.local();
    }
    return _provider;
  }
  var _provider = null;
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var dist = {};
  Object.defineProperty(dist, "__esModule", { value: true });
  var ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = ANCHOR_ERROR__REQUIRE_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_VIOLATED = ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = dist.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = dist.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = ANCHOR_ERROR__CONSTRAINT_SPACE = dist.ANCHOR_ERROR__CONSTRAINT_SPACE = ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = ANCHOR_ERROR__CONSTRAINT_ZERO = dist.ANCHOR_ERROR__CONSTRAINT_ZERO = ANCHOR_ERROR__CONSTRAINT_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_ADDRESS = ANCHOR_ERROR__CONSTRAINT_CLOSE = dist.ANCHOR_ERROR__CONSTRAINT_CLOSE = ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = ANCHOR_ERROR__CONSTRAINT_STATE = dist.ANCHOR_ERROR__CONSTRAINT_STATE = ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = dist.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = ANCHOR_ERROR__CONSTRAINT_SEEDS = dist.ANCHOR_ERROR__CONSTRAINT_SEEDS = ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = dist.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = ANCHOR_ERROR__CONSTRAINT_OWNER = dist.ANCHOR_ERROR__CONSTRAINT_OWNER = ANCHOR_ERROR__CONSTRAINT_RAW = dist.ANCHOR_ERROR__CONSTRAINT_RAW = ANCHOR_ERROR__CONSTRAINT_SIGNER = dist.ANCHOR_ERROR__CONSTRAINT_SIGNER = ANCHOR_ERROR__CONSTRAINT_HAS_ONE = dist.ANCHOR_ERROR__CONSTRAINT_HAS_ONE = ANCHOR_ERROR__CONSTRAINT_MUT = dist.ANCHOR_ERROR__CONSTRAINT_MUT = ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = dist.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = dist.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = dist.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = ANCHOR_ERROR__IDL_INSTRUCTION_STUB = dist.ANCHOR_ERROR__IDL_INSTRUCTION_STUB = ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = dist.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = dist.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = dist.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = ANCHOR_ERROR__INSTRUCTION_MISSING = dist.ANCHOR_ERROR__INSTRUCTION_MISSING = void 0;
  var ANCHOR_ERROR__DEPRECATED = dist.ANCHOR_ERROR__DEPRECATED = ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = dist.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = dist.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = dist.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = dist.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = dist.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = dist.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = dist.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = dist.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = dist.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = dist.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = dist.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = dist.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = ANCHOR_ERROR__INVALID_PROGRAM_ID = dist.ANCHOR_ERROR__INVALID_PROGRAM_ID = ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = dist.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = dist.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = dist.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = dist.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = dist.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = ANCHOR_ERROR__REQUIRE_GT_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_GT_VIOLATED = ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = void 0;
  var ANCHOR_ERROR__INSTRUCTION_MISSING = dist.ANCHOR_ERROR__INSTRUCTION_MISSING = 100;
  var ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = dist.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = 101;
  var ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = dist.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = 102;
  var ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = dist.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = 103;
  var ANCHOR_ERROR__IDL_INSTRUCTION_STUB = dist.ANCHOR_ERROR__IDL_INSTRUCTION_STUB = 1e3;
  var ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = dist.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = 1001;
  var ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = dist.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = 1002;
  var ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = dist.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = 1500;
  var ANCHOR_ERROR__CONSTRAINT_MUT = dist.ANCHOR_ERROR__CONSTRAINT_MUT = 2e3;
  var ANCHOR_ERROR__CONSTRAINT_HAS_ONE = dist.ANCHOR_ERROR__CONSTRAINT_HAS_ONE = 2001;
  var ANCHOR_ERROR__CONSTRAINT_SIGNER = dist.ANCHOR_ERROR__CONSTRAINT_SIGNER = 2002;
  var ANCHOR_ERROR__CONSTRAINT_RAW = dist.ANCHOR_ERROR__CONSTRAINT_RAW = 2003;
  var ANCHOR_ERROR__CONSTRAINT_OWNER = dist.ANCHOR_ERROR__CONSTRAINT_OWNER = 2004;
  var ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = dist.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = 2005;
  var ANCHOR_ERROR__CONSTRAINT_SEEDS = dist.ANCHOR_ERROR__CONSTRAINT_SEEDS = 2006;
  var ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = dist.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = 2007;
  var ANCHOR_ERROR__CONSTRAINT_STATE = dist.ANCHOR_ERROR__CONSTRAINT_STATE = 2008;
  var ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = 2009;
  var ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = 2010;
  var ANCHOR_ERROR__CONSTRAINT_CLOSE = dist.ANCHOR_ERROR__CONSTRAINT_CLOSE = 2011;
  var ANCHOR_ERROR__CONSTRAINT_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_ADDRESS = 2012;
  var ANCHOR_ERROR__CONSTRAINT_ZERO = dist.ANCHOR_ERROR__CONSTRAINT_ZERO = 2013;
  var ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = 2014;
  var ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = 2015;
  var ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = 2016;
  var ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = 2017;
  var ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = 2018;
  var ANCHOR_ERROR__CONSTRAINT_SPACE = dist.ANCHOR_ERROR__CONSTRAINT_SPACE = 2019;
  var ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = dist.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = 2020;
  var ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = 2021;
  var ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = 2022;
  var ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = 2023;
  var ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = 2024;
  var ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = 2025;
  var ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = 2026;
  var ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = 2027;
  var ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = 2028;
  var ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = 2029;
  var ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = 2030;
  var ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = 2031;
  var ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = 2032;
  var ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = 2033;
  var ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = 2034;
  var ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = 2035;
  var ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = dist.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = 2036;
  var ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = 2037;
  var ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = 2038;
  var ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = 2039;
  var ANCHOR_ERROR__REQUIRE_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_VIOLATED = 2500;
  ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = 2501;
  var ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = 2502;
  var ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = 2503;
  var ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = 2504;
  var ANCHOR_ERROR__REQUIRE_GT_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_GT_VIOLATED = 2505;
  var ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = 2506;
  var ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = 3e3;
  var ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = 3001;
  var ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = 3002;
  var ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = dist.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = 3003;
  var ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = dist.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = 3004;
  var ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = dist.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = 3005;
  var ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = dist.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = 3006;
  var ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = dist.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = 3007;
  var ANCHOR_ERROR__INVALID_PROGRAM_ID = dist.ANCHOR_ERROR__INVALID_PROGRAM_ID = 3008;
  var ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = dist.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = 3009;
  var ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = dist.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = 3010;
  var ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = dist.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = 3011;
  var ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = dist.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = 3012;
  var ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = dist.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = 3013;
  var ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = dist.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = 3014;
  var ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = dist.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = 3015;
  var ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = dist.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = 3016;
  var ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = dist.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = 3017;
  var ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = dist.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = 4100;
  var ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = dist.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = 4101;
  var ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = dist.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = 4102;
  ANCHOR_ERROR__DEPRECATED = dist.ANCHOR_ERROR__DEPRECATED = 5e3;
  var _AVAILABLE_FEATURES = /* @__PURE__ */ new Set(["debug-logs"]);
  var _FEATURES = /* @__PURE__ */ new Map();
  function set(key) {
    if (!_AVAILABLE_FEATURES.has(key)) {
      throw new Error("Invalid feature");
    }
    _FEATURES.set(key, true);
  }
  function isSet(key) {
    return _FEATURES.get(key) !== void 0;
  }
  var features = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    set,
    isSet
  });
  var IdlError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "IdlError";
    }
  };
  var ProgramErrorStack = class _ProgramErrorStack {
    constructor(stack) {
      this.stack = stack;
    }
    static parse(logs) {
      var _a;
      const programKeyRegex = /^Program (\w*) invoke/;
      const successRegex = /^Program \w* success/;
      const programStack = [];
      for (let i = 0; i < logs.length; i++) {
        if (successRegex.exec(logs[i])) {
          programStack.pop();
          continue;
        }
        const programKey = (_a = programKeyRegex.exec(logs[i])) === null || _a === void 0 ? void 0 : _a[1];
        if (!programKey) {
          continue;
        }
        programStack.push(new import_web3.PublicKey(programKey));
      }
      return new _ProgramErrorStack(programStack);
    }
  };
  var AnchorError = class _AnchorError extends Error {
    constructor(errorCode, errorMessage, errorLogs, logs, origin, comparedValues) {
      super(errorLogs.join("\n").replace("Program log: ", ""));
      this.errorLogs = errorLogs;
      this.logs = logs;
      this.error = { errorCode, errorMessage, comparedValues, origin };
      this._programErrorStack = ProgramErrorStack.parse(logs);
    }
    static parse(logs) {
      if (!logs) {
        return null;
      }
      const anchorErrorLogIndex = logs.findIndex((log) => log.startsWith("Program log: AnchorError"));
      if (anchorErrorLogIndex === -1) {
        return null;
      }
      const anchorErrorLog = logs[anchorErrorLogIndex];
      const errorLogs = [anchorErrorLog];
      let comparedValues;
      if (anchorErrorLogIndex + 1 < logs.length) {
        if (logs[anchorErrorLogIndex + 1] === "Program log: Left:") {
          const pubkeyRegex = /^Program log: (.*)$/;
          const leftPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 2])[1];
          const rightPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 4])[1];
          comparedValues = [
            new import_web3.PublicKey(leftPubkey),
            new import_web3.PublicKey(rightPubkey)
          ];
          errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 5));
        } else if (logs[anchorErrorLogIndex + 1].startsWith("Program log: Left:")) {
          const valueRegex = /^Program log: (Left|Right): (.*)$/;
          const leftValue = valueRegex.exec(logs[anchorErrorLogIndex + 1])[2];
          const rightValue = valueRegex.exec(logs[anchorErrorLogIndex + 2])[2];
          errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 3));
          comparedValues = [leftValue, rightValue];
        }
      }
      const regexNoInfo = /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
      const noInfoAnchorErrorLog = regexNoInfo.exec(anchorErrorLog);
      const regexFileLine = /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
      const fileLineAnchorErrorLog = regexFileLine.exec(anchorErrorLog);
      const regexAccountName = /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
      const accountNameAnchorErrorLog = regexAccountName.exec(anchorErrorLog);
      if (noInfoAnchorErrorLog) {
        const [errorCodeString, errorNumber, errorMessage] = noInfoAnchorErrorLog.slice(1, 4);
        const errorCode = {
          code: errorCodeString,
          number: parseInt(errorNumber)
        };
        return new _AnchorError(errorCode, errorMessage, errorLogs, logs, void 0, comparedValues);
      } else if (fileLineAnchorErrorLog) {
        const [file, line, errorCodeString, errorNumber, errorMessage] = fileLineAnchorErrorLog.slice(1, 6);
        const errorCode = {
          code: errorCodeString,
          number: parseInt(errorNumber)
        };
        const fileLine = { file, line: parseInt(line) };
        return new _AnchorError(errorCode, errorMessage, errorLogs, logs, fileLine, comparedValues);
      } else if (accountNameAnchorErrorLog) {
        const [accountName, errorCodeString, errorNumber, errorMessage] = accountNameAnchorErrorLog.slice(1, 5);
        const origin = accountName;
        const errorCode = {
          code: errorCodeString,
          number: parseInt(errorNumber)
        };
        return new _AnchorError(errorCode, errorMessage, errorLogs, logs, origin, comparedValues);
      } else {
        return null;
      }
    }
    get program() {
      return this._programErrorStack.stack[this._programErrorStack.stack.length - 1];
    }
    get programErrorStack() {
      return this._programErrorStack.stack;
    }
    toString() {
      return this.message;
    }
  };
  var ProgramError = class _ProgramError extends Error {
    constructor(code, msg, logs) {
      super();
      this.code = code;
      this.msg = msg;
      this.logs = logs;
      if (logs) {
        this._programErrorStack = ProgramErrorStack.parse(logs);
      }
    }
    static parse(err2, idlErrors) {
      const errString = err2.toString();
      let unparsedErrorCode;
      if (errString.includes("custom program error:")) {
        let components = errString.split("custom program error: ");
        if (components.length !== 2) {
          return null;
        } else {
          unparsedErrorCode = components[1];
        }
      } else {
        const matches = errString.match(/"Custom":([0-9]+)}/g);
        if (!matches || matches.length > 1) {
          return null;
        }
        unparsedErrorCode = matches[0].match(/([0-9]+)/g)[0];
      }
      let errorCode;
      try {
        errorCode = parseInt(unparsedErrorCode);
      } catch (parseErr) {
        return null;
      }
      let errorMsg = idlErrors.get(errorCode);
      if (errorMsg !== void 0) {
        return new _ProgramError(errorCode, errorMsg, err2.logs);
      }
      errorMsg = LangErrorMessage.get(errorCode);
      if (errorMsg !== void 0) {
        return new _ProgramError(errorCode, errorMsg, err2.logs);
      }
      return null;
    }
    get program() {
      var _a;
      return (_a = this._programErrorStack) === null || _a === void 0 ? void 0 : _a.stack[this._programErrorStack.stack.length - 1];
    }
    get programErrorStack() {
      var _a;
      return (_a = this._programErrorStack) === null || _a === void 0 ? void 0 : _a.stack;
    }
    toString() {
      return this.msg;
    }
  };
  function translateError(err2, idlErrors) {
    if (isSet("debug-logs")) {
      console.log("Translating error:", err2);
    }
    const anchorError = AnchorError.parse(err2.logs);
    if (anchorError) {
      return anchorError;
    }
    const programError = ProgramError.parse(err2, idlErrors);
    if (programError) {
      return programError;
    }
    if (err2.logs) {
      const handler = {
        get: function(target, prop) {
          if (prop === "programErrorStack") {
            return target.programErrorStack.stack;
          } else if (prop === "program") {
            return target.programErrorStack.stack[err2.programErrorStack.stack.length - 1];
          } else {
            return Reflect.get(...arguments);
          }
        }
      };
      err2.programErrorStack = ProgramErrorStack.parse(err2.logs);
      return new Proxy(err2, handler);
    }
    return err2;
  }
  var LangErrorCode = {
    // Instructions.
    InstructionMissing: ANCHOR_ERROR__INSTRUCTION_MISSING,
    InstructionFallbackNotFound: ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND,
    InstructionDidNotDeserialize: ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE,
    InstructionDidNotSerialize: ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE,
    // IDL instructions.
    IdlInstructionStub: ANCHOR_ERROR__IDL_INSTRUCTION_STUB,
    IdlInstructionInvalidProgram: ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM,
    IdlAccountNotEmpty: ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY,
    // Event instructions.
    EventInstructionStub: ANCHOR_ERROR__EVENT_INSTRUCTION_STUB,
    // Constraints.
    ConstraintMut: ANCHOR_ERROR__CONSTRAINT_MUT,
    ConstraintHasOne: ANCHOR_ERROR__CONSTRAINT_HAS_ONE,
    ConstraintSigner: ANCHOR_ERROR__CONSTRAINT_SIGNER,
    ConstraintRaw: ANCHOR_ERROR__CONSTRAINT_RAW,
    ConstraintOwner: ANCHOR_ERROR__CONSTRAINT_OWNER,
    ConstraintRentExempt: ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT,
    ConstraintSeeds: ANCHOR_ERROR__CONSTRAINT_SEEDS,
    ConstraintExecutable: ANCHOR_ERROR__CONSTRAINT_EXECUTABLE,
    ConstraintState: ANCHOR_ERROR__CONSTRAINT_STATE,
    ConstraintAssociated: ANCHOR_ERROR__CONSTRAINT_ASSOCIATED,
    ConstraintAssociatedInit: ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT,
    ConstraintClose: ANCHOR_ERROR__CONSTRAINT_CLOSE,
    ConstraintAddress: ANCHOR_ERROR__CONSTRAINT_ADDRESS,
    ConstraintZero: ANCHOR_ERROR__CONSTRAINT_ZERO,
    ConstraintTokenMint: ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT,
    ConstraintTokenOwner: ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER,
    ConstraintMintMintAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY,
    ConstraintMintFreezeAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY,
    ConstraintMintDecimals: ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS,
    ConstraintSpace: ANCHOR_ERROR__CONSTRAINT_SPACE,
    ConstraintAccountIsNone: ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE,
    ConstraintTokenTokenProgram: ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM,
    ConstraintMintTokenProgram: ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM,
    ConstraintAssociatedTokenTokenProgram: ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM,
    ConstraintMintGroupPointerExtension: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION,
    ConstraintMintGroupPointerExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY,
    ConstraintMintGroupPointerExtensionGroupAddress: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS,
    ConstraintMintGroupMemberPointerExtension: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION,
    ConstraintMintGroupMemberPointerExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY,
    ConstraintMintGroupMemberPointerExtensionMemberAddress: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS,
    ConstraintMintMetadataPointerExtension: ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION,
    ConstraintMintMetadataPointerExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY,
    ConstraintMintMetadataPointerExtensionMetadataAddress: ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS,
    ConstraintMintCloseAuthorityExtension: ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION,
    ConstraintMintCloseAuthorityExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY,
    ConstraintMintPermanentDelegateExtension: ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION,
    ConstraintMintPermanentDelegateExtensionDelegate: ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE,
    ConstraintMintTransferHookExtension: ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION,
    ConstraintMintTransferHookExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY,
    ConstraintMintTransferHookExtensionProgramId: ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID,
    // Require.
    RequireViolated: ANCHOR_ERROR__REQUIRE_VIOLATED,
    RequireEqViolated: ANCHOR_ERROR__REQUIRE_EQ_VIOLATED,
    RequireKeysEqViolated: ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED,
    RequireNeqViolated: ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED,
    RequireKeysNeqViolated: ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED,
    RequireGtViolated: ANCHOR_ERROR__REQUIRE_GT_VIOLATED,
    RequireGteViolated: ANCHOR_ERROR__REQUIRE_GTE_VIOLATED,
    // Accounts.
    AccountDiscriminatorAlreadySet: ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET,
    AccountDiscriminatorNotFound: ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND,
    AccountDiscriminatorMismatch: ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH,
    AccountDidNotDeserialize: ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE,
    AccountDidNotSerialize: ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE,
    AccountNotEnoughKeys: ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS,
    AccountNotMutable: ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE,
    AccountOwnedByWrongProgram: ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM,
    InvalidProgramId: ANCHOR_ERROR__INVALID_PROGRAM_ID,
    InvalidProgramExecutable: ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE,
    AccountNotSigner: ANCHOR_ERROR__ACCOUNT_NOT_SIGNER,
    AccountNotSystemOwned: ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED,
    AccountNotInitialized: ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED,
    AccountNotProgramData: ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA,
    AccountNotAssociatedTokenAccount: ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT,
    AccountSysvarMismatch: ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH,
    AccountReallocExceedsLimit: ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT,
    AccountDuplicateReallocs: ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS,
    // Miscellaneous
    DeclaredProgramIdMismatch: ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH,
    TryingToInitPayerAsProgramAccount: ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT,
    InvalidNumericConversion: ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION,
    // Used for APIs that shouldn't be used anymore.
    Deprecated: ANCHOR_ERROR__DEPRECATED
  };
  var LangErrorMessage = /* @__PURE__ */ new Map([
    // Instructions.
    [
      LangErrorCode.InstructionMissing,
      "8 byte instruction identifier not provided"
    ],
    [
      LangErrorCode.InstructionFallbackNotFound,
      "Fallback functions are not supported"
    ],
    [
      LangErrorCode.InstructionDidNotDeserialize,
      "The program could not deserialize the given instruction"
    ],
    [
      LangErrorCode.InstructionDidNotSerialize,
      "The program could not serialize the given instruction"
    ],
    // Idl instructions.
    [
      LangErrorCode.IdlInstructionStub,
      "The program was compiled without idl instructions"
    ],
    [
      LangErrorCode.IdlInstructionInvalidProgram,
      "The transaction was given an invalid program for the IDL instruction"
    ],
    [
      LangErrorCode.IdlAccountNotEmpty,
      "IDL account must be empty in order to resize, try closing first"
    ],
    // Event instructions.
    [
      LangErrorCode.EventInstructionStub,
      "The program was compiled without `event-cpi` feature"
    ],
    // Constraints.
    [LangErrorCode.ConstraintMut, "A mut constraint was violated"],
    [LangErrorCode.ConstraintHasOne, "A has one constraint was violated"],
    [LangErrorCode.ConstraintSigner, "A signer constraint was violated"],
    [LangErrorCode.ConstraintRaw, "A raw constraint was violated"],
    [LangErrorCode.ConstraintOwner, "An owner constraint was violated"],
    [
      LangErrorCode.ConstraintRentExempt,
      "A rent exemption constraint was violated"
    ],
    [LangErrorCode.ConstraintSeeds, "A seeds constraint was violated"],
    [LangErrorCode.ConstraintExecutable, "An executable constraint was violated"],
    [
      LangErrorCode.ConstraintState,
      "Deprecated Error, feel free to replace with something else"
    ],
    [LangErrorCode.ConstraintAssociated, "An associated constraint was violated"],
    [
      LangErrorCode.ConstraintAssociatedInit,
      "An associated init constraint was violated"
    ],
    [LangErrorCode.ConstraintClose, "A close constraint was violated"],
    [LangErrorCode.ConstraintAddress, "An address constraint was violated"],
    [LangErrorCode.ConstraintZero, "Expected zero account discriminant"],
    [LangErrorCode.ConstraintTokenMint, "A token mint constraint was violated"],
    [LangErrorCode.ConstraintTokenOwner, "A token owner constraint was violated"],
    [
      LangErrorCode.ConstraintMintMintAuthority,
      "A mint mint authority constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintFreezeAuthority,
      "A mint freeze authority constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintDecimals,
      "A mint decimals constraint was violated"
    ],
    [LangErrorCode.ConstraintSpace, "A space constraint was violated"],
    [
      LangErrorCode.ConstraintAccountIsNone,
      "A required account for the constraint is None"
    ],
    [
      LangErrorCode.ConstraintTokenTokenProgram,
      "A token account token program constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintTokenProgram,
      "A mint token program constraint was violated"
    ],
    [
      LangErrorCode.ConstraintAssociatedTokenTokenProgram,
      "An associated token account token program constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintGroupPointerExtension,
      "A group pointer extension constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintGroupPointerExtensionAuthority,
      "A group pointer extension authority constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintGroupPointerExtensionGroupAddress,
      "A group pointer extension group address constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintGroupMemberPointerExtension,
      "A group member pointer extension constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintGroupMemberPointerExtensionAuthority,
      "A group member pointer extension authority constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintGroupMemberPointerExtensionMemberAddress,
      "A group member pointer extension group address constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintMetadataPointerExtension,
      "A metadata pointer extension constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintMetadataPointerExtensionAuthority,
      "A metadata pointer extension authority constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintMetadataPointerExtensionMetadataAddress,
      "A metadata pointer extension metadata address constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintCloseAuthorityExtension,
      "A close authority constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintCloseAuthorityExtensionAuthority,
      "A close authority extension authority constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintPermanentDelegateExtension,
      "A permanent delegate extension constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintPermanentDelegateExtensionDelegate,
      "A permanent delegate extension delegate constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintTransferHookExtension,
      "A transfer hook extension constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintTransferHookExtensionAuthority,
      "A transfer hook extension authority constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintTransferHookExtensionProgramId,
      "A transfer hook extension transfer hook program id constraint was violated"
    ],
    // Require.
    [LangErrorCode.RequireViolated, "A require expression was violated"],
    [LangErrorCode.RequireEqViolated, "A require_eq expression was violated"],
    [
      LangErrorCode.RequireKeysEqViolated,
      "A require_keys_eq expression was violated"
    ],
    [LangErrorCode.RequireNeqViolated, "A require_neq expression was violated"],
    [
      LangErrorCode.RequireKeysNeqViolated,
      "A require_keys_neq expression was violated"
    ],
    [LangErrorCode.RequireGtViolated, "A require_gt expression was violated"],
    [LangErrorCode.RequireGteViolated, "A require_gte expression was violated"],
    // Accounts.
    [
      LangErrorCode.AccountDiscriminatorAlreadySet,
      "The account discriminator was already set on this account"
    ],
    [
      LangErrorCode.AccountDiscriminatorNotFound,
      "No 8 byte discriminator was found on the account"
    ],
    [
      LangErrorCode.AccountDiscriminatorMismatch,
      "8 byte discriminator did not match what was expected"
    ],
    [LangErrorCode.AccountDidNotDeserialize, "Failed to deserialize the account"],
    [LangErrorCode.AccountDidNotSerialize, "Failed to serialize the account"],
    [
      LangErrorCode.AccountNotEnoughKeys,
      "Not enough account keys given to the instruction"
    ],
    [LangErrorCode.AccountNotMutable, "The given account is not mutable"],
    [
      LangErrorCode.AccountOwnedByWrongProgram,
      "The given account is owned by a different program than expected"
    ],
    [LangErrorCode.InvalidProgramId, "Program ID was not as expected"],
    [LangErrorCode.InvalidProgramExecutable, "Program account is not executable"],
    [LangErrorCode.AccountNotSigner, "The given account did not sign"],
    [
      LangErrorCode.AccountNotSystemOwned,
      "The given account is not owned by the system program"
    ],
    [
      LangErrorCode.AccountNotInitialized,
      "The program expected this account to be already initialized"
    ],
    [
      LangErrorCode.AccountNotProgramData,
      "The given account is not a program data account"
    ],
    [
      LangErrorCode.AccountNotAssociatedTokenAccount,
      "The given account is not the associated token account"
    ],
    [
      LangErrorCode.AccountSysvarMismatch,
      "The given public key does not match the required sysvar"
    ],
    [
      LangErrorCode.AccountReallocExceedsLimit,
      "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"
    ],
    [
      LangErrorCode.AccountDuplicateReallocs,
      "The account was duplicated for more than one reallocation"
    ],
    // Miscellaneous
    [
      LangErrorCode.DeclaredProgramIdMismatch,
      "The declared program id does not match the actual program id"
    ],
    [
      LangErrorCode.TryingToInitPayerAsProgramAccount,
      "You cannot/should not initialize the payer account as a program account"
    ],
    [
      LangErrorCode.InvalidNumericConversion,
      "The program could not perform the numeric conversion, out of range integral type conversion attempted"
    ],
    // Deprecated
    [
      LangErrorCode.Deprecated,
      "The API being used is deprecated and should no longer be used"
    ]
  ]);
  var IdlCoder = class _IdlCoder {
    static fieldLayout(field, types = [], genericArgs) {
      const fieldName = field.name;
      switch (field.type) {
        case "bool": {
          return borsh.bool(fieldName);
        }
        case "u8": {
          return borsh.u8(fieldName);
        }
        case "i8": {
          return borsh.i8(fieldName);
        }
        case "u16": {
          return borsh.u16(fieldName);
        }
        case "i16": {
          return borsh.i16(fieldName);
        }
        case "u32": {
          return borsh.u32(fieldName);
        }
        case "i32": {
          return borsh.i32(fieldName);
        }
        case "f32": {
          return borsh.f32(fieldName);
        }
        case "u64": {
          return borsh.u64(fieldName);
        }
        case "i64": {
          return borsh.i64(fieldName);
        }
        case "f64": {
          return borsh.f64(fieldName);
        }
        case "u128": {
          return borsh.u128(fieldName);
        }
        case "i128": {
          return borsh.i128(fieldName);
        }
        case "u256": {
          return borsh.u256(fieldName);
        }
        case "i256": {
          return borsh.i256(fieldName);
        }
        case "bytes": {
          return borsh.vecU8(fieldName);
        }
        case "string": {
          return borsh.str(fieldName);
        }
        case "pubkey": {
          return borsh.publicKey(fieldName);
        }
        default: {
          if ("option" in field.type) {
            return borsh.option(_IdlCoder.fieldLayout({ type: field.type.option }, types, genericArgs), fieldName);
          }
          if ("vec" in field.type) {
            return borsh.vec(_IdlCoder.fieldLayout({ type: field.type.vec }, types, genericArgs), fieldName);
          }
          if ("array" in field.type) {
            let [type2, len] = field.type.array;
            len = _IdlCoder.resolveArrayLen(len, genericArgs);
            return borsh.array(_IdlCoder.fieldLayout({ type: type2 }, types, genericArgs), len, fieldName);
          }
          if ("defined" in field.type) {
            if (!types) {
              throw new IdlError("User defined types not provided");
            }
            const definedName = field.type.defined.name;
            const typeDef = types.find((t) => t.name === definedName);
            if (!typeDef) {
              throw new IdlError(`Type not found: ${field.name}`);
            }
            return _IdlCoder.typeDefLayout({
              typeDef,
              types,
              genericArgs: genericArgs !== null && genericArgs !== void 0 ? genericArgs : field.type.defined.generics,
              name: fieldName
            });
          }
          if ("generic" in field.type) {
            const genericArg = genericArgs === null || genericArgs === void 0 ? void 0 : genericArgs.at(0);
            if ((genericArg === null || genericArg === void 0 ? void 0 : genericArg.kind) !== "type") {
              throw new IdlError(`Invalid generic field: ${field.name}`);
            }
            return _IdlCoder.fieldLayout({ ...field, type: genericArg.type }, types);
          }
          throw new IdlError(`Not yet implemented: ${JSON.stringify(field.type)}`);
        }
      }
    }
    /**
     * Get the type layout of the given defined type(struct or enum).
     */
    static typeDefLayout({ typeDef, types, name, genericArgs }) {
      switch (typeDef.type.kind) {
        case "struct": {
          const fieldLayouts = handleDefinedFields(typeDef.type.fields, () => [], (fields) => fields.map((f2) => {
            const genArgs = genericArgs ? _IdlCoder.resolveGenericArgs({
              type: f2.type,
              typeDef,
              genericArgs
            }) : genericArgs;
            return _IdlCoder.fieldLayout(f2, types, genArgs);
          }), (fields) => fields.map((f2, i) => {
            const genArgs = genericArgs ? _IdlCoder.resolveGenericArgs({
              type: f2,
              typeDef,
              genericArgs
            }) : genericArgs;
            return _IdlCoder.fieldLayout({ name: i.toString(), type: f2 }, types, genArgs);
          }));
          return borsh.struct(fieldLayouts, name);
        }
        case "enum": {
          const variants = typeDef.type.variants.map((variant) => {
            const fieldLayouts = handleDefinedFields(variant.fields, () => [], (fields) => fields.map((f2) => {
              const genArgs = genericArgs ? _IdlCoder.resolveGenericArgs({
                type: f2.type,
                typeDef,
                genericArgs
              }) : genericArgs;
              return _IdlCoder.fieldLayout(f2, types, genArgs);
            }), (fields) => fields.map((f2, i) => {
              const genArgs = genericArgs ? _IdlCoder.resolveGenericArgs({
                type: f2,
                typeDef,
                genericArgs
              }) : genericArgs;
              return _IdlCoder.fieldLayout({ name: i.toString(), type: f2 }, types, genArgs);
            }));
            return borsh.struct(fieldLayouts, variant.name);
          });
          if (name !== void 0) {
            return borsh.rustEnum(variants).replicate(name);
          }
          return borsh.rustEnum(variants, name);
        }
        case "type": {
          return _IdlCoder.fieldLayout({ type: typeDef.type.alias, name }, types);
        }
      }
    }
    /**
     * Get the type of the size in bytes. Returns `1` for variable length types.
     */
    static typeSize(ty, idl, genericArgs) {
      var _a;
      switch (ty) {
        case "bool":
          return 1;
        case "u8":
          return 1;
        case "i8":
          return 1;
        case "i16":
          return 2;
        case "u16":
          return 2;
        case "u32":
          return 4;
        case "i32":
          return 4;
        case "f32":
          return 4;
        case "u64":
          return 8;
        case "i64":
          return 8;
        case "f64":
          return 8;
        case "u128":
          return 16;
        case "i128":
          return 16;
        case "u256":
          return 32;
        case "i256":
          return 32;
        case "bytes":
          return 1;
        case "string":
          return 1;
        case "pubkey":
          return 32;
        default:
          if ("option" in ty) {
            return 1 + _IdlCoder.typeSize(ty.option, idl, genericArgs);
          }
          if ("coption" in ty) {
            return 4 + _IdlCoder.typeSize(ty.coption, idl, genericArgs);
          }
          if ("vec" in ty) {
            return 1;
          }
          if ("array" in ty) {
            let [type2, len] = ty.array;
            len = _IdlCoder.resolveArrayLen(len, genericArgs);
            return _IdlCoder.typeSize(type2, idl, genericArgs) * len;
          }
          if ("defined" in ty) {
            const typeDef = (_a = idl.types) === null || _a === void 0 ? void 0 : _a.find((t) => t.name === ty.defined.name);
            if (!typeDef) {
              throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);
            }
            const typeSize = (type2) => {
              const genArgs = genericArgs !== null && genericArgs !== void 0 ? genericArgs : ty.defined.generics;
              const args = genArgs ? _IdlCoder.resolveGenericArgs({
                type: type2,
                typeDef,
                genericArgs: genArgs
              }) : genArgs;
              return _IdlCoder.typeSize(type2, idl, args);
            };
            switch (typeDef.type.kind) {
              case "struct": {
                return handleDefinedFields(typeDef.type.fields, () => [0], (fields) => fields.map((f2) => typeSize(f2.type)), (fields) => fields.map((f2) => typeSize(f2))).reduce((acc, size) => acc + size, 0);
              }
              case "enum": {
                const variantSizes = typeDef.type.variants.map((variant) => {
                  return handleDefinedFields(variant.fields, () => [0], (fields) => fields.map((f2) => typeSize(f2.type)), (fields) => fields.map((f2) => typeSize(f2))).reduce((acc, size) => acc + size, 0);
                });
                return Math.max(...variantSizes) + 1;
              }
              case "type": {
                return _IdlCoder.typeSize(typeDef.type.alias, idl, genericArgs);
              }
            }
          }
          if ("generic" in ty) {
            const genericArg = genericArgs === null || genericArgs === void 0 ? void 0 : genericArgs.at(0);
            if ((genericArg === null || genericArg === void 0 ? void 0 : genericArg.kind) !== "type") {
              throw new IdlError(`Invalid generic: ${ty.generic}`);
            }
            return _IdlCoder.typeSize(genericArg.type, idl, genericArgs);
          }
          throw new Error(`Invalid type ${JSON.stringify(ty)}`);
      }
    }
    /**
     * Resolve the generic array length or return the constant-sized array length.
     */
    static resolveArrayLen(len, genericArgs) {
      if (typeof len === "number")
        return len;
      if (genericArgs) {
        const genericLen = genericArgs.find((g) => g.kind === "const");
        if ((genericLen === null || genericLen === void 0 ? void 0 : genericLen.kind) === "const") {
          len = +genericLen.value;
        }
      }
      if (typeof len !== "number") {
        throw new IdlError("Generic array length did not resolve");
      }
      return len;
    }
    /**
     * Recursively resolve generic arguments i.e. replace all generics with the
     * actual type that they hold based on the initial `genericArgs` given.
     */
    static resolveGenericArgs({ type: type2, typeDef, genericArgs, isDefined }) {
      if (typeof type2 !== "object")
        return null;
      for (const index2 in typeDef.generics) {
        const defGeneric = typeDef.generics[index2];
        if ("generic" in type2 && defGeneric.name === type2.generic) {
          return [genericArgs[index2]];
        }
        if ("option" in type2) {
          const args = _IdlCoder.resolveGenericArgs({
            type: type2.option,
            typeDef,
            genericArgs,
            isDefined
          });
          if (!args || !isDefined)
            return args;
          if (args[0].kind === "type") {
            return [
              {
                kind: "type",
                type: { option: args[0].type }
              }
            ];
          }
        }
        if ("vec" in type2) {
          const args = _IdlCoder.resolveGenericArgs({
            type: type2.vec,
            typeDef,
            genericArgs,
            isDefined
          });
          if (!args || !isDefined)
            return args;
          if (args[0].kind === "type") {
            return [
              {
                kind: "type",
                type: { vec: args[0].type }
              }
            ];
          }
        }
        if ("array" in type2) {
          const [elTy, len] = type2.array;
          const isGenericLen = typeof len === "object";
          const args = _IdlCoder.resolveGenericArgs({
            type: elTy,
            typeDef,
            genericArgs,
            isDefined
          });
          if (args) {
            for (const i in typeDef.generics.slice(+index2)) {
              const curIndex = +index2 + +i;
              if (isGenericLen && typeDef.generics[curIndex].name === len.generic) {
                args.push(genericArgs[curIndex]);
              }
            }
            if (!isDefined)
              return args;
            if (args[0].kind === "type" && args[1].kind === "const") {
              return [
                {
                  kind: "type",
                  type: { array: [args[0].type, +args[1].value] }
                }
              ];
            }
          }
          if (isGenericLen && defGeneric.name === len.generic) {
            const arg = genericArgs[index2];
            if (!isDefined)
              return [arg];
            return [
              {
                kind: "type",
                type: { array: [elTy, +arg.value] }
              }
            ];
          }
          return null;
        }
        if ("defined" in type2) {
          if (!type2.defined.generics)
            return null;
          return type2.defined.generics.flatMap((g) => {
            switch (g.kind) {
              case "type":
                return _IdlCoder.resolveGenericArgs({
                  type: g.type,
                  typeDef,
                  genericArgs,
                  isDefined: true
                });
              case "const":
                return [g];
            }
          }).filter((g) => g !== null);
        }
      }
      return null;
    }
  };
  var BorshInstructionCoder = class {
    constructor(idl) {
      this.idl = idl;
      const ixLayouts = idl.instructions.map((ix) => {
        const name = ix.name;
        const fieldLayouts = ix.args.map((arg) => IdlCoder.fieldLayout(arg, idl.types));
        const layout = borsh.struct(fieldLayouts, name);
        return [name, { discriminator: ix.discriminator, layout }];
      });
      this.ixLayouts = new Map(ixLayouts);
      const sighashLayouts = ixLayouts.map(([name, { discriminator, layout }]) => {
        return [import_bs58.default.encode(discriminator), { name, layout }];
      });
      this.sighashLayouts = new Map(sighashLayouts);
    }
    /**
     * Encodes a program instruction.
     */
    encode(ixName, ix) {
      const buffer = import_buffer.Buffer.alloc(1e3);
      const encoder = this.ixLayouts.get(ixName);
      if (!encoder) {
        throw new Error(`Unknown method: ${ixName}`);
      }
      const len = encoder.layout.encode(ix, buffer);
      const data = buffer.slice(0, len);
      return import_buffer.Buffer.concat([import_buffer.Buffer.from(encoder.discriminator), data]);
    }
    /**
     * Decodes a program instruction.
     */
    decode(ix, encoding = "hex") {
      if (typeof ix === "string") {
        ix = encoding === "hex" ? import_buffer.Buffer.from(ix, "hex") : import_bs58.default.decode(ix);
      }
      const disc = ix.slice(0, DISCRIMINATOR_SIZE);
      const data = ix.slice(DISCRIMINATOR_SIZE);
      const decoder = this.sighashLayouts.get(import_bs58.default.encode(disc));
      if (!decoder) {
        return null;
      }
      return {
        name: decoder.name,
        data: decoder.layout.decode(data)
      };
    }
    /**
     * Returns a formatted table of all the fields in the given instruction data.
     */
    format(ix, accountMetas) {
      return InstructionFormatter.format(ix, accountMetas, this.idl);
    }
  };
  var InstructionFormatter = class _InstructionFormatter {
    static format(ix, accountMetas, idl) {
      const idlIx = idl.instructions.find((i) => ix.name === i.name);
      if (!idlIx) {
        console.error("Invalid instruction given");
        return null;
      }
      const args = idlIx.args.map((idlField) => {
        return {
          name: idlField.name,
          type: _InstructionFormatter.formatIdlType(idlField.type),
          data: _InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)
        };
      });
      const flatIdlAccounts = _InstructionFormatter.flattenIdlAccounts(idlIx.accounts);
      const accounts = accountMetas.map((meta, idx) => {
        if (idx < flatIdlAccounts.length) {
          return {
            name: flatIdlAccounts[idx].name,
            ...meta
          };
        } else {
          return {
            name: void 0,
            ...meta
          };
        }
      });
      return {
        args,
        accounts
      };
    }
    static formatIdlType(idlType) {
      if (typeof idlType === "string") {
        return idlType;
      }
      if ("option" in idlType) {
        return `Option<${this.formatIdlType(idlType.option)}>`;
      }
      if ("coption" in idlType) {
        return `COption<${this.formatIdlType(idlType.coption)}>`;
      }
      if ("vec" in idlType) {
        return `Vec<${this.formatIdlType(idlType.vec)}>`;
      }
      if ("array" in idlType) {
        return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;
      }
      if ("defined" in idlType) {
        const name = idlType.defined.name;
        if (idlType.defined.generics) {
          const generics = idlType.defined.generics.map((g) => {
            switch (g.kind) {
              case "type":
                return _InstructionFormatter.formatIdlType(g.type);
              case "const":
                return g.value;
            }
          }).join(", ");
          return `${name}<${generics}>`;
        }
        return name;
      }
      throw new Error(`Unknown IDL type: ${idlType}`);
    }
    static formatIdlData(idlField, data, types) {
      if (typeof idlField.type === "string") {
        return data.toString();
      }
      if ("vec" in idlField.type) {
        return "[" + data.map((d) => this.formatIdlData({ name: "", type: idlField.type.vec }, d, types)).join(", ") + "]";
      }
      if ("option" in idlField.type) {
        return data === null ? "null" : this.formatIdlData({ name: "", type: idlField.type.option }, data, types);
      }
      if ("defined" in idlField.type) {
        if (!types) {
          throw new Error("User defined types not provided");
        }
        const definedName = idlField.type.defined.name;
        const typeDef = types.find((t) => t.name === definedName);
        if (!typeDef) {
          throw new Error(`Type not found: ${definedName}`);
        }
        return _InstructionFormatter.formatIdlDataDefined(typeDef, data, types);
      }
      return "unknown";
    }
    static formatIdlDataDefined(typeDef, data, types) {
      switch (typeDef.type.kind) {
        case "struct": {
          return "{ " + handleDefinedFields(typeDef.type.fields, () => "", (fields) => {
            return Object.entries(data).map(([key, val]) => {
              const field = fields.find((f2) => f2.name === key);
              if (!field) {
                throw new Error(`Field not found: ${key}`);
              }
              return key + ": " + _InstructionFormatter.formatIdlData(field, val, types);
            }).join(", ");
          }, (fields) => {
            return Object.entries(data).map(([key, val]) => {
              return key + ": " + _InstructionFormatter.formatIdlData({ name: "", type: fields[key] }, val, types);
            }).join(", ");
          }) + " }";
        }
        case "enum": {
          const variantName = Object.keys(data)[0];
          const variant = typeDef.type.variants.find((v) => v.name === variantName);
          if (!variant) {
            throw new Error(`Unable to find variant: ${variantName}`);
          }
          const enumValue = data[variantName];
          return handleDefinedFields(variant.fields, () => variantName, (fields) => {
            const namedFields = Object.keys(enumValue).map((f2) => {
              const fieldData = enumValue[f2];
              const idlField = fields.find((v) => v.name === f2);
              if (!idlField) {
                throw new Error(`Field not found: ${f2}`);
              }
              return f2 + ": " + _InstructionFormatter.formatIdlData(idlField, fieldData, types);
            }).join(", ");
            return `${variantName} { ${namedFields} }`;
          }, (fields) => {
            const tupleFields = Object.entries(enumValue).map(([key, val]) => {
              return key + ": " + _InstructionFormatter.formatIdlData({ name: "", type: fields[key] }, val, types);
            }).join(", ");
            return `${variantName} { ${tupleFields} }`;
          });
        }
        case "type": {
          return _InstructionFormatter.formatIdlType(typeDef.type.alias);
        }
      }
    }
    static flattenIdlAccounts(accounts, prefix) {
      return accounts.map((account) => {
        const accName = sentenceCase(account.name);
        if (account.hasOwnProperty("accounts")) {
          const newPrefix = prefix ? `${prefix} > ${accName}` : accName;
          return _InstructionFormatter.flattenIdlAccounts(account.accounts, newPrefix);
        } else {
          return {
            ...account,
            name: prefix ? `${prefix} > ${accName}` : accName
          };
        }
      }).flat();
    }
  };
  function sentenceCase(field) {
    const result = field.replace(/([A-Z])/g, " $1");
    return result.charAt(0).toUpperCase() + result.slice(1);
  }
  var DISCRIMINATOR_SIZE = 8;
  var BorshAccountsCoder = class {
    constructor(idl) {
      this.idl = idl;
      if (!idl.accounts) {
        this.accountLayouts = /* @__PURE__ */ new Map();
        return;
      }
      const types = idl.types;
      if (!types) {
        throw new Error("Accounts require `idl.types`");
      }
      const layouts = idl.accounts.map((acc) => {
        const typeDef = types.find((ty) => ty.name === acc.name);
        if (!typeDef) {
          throw new Error(`Account not found: ${acc.name}`);
        }
        return [acc.name, IdlCoder.typeDefLayout({ typeDef, types })];
      });
      this.accountLayouts = new Map(layouts);
    }
    async encode(accountName, account) {
      const buffer = import_buffer.Buffer.alloc(1e3);
      const layout = this.accountLayouts.get(accountName);
      if (!layout) {
        throw new Error(`Unknown account: ${accountName}`);
      }
      const len = layout.encode(account, buffer);
      const accountData = buffer.slice(0, len);
      const discriminator = this.accountDiscriminator(accountName);
      return import_buffer.Buffer.concat([discriminator, accountData]);
    }
    decode(accountName, data) {
      const discriminator = this.accountDiscriminator(accountName);
      if (discriminator.compare(data.slice(0, DISCRIMINATOR_SIZE))) {
        throw new Error("Invalid account discriminator");
      }
      return this.decodeUnchecked(accountName, data);
    }
    decodeAny(data) {
      const discriminator = data.slice(0, DISCRIMINATOR_SIZE);
      const accountName = Array.from(this.accountLayouts.keys()).find((key) => this.accountDiscriminator(key).equals(discriminator));
      if (!accountName) {
        throw new Error("Account not found");
      }
      return this.decodeUnchecked(accountName, data);
    }
    decodeUnchecked(accountName, acc) {
      const data = acc.subarray(DISCRIMINATOR_SIZE);
      const layout = this.accountLayouts.get(accountName);
      if (!layout) {
        throw new Error(`Unknown account: ${accountName}`);
      }
      return layout.decode(data);
    }
    memcmp(accountName, appendData) {
      const discriminator = this.accountDiscriminator(accountName);
      return {
        offset: 0,
        bytes: import_bs58.default.encode(appendData ? import_buffer.Buffer.concat([discriminator, appendData]) : discriminator)
      };
    }
    size(accountName) {
      return DISCRIMINATOR_SIZE + IdlCoder.typeSize({ defined: { name: accountName } }, this.idl);
    }
    /**
     * Calculates and returns a unique 8 byte discriminator prepended to all anchor accounts.
     *
     * @param name The name of the account to calculate the discriminator.
     */
    accountDiscriminator(name) {
      var _a;
      const account = (_a = this.idl.accounts) === null || _a === void 0 ? void 0 : _a.find((acc) => acc.name === name);
      if (!account) {
        throw new Error(`Account not found: ${name}`);
      }
      return import_buffer.Buffer.from(account.discriminator);
    }
  };
  var BorshEventCoder = class {
    constructor(idl) {
      var _a;
      if (!idl.events) {
        this.layouts = /* @__PURE__ */ new Map();
        return;
      }
      const types = idl.types;
      if (!types) {
        throw new Error("Events require `idl.types`");
      }
      const layouts = idl.events.map((ev) => {
        const typeDef = types.find((ty) => ty.name === ev.name);
        if (!typeDef) {
          throw new Error(`Event not found: ${ev.name}`);
        }
        return [ev.name, IdlCoder.typeDefLayout({ typeDef, types })];
      });
      this.layouts = new Map(layouts);
      this.discriminators = new Map(((_a = idl.events) !== null && _a !== void 0 ? _a : []).map((ev) => [
        encode(import_buffer.Buffer.from(ev.discriminator)),
        ev.name
      ]));
    }
    decode(log) {
      let logArr;
      try {
        logArr = decode(log);
      } catch (e) {
        return null;
      }
      const disc = encode(logArr.slice(0, 8));
      const eventName = this.discriminators.get(disc);
      if (!eventName) {
        return null;
      }
      const layout = this.layouts.get(eventName);
      if (!layout) {
        throw new Error(`Unknown event: ${eventName}`);
      }
      const data = layout.decode(logArr.slice(8));
      return { data, name: eventName };
    }
  };
  var BorshTypesCoder = class {
    constructor(idl) {
      const types = idl.types;
      if (!types) {
        this.typeLayouts = /* @__PURE__ */ new Map();
        return;
      }
      const layouts = types.filter((ty) => !ty.generics).map((ty) => [
        ty.name,
        IdlCoder.typeDefLayout({ typeDef: ty, types })
      ]);
      this.typeLayouts = new Map(layouts);
    }
    encode(name, type2) {
      const buffer = import_buffer.Buffer.alloc(1e3);
      const layout = this.typeLayouts.get(name);
      if (!layout) {
        throw new Error(`Unknown type: ${name}`);
      }
      const len = layout.encode(type2, buffer);
      return buffer.slice(0, len);
    }
    decode(name, data) {
      const layout = this.typeLayouts.get(name);
      if (!layout) {
        throw new Error(`Unknown type: ${name}`);
      }
      return layout.decode(data);
    }
  };
  var BorshCoder = class {
    constructor(idl) {
      this.instruction = new BorshInstructionCoder(idl);
      this.accounts = new BorshAccountsCoder(idl);
      this.events = new BorshEventCoder(idl);
      this.types = new BorshTypesCoder(idl);
    }
  };
  var Layout = class {
    constructor(span, property) {
      if (!Number.isInteger(span)) {
        throw new TypeError("span must be an integer");
      }
      this.span = span;
      this.property = property;
    }
    /** Function to create an Object into which decoded properties will
     * be written.
     *
     * Used only for layouts that {@link Layout#decode|decode} to Object
     * instances, which means:
     * * {@link Structure}
     * * {@link Union}
     * * {@link VariantLayout}
     * * {@link BitStructure}
     *
     * If left undefined the JavaScript representation of these layouts
     * will be Object instances.
     *
     * See {@link bindConstructorLayout}.
     */
    makeDestinationObject() {
      return {};
    }
    /**
     * Decode from a Buffer into an JavaScript value.
     *
     * @param {Buffer} b - the buffer from which encoded data is read.
     *
     * @param {Number} [offset] - the offset at which the encoded data
     * starts.  If absent a zero offset is inferred.
     *
     * @returns {(Number|Array|Object)} - the value of the decoded data.
     *
     * @abstract
     */
    decode(b, offset2) {
      throw new Error("Layout is abstract");
    }
    /**
     * Encode a JavaScript value into a Buffer.
     *
     * @param {(Number|Array|Object)} src - the value to be encoded into
     * the buffer.  The type accepted depends on the (sub-)type of {@link
     * Layout}.
     *
     * @param {Buffer} b - the buffer into which encoded data will be
     * written.
     *
     * @param {Number} [offset] - the offset at which the encoded data
     * starts.  If absent a zero offset is inferred.
     *
     * @returns {Number} - the number of bytes encoded, including the
     * space skipped for internal padding, but excluding data such as
     * {@link Sequence#count|lengths} when stored {@link
     * ExternalLayout|externally}.  This is the adjustment to `offset`
     * producing the offset where data for the next layout would be
     * written.
     *
     * @abstract
     */
    encode(src, b, offset2) {
      throw new Error("Layout is abstract");
    }
    /**
     * Calculate the span of a specific instance of a layout.
     *
     * @param {Buffer} b - the buffer that contains an encoded instance.
     *
     * @param {Number} [offset] - the offset at which the encoded instance
     * starts.  If absent a zero offset is inferred.
     *
     * @return {Number} - the number of bytes covered by the layout
     * instance.  If this method is not overridden in a subclass the
     * definition-time constant {@link Layout#span|span} will be
     * returned.
     *
     * @throws {RangeError} - if the length of the value cannot be
     * determined.
     */
    getSpan(b, offset2) {
      if (0 > this.span) {
        throw new RangeError("indeterminate span");
      }
      return this.span;
    }
    /**
     * Replicate the layout using a new property.
     *
     * This function must be used to get a structurally-equivalent layout
     * with a different name since all {@link Layout} instances are
     * immutable.
     *
     * **NOTE** This is a shallow copy.  All fields except {@link
     * Layout#property|property} are strictly equal to the origin layout.
     *
     * @param {String} property - the value for {@link
     * Layout#property|property} in the replica.
     *
     * @returns {Layout} - the copy with {@link Layout#property|property}
     * set to `property`.
     */
    replicate(property) {
      const rv = Object.create(this.constructor.prototype);
      Object.assign(rv, this);
      rv.property = property;
      return rv;
    }
    /**
     * Create an object from layout properties and an array of values.
     *
     * **NOTE** This function returns `undefined` if invoked on a layout
     * that does not return its value as an Object.  Objects are
     * returned for things that are a {@link Structure}, which includes
     * {@link VariantLayout|variant layouts} if they are structures, and
     * excludes {@link Union}s.  If you want this feature for a union
     * you must use {@link Union.getVariant|getVariant} to select the
     * desired layout.
     *
     * @param {Array} values - an array of values that correspond to the
     * default order for properties.  As with {@link Layout#decode|decode}
     * layout elements that have no property name are skipped when
     * iterating over the array values.  Only the top-level properties are
     * assigned; arguments are not assigned to properties of contained
     * layouts.  Any unused values are ignored.
     *
     * @return {(Object|undefined)}
     */
    fromArray(values) {
      return void 0;
    }
  };
  var Layout_2 = Layout;
  function nameWithProperty(name, lo) {
    if (lo.property) {
      return name + "[" + lo.property + "]";
    }
    return name;
  }
  var ExternalLayout = class extends Layout {
    /**
     * Return `true` iff the external layout decodes to an unsigned
     * integer layout.
     *
     * In that case it can be used as the source of {@link
     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
     * or as {@link UnionLayoutDiscriminator#layout|external union
     * discriminators}.
     *
     * @abstract
     */
    isCount() {
      throw new Error("ExternalLayout is abstract");
    }
  };
  var OffsetLayout = class extends ExternalLayout {
    constructor(layout, offset2, property) {
      if (!(layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (void 0 === offset2) {
        offset2 = 0;
      } else if (!Number.isInteger(offset2)) {
        throw new TypeError("offset must be integer or undefined");
      }
      super(layout.span, property || layout.property);
      this.layout = layout;
      this.offset = offset2;
    }
    /** @override */
    isCount() {
      return this.layout instanceof UInt || this.layout instanceof UIntBE;
    }
    /** @override */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      return this.layout.decode(b, offset2 + this.offset);
    }
    /** @override */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      return this.layout.encode(src, b, offset2 + this.offset);
    }
  };
  var UInt = class extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    /** @override */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      return b.readUIntLE(offset2, this.span);
    }
    /** @override */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      b.writeUIntLE(src, offset2, this.span);
      return this.span;
    }
  };
  var UIntBE = class extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    /** @override */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      return b.readUIntBE(offset2, this.span);
    }
    /** @override */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      b.writeUIntBE(src, offset2, this.span);
      return this.span;
    }
  };
  var V2E32 = Math.pow(2, 32);
  function divmodInt64(src) {
    const hi32 = Math.floor(src / V2E32);
    const lo32 = src - hi32 * V2E32;
    return { hi32, lo32 };
  }
  function roundedInt64(hi32, lo32) {
    return hi32 * V2E32 + lo32;
  }
  var NearUInt64 = class extends Layout {
    constructor(property) {
      super(8, property);
    }
    /** @override */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const lo32 = b.readUInt32LE(offset2);
      const hi32 = b.readUInt32LE(offset2 + 4);
      return roundedInt64(hi32, lo32);
    }
    /** @override */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const split = divmodInt64(src);
      b.writeUInt32LE(split.lo32, offset2);
      b.writeUInt32LE(split.hi32, offset2 + 4);
      return 8;
    }
  };
  var NearInt64 = class extends Layout {
    constructor(property) {
      super(8, property);
    }
    /** @override */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const lo32 = b.readUInt32LE(offset2);
      const hi32 = b.readInt32LE(offset2 + 4);
      return roundedInt64(hi32, lo32);
    }
    /** @override */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const split = divmodInt64(src);
      b.writeUInt32LE(split.lo32, offset2);
      b.writeInt32LE(split.hi32, offset2 + 4);
      return 8;
    }
  };
  var Structure = class extends Layout {
    constructor(fields, property, decodePrefixes) {
      if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout, true))) {
        throw new TypeError("fields must be array of Layout instances");
      }
      if ("boolean" === typeof property && void 0 === decodePrefixes) {
        decodePrefixes = property;
        property = void 0;
      }
      for (const fd of fields) {
        if (0 > fd.span && void 0 === fd.property) {
          throw new Error("fields cannot contain unnamed variable-length layout");
        }
      }
      let span = -1;
      try {
        span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
      } catch (e) {
      }
      super(span, property);
      this.fields = fields;
      this.decodePrefixes = !!decodePrefixes;
    }
    /** @override */
    getSpan(b, offset2) {
      if (0 <= this.span) {
        return this.span;
      }
      if (void 0 === offset2) {
        offset2 = 0;
      }
      let span = 0;
      try {
        span = this.fields.reduce((span2, fd) => {
          const fsp = fd.getSpan(b, offset2);
          offset2 += fsp;
          return span2 + fsp;
        }, 0);
      } catch (e) {
        throw new RangeError("indeterminate span");
      }
      return span;
    }
    /** @override */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (void 0 !== fd.property) {
          dest[fd.property] = fd.decode(b, offset2);
        }
        offset2 += fd.getSpan(b, offset2);
        if (this.decodePrefixes && b.length === offset2) {
          break;
        }
      }
      return dest;
    }
    /** Implement {@link Layout#encode|encode} for {@link Structure}.
     *
     * If `src` is missing a property for a member with a defined {@link
     * Layout#property|property} the corresponding region of the buffer is
     * left unmodified. */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const firstOffset = offset2;
      let lastOffset = 0;
      let lastWrote = 0;
      for (const fd of this.fields) {
        let span = fd.span;
        lastWrote = 0 < span ? span : 0;
        if (void 0 !== fd.property) {
          const fv = src[fd.property];
          if (void 0 !== fv) {
            lastWrote = fd.encode(fv, b, offset2);
            if (0 > span) {
              span = fd.getSpan(b, offset2);
            }
          }
        }
        lastOffset = offset2;
        offset2 += span;
      }
      return lastOffset + lastWrote - firstOffset;
    }
    /** @override */
    fromArray(values) {
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (void 0 !== fd.property && 0 < values.length) {
          dest[fd.property] = values.shift();
        }
      }
      return dest;
    }
    /**
     * Get access to the layout of a given property.
     *
     * @param {String} property - the structure member of interest.
     *
     * @return {Layout} - the layout associated with `property`, or
     * undefined if there is no such property.
     */
    layoutFor(property) {
      if ("string" !== typeof property) {
        throw new TypeError("property must be string");
      }
      for (const fd of this.fields) {
        if (fd.property === property) {
          return fd;
        }
      }
    }
    /**
     * Get the offset of a structure member.
     *
     * @param {String} property - the structure member of interest.
     *
     * @return {Number} - the offset in bytes to the start of `property`
     * within the structure, or undefined if `property` is not a field
     * within the structure.  If the property is a member but follows a
     * variable-length structure member a negative number will be
     * returned.
     */
    offsetOf(property) {
      if ("string" !== typeof property) {
        throw new TypeError("property must be string");
      }
      let offset2 = 0;
      for (const fd of this.fields) {
        if (fd.property === property) {
          return offset2;
        }
        if (0 > fd.span) {
          offset2 = -1;
        } else if (0 <= offset2) {
          offset2 += fd.span;
        }
      }
    }
  };
  var UnionDiscriminator = class {
    constructor(property) {
      this.property = property;
    }
    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
     *
     * The implementation of this method need not reference the buffer if
     * variant information is available through other means. */
    decode() {
      throw new Error("UnionDiscriminator is abstract");
    }
    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
     *
     * The implementation of this method need not store the value if
     * variant information is maintained through other means. */
    encode() {
      throw new Error("UnionDiscriminator is abstract");
    }
  };
  var UnionLayoutDiscriminator = class extends UnionDiscriminator {
    constructor(layout, property) {
      if (!(layout instanceof ExternalLayout && layout.isCount())) {
        throw new TypeError("layout must be an unsigned integer ExternalLayout");
      }
      super(property || layout.property || "variant");
      this.layout = layout;
    }
    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
    decode(b, offset2) {
      return this.layout.decode(b, offset2);
    }
    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
    encode(src, b, offset2) {
      return this.layout.encode(src, b, offset2);
    }
  };
  var Union = class extends Layout {
    constructor(discr, defaultLayout, property) {
      const upv = discr instanceof UInt || discr instanceof UIntBE;
      if (upv) {
        discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));
      } else if (discr instanceof ExternalLayout && discr.isCount()) {
        discr = new UnionLayoutDiscriminator(discr);
      } else if (!(discr instanceof UnionDiscriminator)) {
        throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
      }
      if (void 0 === defaultLayout) {
        defaultLayout = null;
      }
      if (!(null === defaultLayout || defaultLayout instanceof Layout)) {
        throw new TypeError("defaultLayout must be null or a Layout");
      }
      if (null !== defaultLayout) {
        if (0 > defaultLayout.span) {
          throw new Error("defaultLayout must have constant span");
        }
        if (void 0 === defaultLayout.property) {
          defaultLayout = defaultLayout.replicate("content");
        }
      }
      let span = -1;
      if (defaultLayout) {
        span = defaultLayout.span;
        if (0 <= span && upv) {
          span += discr.layout.span;
        }
      }
      super(span, property);
      this.discriminator = discr;
      this.usesPrefixDiscriminator = upv;
      this.defaultLayout = defaultLayout;
      this.registry = {};
      let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
      this.getSourceVariant = function(src) {
        return boundGetSourceVariant(src);
      };
      this.configGetSourceVariant = function(gsv) {
        boundGetSourceVariant = gsv.bind(this);
      };
    }
    /** @override */
    getSpan(b, offset2) {
      if (0 <= this.span) {
        return this.span;
      }
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const vlo = this.getVariant(b, offset2);
      if (!vlo) {
        throw new Error("unable to determine span for unrecognized variant");
      }
      return vlo.getSpan(b, offset2);
    }
    /**
     * Method to infer a registered Union variant compatible with `src`.
     *
     * The first satisified rule in the following sequence defines the
     * return value:
     * * If `src` has properties matching the Union discriminator and
     *   the default layout, `undefined` is returned regardless of the
     *   value of the discriminator property (this ensures the default
     *   layout will be used);
     * * If `src` has a property matching the Union discriminator, the
     *   value of the discriminator identifies a registered variant, and
     *   either (a) the variant has no layout, or (b) `src` has the
     *   variant's property, then the variant is returned (because the
     *   source satisfies the constraints of the variant it identifies);
     * * If `src` does not have a property matching the Union
     *   discriminator, but does have a property matching a registered
     *   variant, then the variant is returned (because the source
     *   matches a variant without an explicit conflict);
     * * An error is thrown (because we either can't identify a variant,
     *   or we were explicitly told the variant but can't satisfy it).
     *
     * @param {Object} src - an object presumed to be compatible with
     * the content of the Union.
     *
     * @return {(undefined|VariantLayout)} - as described above.
     *
     * @throws {Error} - if `src` cannot be associated with a default or
     * registered variant.
     */
    defaultGetSourceVariant(src) {
      if (src.hasOwnProperty(this.discriminator.property)) {
        if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
          return void 0;
        }
        const vlo = this.registry[src[this.discriminator.property]];
        if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
          return vlo;
        }
      } else {
        for (const tag in this.registry) {
          const vlo = this.registry[tag];
          if (src.hasOwnProperty(vlo.property)) {
            return vlo;
          }
        }
      }
      throw new Error("unable to infer src variant");
    }
    /** Implement {@link Layout#decode|decode} for {@link Union}.
     *
     * If the variant is {@link Union#addVariant|registered} the return
     * value is an instance of that variant, with no explicit
     * discriminator.  Otherwise the {@link Union#defaultLayout|default
     * layout} is used to decode the content. */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      let dest;
      const dlo = this.discriminator;
      const discr = dlo.decode(b, offset2);
      let clo = this.registry[discr];
      if (void 0 === clo) {
        let contentOffset = 0;
        clo = this.defaultLayout;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dest = this.makeDestinationObject();
        dest[dlo.property] = discr;
        dest[clo.property] = this.defaultLayout.decode(b, offset2 + contentOffset);
      } else {
        dest = clo.decode(b, offset2);
      }
      return dest;
    }
    /** Implement {@link Layout#encode|encode} for {@link Union}.
     *
     * This API assumes the `src` object is consistent with the union's
     * {@link Union#defaultLayout|default layout}.  To encode variants
     * use the appropriate variant-specific {@link VariantLayout#encode}
     * method. */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const vlo = this.getSourceVariant(src);
      if (void 0 === vlo) {
        const dlo = this.discriminator;
        const clo = this.defaultLayout;
        let contentOffset = 0;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dlo.encode(src[dlo.property], b, offset2);
        return contentOffset + clo.encode(
          src[clo.property],
          b,
          offset2 + contentOffset
        );
      }
      return vlo.encode(src, b, offset2);
    }
    /** Register a new variant structure within a union.  The newly
     * created variant is returned.
     *
     * @param {Number} variant - initializer for {@link
     * VariantLayout#variant|variant}.
     *
     * @param {Layout} layout - initializer for {@link
     * VariantLayout#layout|layout}.
     *
     * @param {String} property - initializer for {@link
     * Layout#property|property}.
     *
     * @return {VariantLayout} */
    addVariant(variant, layout, property) {
      const rv = new VariantLayout(this, variant, layout, property);
      this.registry[variant] = rv;
      return rv;
    }
    /**
     * Get the layout associated with a registered variant.
     *
     * If `vb` does not produce a registered variant the function returns
     * `undefined`.
     *
     * @param {(Number|Buffer)} vb - either the variant number, or a
     * buffer from which the discriminator is to be read.
     *
     * @param {Number} offset - offset into `vb` for the start of the
     * union.  Used only when `vb` is an instance of {Buffer}.
     *
     * @return {({VariantLayout}|undefined)}
     */
    getVariant(vb, offset2) {
      let variant = vb;
      if (Buffer.isBuffer(vb)) {
        if (void 0 === offset2) {
          offset2 = 0;
        }
        variant = this.discriminator.decode(vb, offset2);
      }
      return this.registry[variant];
    }
  };
  var VariantLayout = class extends Layout {
    constructor(union2, variant, layout, property) {
      if (!(union2 instanceof Union)) {
        throw new TypeError("union must be a Union");
      }
      if (!Number.isInteger(variant) || 0 > variant) {
        throw new TypeError("variant must be a (non-negative) integer");
      }
      if ("string" === typeof layout && void 0 === property) {
        property = layout;
        layout = null;
      }
      if (layout) {
        if (!(layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (null !== union2.defaultLayout && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
          throw new Error("variant span exceeds span of containing union");
        }
        if ("string" !== typeof property) {
          throw new TypeError("variant must have a String property");
        }
      }
      let span = union2.span;
      if (0 > union2.span) {
        span = layout ? layout.span : 0;
        if (0 <= span && union2.usesPrefixDiscriminator) {
          span += union2.discriminator.layout.span;
        }
      }
      super(span, property);
      this.union = union2;
      this.variant = variant;
      this.layout = layout || null;
    }
    /** @override */
    getSpan(b, offset2) {
      if (0 <= this.span) {
        return this.span;
      }
      if (void 0 === offset2) {
        offset2 = 0;
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      return contentOffset + this.layout.getSpan(b, offset2 + contentOffset);
    }
    /** @override */
    decode(b, offset2) {
      const dest = this.makeDestinationObject();
      if (void 0 === offset2) {
        offset2 = 0;
      }
      if (this !== this.union.getVariant(b, offset2)) {
        throw new Error("variant mismatch");
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout) {
        dest[this.property] = this.layout.decode(b, offset2 + contentOffset);
      } else if (this.property) {
        dest[this.property] = true;
      } else if (this.union.usesPrefixDiscriminator) {
        dest[this.union.discriminator.property] = this.variant;
      }
      return dest;
    }
    /** @override */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout && !src.hasOwnProperty(this.property)) {
        throw new TypeError("variant lacks property " + this.property);
      }
      this.union.discriminator.encode(this.variant, b, offset2);
      let span = contentOffset;
      if (this.layout) {
        this.layout.encode(src[this.property], b, offset2 + contentOffset);
        span += this.layout.getSpan(b, offset2 + contentOffset);
        if (0 <= this.union.span && span > this.union.span) {
          throw new Error("encoded variant overruns containing union");
        }
      }
      return span;
    }
    /** Delegate {@link Layout#fromArray|fromArray} to {@link
     * VariantLayout#layout|layout}. */
    fromArray(values) {
      if (this.layout) {
        return this.layout.fromArray(values);
      }
    }
  };
  var Blob$1 = class extends Layout {
    constructor(length, property) {
      if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
        throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
      }
      let span = -1;
      if (!(length instanceof ExternalLayout)) {
        span = length;
      }
      super(span, property);
      this.length = length;
    }
    /** @override */
    getSpan(b, offset2) {
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b, offset2);
      }
      return span;
    }
    /** @override */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b, offset2);
      }
      return b.slice(offset2, offset2 + span);
    }
    /** Implement {@link Layout#encode|encode} for {@link Blob}.
     *
     * **NOTE** If {@link Layout#count|count} is an instance of {@link
     * ExternalLayout} then the length of `src` will be encoded as the
     * count after `src` is encoded. */
    encode(src, b, offset2) {
      let span = this.length;
      if (this.length instanceof ExternalLayout) {
        span = src.length;
      }
      if (!(Buffer.isBuffer(src) && span === src.length)) {
        throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
      }
      if (offset2 + span > b.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      b.write(src.toString("hex"), offset2, span, "hex");
      if (this.length instanceof ExternalLayout) {
        this.length.encode(span, b, offset2);
      }
      return span;
    }
  };
  var offset = ((layout, offset2, property) => new OffsetLayout(layout, offset2, property));
  var u82 = ((property) => new UInt(1, property));
  var u322 = ((property) => new UInt(4, property));
  var nu64 = ((property) => new NearUInt64(property));
  var ns64 = ((property) => new NearInt64(property));
  var struct2 = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));
  var union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));
  var blob = ((length, property) => new Blob$1(length, property));
  var SystemInstructionCoder = class {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    constructor(_) {
    }
    encode(ixName, ix) {
      switch (ixName) {
        case "createAccount": {
          return encodeCreateAccount(ix);
        }
        case "assign": {
          return encodeAssign(ix);
        }
        case "transfer": {
          return encodeTransfer(ix);
        }
        case "createAccountWithSeed": {
          return encodeCreateAccountWithSeed(ix);
        }
        case "advanceNonceAccount": {
          return encodeAdvanceNonceAccount(ix);
        }
        case "withdrawNonceAccount": {
          return encodeWithdrawNonceAccount(ix);
        }
        case "initializeNonceAccount": {
          return encodeInitializeNonceAccount(ix);
        }
        case "authorizeNonceAccount": {
          return encodeAuthorizeNonceAccount(ix);
        }
        case "allocate": {
          return encodeAllocate(ix);
        }
        case "allocateWithSeed": {
          return encodeAllocateWithSeed(ix);
        }
        case "assignWithSeed": {
          return encodeAssignWithSeed(ix);
        }
        case "transferWithSeed": {
          return encodeTransferWithSeed(ix);
        }
        default: {
          throw new Error(`Invalid instruction: ${ixName}`);
        }
      }
    }
    encodeState(_ixName, _ix) {
      throw new Error("System does not have state");
    }
  };
  var RustStringLayout = class extends Layout_2 {
    constructor(property) {
      super(-1, property);
      this.property = property;
      this.layout = struct2([
        u322("length"),
        u322("lengthPadding"),
        blob(offset(u322(), -8), "chars")
      ], this.property);
    }
    encode(src, b, offset2 = 0) {
      if (src === null || src === void 0) {
        return this.layout.span;
      }
      const data = {
        chars: Buffer.from(src, "utf8")
      };
      return this.layout.encode(data, b, offset2);
    }
    decode(b, offset2 = 0) {
      const data = this.layout.decode(b, offset2);
      return data["chars"].toString();
    }
    getSpan(b, offset2 = 0) {
      return u322().span + u322().span + new import_bn.default(new Uint8Array(b).slice(offset2, offset2 + 4), 10, "le").toNumber();
    }
  };
  function rustStringLayout(property) {
    return new RustStringLayout(property);
  }
  function publicKey$2(property) {
    return blob(32, property);
  }
  function encodeCreateAccount({ lamports, space, owner }) {
    return encodeData({
      createAccount: { lamports, space, owner: owner.toBuffer() }
    });
  }
  function encodeAssign({ owner }) {
    return encodeData({
      assign: { owner: owner.toBuffer() }
    });
  }
  function encodeTransfer({ lamports }) {
    return encodeData({
      transfer: { lamports }
    });
  }
  function encodeCreateAccountWithSeed({ base, seed: seed2, lamports, space, owner }) {
    return encodeData({
      createAccountWithSeed: {
        base: base.toBuffer(),
        seed: seed2,
        lamports,
        space,
        owner: owner.toBuffer()
      }
    }, LAYOUT.getVariant(3).span + seed2.length);
  }
  function encodeInitializeNonceAccount({ authorized }) {
    return encodeData({
      initializeNonceAccount: { authorized: authorized.toBuffer() }
    });
  }
  function encodeAdvanceNonceAccount({ authorized }) {
    return encodeData({
      advanceNonceAccount: { authorized: authorized.toBuffer() }
    });
  }
  function encodeWithdrawNonceAccount({ lamports }) {
    return encodeData({
      withdrawNonceAccount: { lamports }
    });
  }
  function encodeAuthorizeNonceAccount({ authorized }) {
    return encodeData({
      authorizeNonceAccount: { authorized: authorized.toBuffer() }
    });
  }
  function encodeAllocate({ space }) {
    return encodeData({
      allocate: { space }
    });
  }
  function encodeAllocateWithSeed({ base, seed: seed2, space, owner }) {
    return encodeData({
      allocateWithSeed: {
        base: base.toBuffer(),
        seed: seed2,
        space,
        owner: owner.toBuffer()
      }
    }, LAYOUT.getVariant(9).span + seed2.length);
  }
  function encodeAssignWithSeed({ base, seed: seed2, owner }) {
    return encodeData({
      assignWithSeed: {
        base: base.toBuffer(),
        seed: seed2,
        owner: owner.toBuffer()
      }
    }, LAYOUT.getVariant(10).span + seed2.length);
  }
  function encodeTransferWithSeed({ lamports, seed: seed2, owner }) {
    return encodeData({
      transferWithSeed: {
        lamports,
        seed: seed2,
        owner: owner.toBuffer()
      }
    }, LAYOUT.getVariant(11).span + seed2.length);
  }
  var LAYOUT = union(u322("instruction"));
  LAYOUT.addVariant(0, struct2([
    ns64("lamports"),
    ns64("space"),
    publicKey$2("owner")
  ]), "createAccount");
  LAYOUT.addVariant(1, struct2([publicKey$2("owner")]), "assign");
  LAYOUT.addVariant(2, struct2([ns64("lamports")]), "transfer");
  LAYOUT.addVariant(3, struct2([
    publicKey$2("base"),
    rustStringLayout("seed"),
    ns64("lamports"),
    ns64("space"),
    publicKey$2("owner")
  ]), "createAccountWithSeed");
  LAYOUT.addVariant(4, struct2([publicKey$2("authorized")]), "advanceNonceAccount");
  LAYOUT.addVariant(5, struct2([ns64("lamports")]), "withdrawNonceAccount");
  LAYOUT.addVariant(6, struct2([publicKey$2("authorized")]), "initializeNonceAccount");
  LAYOUT.addVariant(7, struct2([publicKey$2("authorized")]), "authorizeNonceAccount");
  LAYOUT.addVariant(8, struct2([ns64("space")]), "allocate");
  LAYOUT.addVariant(9, struct2([
    publicKey$2("base"),
    rustStringLayout("seed"),
    ns64("space"),
    publicKey$2("owner")
  ]), "allocateWithSeed");
  LAYOUT.addVariant(10, struct2([
    publicKey$2("base"),
    rustStringLayout("seed"),
    publicKey$2("owner")
  ]), "assignWithSeed");
  LAYOUT.addVariant(11, struct2([
    ns64("lamports"),
    rustStringLayout("seed"),
    publicKey$2("owner")
  ]), "transferWithSeed");
  function encodeData(instruction, maxSpan) {
    const b = Buffer.alloc(maxSpan !== null && maxSpan !== void 0 ? maxSpan : instructionMaxSpan);
    const span = LAYOUT.encode(instruction, b);
    if (maxSpan === void 0) {
      return b.slice(0, span);
    }
    return b;
  }
  var instructionMaxSpan = Math.max(...Object.values(LAYOUT.registry).map((r) => r.span));
  var SystemAccountsCoder = class {
    constructor(idl) {
      this.idl = idl;
    }
    async encode(accountName, account) {
      switch (accountName) {
        case "nonce": {
          const buffer = Buffer.alloc(import_web3.NONCE_ACCOUNT_LENGTH);
          const len = NONCE_ACCOUNT_LAYOUT.encode(account, buffer);
          return buffer.slice(0, len);
        }
        default: {
          throw new Error(`Invalid account name: ${accountName}`);
        }
      }
    }
    decode(accountName, ix) {
      return this.decodeUnchecked(accountName, ix);
    }
    decodeUnchecked(accountName, ix) {
      switch (accountName) {
        case "nonce": {
          return decodeNonceAccount(ix);
        }
        default: {
          throw new Error(`Invalid account name: ${accountName}`);
        }
      }
    }
    // TODO: this won't use the appendData.
    memcmp(accountName, _appendData) {
      switch (accountName) {
        case "nonce": {
          return {
            dataSize: import_web3.NONCE_ACCOUNT_LENGTH
          };
        }
        default: {
          throw new Error(`Invalid account name: ${accountName}`);
        }
      }
    }
    size(accountName) {
      return IdlCoder.typeSize({ defined: { name: accountName } }, this.idl);
    }
  };
  function decodeNonceAccount(ix) {
    return NONCE_ACCOUNT_LAYOUT.decode(ix);
  }
  var WrappedLayout$1 = class extends Layout_2 {
    constructor(layout, decoder, encoder, property) {
      super(layout.span, property);
      this.layout = layout;
      this.decoder = decoder;
      this.encoder = encoder;
    }
    decode(b, offset2) {
      return this.decoder(this.layout.decode(b, offset2));
    }
    encode(src, b, offset2) {
      return this.layout.encode(this.encoder(src), b, offset2);
    }
    getSpan(b, offset2) {
      return this.layout.getSpan(b, offset2);
    }
  };
  function publicKey$1(property) {
    return new WrappedLayout$1(blob(32), (b) => new import_web3.PublicKey(b), (key) => key.toBuffer(), property);
  }
  var NONCE_ACCOUNT_LAYOUT = struct2([
    u322("version"),
    u322("state"),
    publicKey$1("authorizedPubkey"),
    publicKey$1("nonce"),
    struct2([nu64("lamportsPerSignature")], "feeCalculator")
  ]);
  var SystemEventsCoder = class {
    constructor(_idl) {
    }
    decode(_log) {
      throw new Error("System program does not have events");
    }
  };
  var SystemTypesCoder = class {
    constructor(_idl) {
    }
    encode(_name, _type) {
      throw new Error("System does not have user-defined types");
    }
    decode(_name, _typeData) {
      throw new Error("System does not have user-defined types");
    }
  };
  var SystemCoder = class {
    constructor(idl) {
      this.instruction = new SystemInstructionCoder(idl);
      this.accounts = new SystemAccountsCoder(idl);
      this.events = new SystemEventsCoder(idl);
      this.types = new SystemTypesCoder(idl);
    }
  };
  function hash(data) {
    return new TextDecoder().decode(sha2562(data));
  }
  var sha2563 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    hash
  });
  function createWithSeedSync(fromPublicKey, seed2, programId) {
    const buffer = import_buffer.Buffer.concat([
      fromPublicKey.toBuffer(),
      import_buffer.Buffer.from(seed2),
      programId.toBuffer()
    ]);
    return new import_web3.PublicKey(sha2562(buffer));
  }
  var pubkey = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    createWithSeedSync
  });
  var TOKEN_PROGRAM_ID = new import_web3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
  var ASSOCIATED_PROGRAM_ID = new import_web3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
  function associatedAddress({ mint, owner }) {
    return import_web3.PublicKey.findProgramAddressSync([owner.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()], ASSOCIATED_PROGRAM_ID)[0];
  }
  var token = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    TOKEN_PROGRAM_ID,
    ASSOCIATED_PROGRAM_ID,
    associatedAddress
  });
  var browserPonyfill = { exports: {} };
  (function(module, exports) {
    var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
    var __self__ = (function() {
      function F() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F.prototype = global2;
      return new F();
    })();
    (function(self2) {
      (function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && (function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          })(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob2) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob2);
          return promise;
        }
        function readBlobAsText(blob2) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob2);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode2);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode2(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err2) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch2;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      })({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  })(browserPonyfill, browserPonyfill.exports);
  var fetch = /* @__PURE__ */ getDefaultExportFromCjs(browserPonyfill.exports);
  async function verifiedBuild(connection, programId, limit = 5) {
    const url = `https://api.apr.dev/api/v0/program/${programId.toString()}/latest?limit=${limit}`;
    const [programData, latestBuildsResp] = await Promise.all([
      fetchData(connection, programId),
      fetch(url)
    ]);
    const latestBuilds = (await latestBuildsResp.json()).filter((b) => !b.aborted && b.state === "Built" && b.verified === "Verified");
    if (latestBuilds.length === 0) {
      return null;
    }
    const build = latestBuilds[0];
    if (programData.slot.toNumber() !== build.verified_slot) {
      return null;
    }
    return build;
  }
  async function fetchData(connection, programId) {
    const accountInfo = await connection.getAccountInfo(programId);
    if (accountInfo === null) {
      throw new Error("program account not found");
    }
    const { program: program2 } = decodeUpgradeableLoaderState(accountInfo.data);
    const programdataAccountInfo = await connection.getAccountInfo(program2.programdataAddress);
    if (programdataAccountInfo === null) {
      throw new Error("program data account not found");
    }
    const { programData } = decodeUpgradeableLoaderState(programdataAccountInfo.data);
    return programData;
  }
  var UPGRADEABLE_LOADER_STATE_LAYOUT = borsh.rustEnum([
    borsh.struct([], "uninitialized"),
    borsh.struct([borsh.option(borsh.publicKey(), "authorityAddress")], "buffer"),
    borsh.struct([borsh.publicKey("programdataAddress")], "program"),
    borsh.struct([
      borsh.u64("slot"),
      borsh.option(borsh.publicKey(), "upgradeAuthorityAddress")
    ], "programData")
  ], void 0, borsh.u32());
  function decodeUpgradeableLoaderState(data) {
    return UPGRADEABLE_LOADER_STATE_LAYOUT.decode(data);
  }
  var registry = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    verifiedBuild,
    fetchData,
    decodeUpgradeableLoaderState
  });
  var index = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    sha256: sha2563,
    rpc,
    publicKey: pubkey,
    bytes: index$1,
    token,
    features,
    registry
  });
  function splitArgsAndCtx(idlIx, args) {
    var _a, _b;
    let options = {};
    const inputLen = idlIx.args ? idlIx.args.length : 0;
    if (args.length > inputLen) {
      if (args.length !== inputLen + 1) {
        throw new Error(`provided too many arguments ${args} to instruction ${idlIx === null || idlIx === void 0 ? void 0 : idlIx.name} expecting: ${(_b = (_a = idlIx.args) === null || _a === void 0 ? void 0 : _a.map((a) => a.name)) !== null && _b !== void 0 ? _b : []}`);
      }
      options = args.pop();
    }
    return [args, options];
  }
  var InstructionNamespaceFactory = class _InstructionNamespaceFactory {
    static build(idlIx, encodeFn, programId) {
      if (idlIx.name === "_inner") {
        throw new IdlError("the _inner name is reserved");
      }
      const ix = (...args) => {
        const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);
        validateAccounts(idlIx.accounts, ctx.accounts);
        validateInstruction(idlIx, ...args);
        const keys = ix.accounts(ctx.accounts);
        if (ctx.remainingAccounts !== void 0) {
          keys.push(...ctx.remainingAccounts);
        }
        if (isSet("debug-logs")) {
          console.log("Outgoing account metas:", keys);
        }
        return new import_web3.TransactionInstruction({
          keys,
          programId,
          data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs))
        });
      };
      ix["accounts"] = (accs) => {
        return _InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts, programId, idlIx.name);
      };
      return ix;
    }
    static accountsArray(ctx, accounts, programId, ixName) {
      if (!ctx) {
        return [];
      }
      return accounts.map((acc) => {
        if (isCompositeAccounts(acc)) {
          const rpcAccs = ctx[acc.name];
          return _InstructionNamespaceFactory.accountsArray(rpcAccs, acc.accounts, programId, ixName).flat();
        }
        let pubkey2;
        try {
          pubkey2 = translateAddress(ctx[acc.name]);
        } catch (err2) {
          throw new Error(`Wrong input type for account "${acc.name}" in the instruction accounts object${ixName !== void 0 ? ' for instruction "' + ixName + '"' : ""}. Expected PublicKey or string.`);
        }
        const isOptional = acc.optional && pubkey2.equals(programId);
        const isWritable = Boolean(acc.writable && !isOptional);
        const isSigner = Boolean(acc.signer && !isOptional);
        return {
          pubkey: pubkey2,
          isWritable,
          isSigner
        };
      }).flat();
    }
  };
  function validateInstruction(ix, ...args) {
  }
  var TransactionFactory = class {
    static build(idlIx, ixFn) {
      const txFn = (...args) => {
        var _a, _b, _c;
        const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
        const tx = new import_web3.Transaction();
        if (ctx.preInstructions && ctx.instructions) {
          throw new Error("instructions is deprecated, use preInstructions");
        }
        (_a = ctx.preInstructions) === null || _a === void 0 ? void 0 : _a.forEach((ix) => tx.add(ix));
        (_b = ctx.instructions) === null || _b === void 0 ? void 0 : _b.forEach((ix) => tx.add(ix));
        tx.add(ixFn(...args));
        (_c = ctx.postInstructions) === null || _c === void 0 ? void 0 : _c.forEach((ix) => tx.add(ix));
        return tx;
      };
      return txFn;
    }
  };
  var RpcFactory = class {
    static build(idlIx, txFn, idlErrors, provider) {
      const rpc2 = async (...args) => {
        var _a;
        const tx = txFn(...args);
        const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
        if (provider.sendAndConfirm === void 0) {
          throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
        }
        try {
          return await provider.sendAndConfirm(tx, (_a = ctx.signers) !== null && _a !== void 0 ? _a : [], ctx.options);
        } catch (err2) {
          throw translateError(err2, idlErrors);
        }
      };
      return rpc2;
    }
  };
  var AccountFactory = class {
    static build(idl, coder2, programId, provider) {
      var _a;
      return ((_a = idl.accounts) !== null && _a !== void 0 ? _a : []).reduce((accountFns, acc) => {
        accountFns[acc.name] = new AccountClient(idl, acc, programId, provider, coder2);
        return accountFns;
      }, {});
    }
  };
  var AccountClient = class {
    /**
     * Returns the number of bytes in this account.
     */
    get size() {
      return this._size;
    }
    /**
     * Returns the program ID owning all accounts.
     */
    get programId() {
      return this._programId;
    }
    /**
     * Returns the client's wallet and network provider.
     */
    get provider() {
      return this._provider;
    }
    /**
     * Returns the coder.
     */
    get coder() {
      return this._coder;
    }
    constructor(idl, idlAccount, programId, provider, coder2) {
      this._idlAccount = idlAccount;
      this._programId = programId;
      this._provider = provider !== null && provider !== void 0 ? provider : getProvider();
      this._coder = coder2 !== null && coder2 !== void 0 ? coder2 : new BorshCoder(idl);
      this._size = this._coder.accounts.size(idlAccount.name);
    }
    /**
     * Returns a deserialized account, returning null if it doesn't exist.
     *
     * @param address The address of the account to fetch.
     */
    async fetchNullable(address, commitment) {
      const { data } = await this.fetchNullableAndContext(address, commitment);
      return data;
    }
    /**
     * Returns a deserialized account along with the associated rpc response context, returning null if it doesn't exist.
     *
     * @param address The address of the account to fetch.
     */
    async fetchNullableAndContext(address, commitment) {
      const accountInfo = await this.getAccountInfoAndContext(address, commitment);
      const { value, context } = accountInfo;
      return {
        data: value && value.data.length !== 0 ? this._coder.accounts.decode(this._idlAccount.name, value.data) : null,
        context
      };
    }
    /**
     * Returns a deserialized account.
     *
     * @param address The address of the account to fetch.
     */
    async fetch(address, commitment) {
      const { data } = await this.fetchNullableAndContext(address, commitment);
      if (data === null) {
        throw new Error(`Account does not exist or has no data ${address.toString()}`);
      }
      return data;
    }
    /**
     * Returns a deserialized account along with the associated rpc response context.
     *
     * @param address The address of the account to fetch.
     */
    async fetchAndContext(address, commitment) {
      const { data, context } = await this.fetchNullableAndContext(address, commitment);
      if (data === null) {
        throw new Error(`Account does not exist ${address.toString()}`);
      }
      return { data, context };
    }
    /**
     * Returns multiple deserialized accounts.
     * Accounts not found or with wrong discriminator are returned as null.
     *
     * @param addresses The addresses of the accounts to fetch.
     */
    async fetchMultiple(addresses, commitment) {
      const accounts = await this.fetchMultipleAndContext(addresses, commitment);
      return accounts.map((account) => account ? account.data : null);
    }
    /**
     * Returns multiple deserialized accounts.
     * Accounts not found or with wrong discriminator are returned as null.
     *
     * @param addresses The addresses of the accounts to fetch.
     */
    async fetchMultipleAndContext(addresses, commitment) {
      const accounts = await getMultipleAccountsAndContext(this._provider.connection, addresses.map((address) => translateAddress(address)), commitment);
      return accounts.map((result) => {
        if (result == null) {
          return null;
        }
        const { account, context } = result;
        return {
          data: this._coder.accounts.decode(this._idlAccount.name, account.data),
          context
        };
      });
    }
    /**
     * Returns all instances of this account type for the program.
     *
     * @param filters User-provided filters to narrow the results from `connection.getProgramAccounts`.
     *
     *                When filters are not defined this method returns all
     *                the account instances.
     *
     *                When filters are of type `Buffer`, the filters are appended
     *                after the discriminator.
     *
     *                When filters are of type `GetProgramAccountsFilter[]`,
     *                filters are appended after the discriminator filter.
     */
    async all(filters) {
      const filter = this.coder.accounts.memcmp(this._idlAccount.name, filters instanceof Buffer ? filters : void 0);
      const coderFilters = [];
      if ((filter === null || filter === void 0 ? void 0 : filter.offset) != void 0 && (filter === null || filter === void 0 ? void 0 : filter.bytes) != void 0) {
        coderFilters.push({
          memcmp: { offset: filter.offset, bytes: filter.bytes }
        });
      }
      if ((filter === null || filter === void 0 ? void 0 : filter.dataSize) != void 0) {
        coderFilters.push({ dataSize: filter.dataSize });
      }
      let resp = await this._provider.connection.getProgramAccounts(this._programId, {
        commitment: this._provider.connection.commitment,
        filters: [...coderFilters, ...Array.isArray(filters) ? filters : []]
      });
      return resp.map(({ pubkey: pubkey2, account }) => {
        return {
          publicKey: pubkey2,
          account: this._coder.accounts.decode(this._idlAccount.name, account.data)
        };
      });
    }
    /**
     * Returns an `EventEmitter` emitting a "change" event whenever the account
     * changes.
     */
    subscribe(address, commitment) {
      const sub = subscriptions.get(address.toString());
      if (sub) {
        return sub.ee;
      }
      const ee = new import_eventemitter3.default();
      address = translateAddress(address);
      const listener = this._provider.connection.onAccountChange(address, (acc) => {
        const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);
        ee.emit("change", account);
      }, commitment);
      subscriptions.set(address.toString(), {
        ee,
        listener
      });
      return ee;
    }
    /**
     * Unsubscribes from the account at the given address.
     */
    async unsubscribe(address) {
      let sub = subscriptions.get(address.toString());
      if (!sub) {
        console.warn("Address is not subscribed");
        return;
      }
      if (subscriptions) {
        await this._provider.connection.removeAccountChangeListener(sub.listener).then(() => {
          subscriptions.delete(address.toString());
        }).catch(console.error);
      }
    }
    /**
     * Returns an instruction for creating this account.
     */
    async createInstruction(signer, sizeOverride) {
      const size = this.size;
      if (this._provider.publicKey === void 0) {
        throw new Error("This function requires the Provider interface implementor to have a 'publicKey' field.");
      }
      return import_web3.SystemProgram.createAccount({
        fromPubkey: this._provider.publicKey,
        newAccountPubkey: signer.publicKey,
        space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,
        lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),
        programId: this._programId
      });
    }
    async getAccountInfo(address, commitment) {
      return await this._provider.connection.getAccountInfo(translateAddress(address), commitment);
    }
    async getAccountInfoAndContext(address, commitment) {
      return await this._provider.connection.getAccountInfoAndContext(translateAddress(address), commitment);
    }
  };
  var subscriptions = /* @__PURE__ */ new Map();
  var PROGRAM_LOG = "Program log: ";
  var PROGRAM_DATA = "Program data: ";
  var PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length;
  var PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;
  var EventManager = class {
    constructor(programId, provider, coder2) {
      this._programId = programId;
      this._provider = provider;
      this._eventParser = new EventParser(programId, coder2);
      this._eventCallbacks = /* @__PURE__ */ new Map();
      this._eventListeners = /* @__PURE__ */ new Map();
      this._listenerIdCount = 0;
    }
    addEventListener(eventName, callback) {
      var _a;
      let listener = this._listenerIdCount;
      this._listenerIdCount += 1;
      if (!this._eventListeners.has(eventName)) {
        this._eventListeners.set(eventName, []);
      }
      this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== void 0 ? _a : []).concat(listener));
      this._eventCallbacks.set(listener, [eventName, callback]);
      if (this._onLogsSubscriptionId !== void 0) {
        return listener;
      }
      this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx) => {
        if (logs.err) {
          return;
        }
        for (const event of this._eventParser.parseLogs(logs.logs)) {
          const allListeners = this._eventListeners.get(event.name);
          if (allListeners) {
            allListeners.forEach((listener2) => {
              const listenerCb = this._eventCallbacks.get(listener2);
              if (listenerCb) {
                const [, callback2] = listenerCb;
                callback2(event.data, ctx.slot, logs.signature);
              }
            });
          }
        }
      });
      return listener;
    }
    async removeEventListener(listener) {
      const callback = this._eventCallbacks.get(listener);
      if (!callback) {
        throw new Error(`Event listener ${listener} doesn't exist!`);
      }
      const [eventName] = callback;
      let listeners = this._eventListeners.get(eventName);
      if (!listeners) {
        throw new Error(`Event listeners don't exist for ${eventName}!`);
      }
      this._eventCallbacks.delete(listener);
      listeners = listeners.filter((l) => l !== listener);
      this._eventListeners.set(eventName, listeners);
      if (listeners.length === 0) {
        this._eventListeners.delete(eventName);
      }
      if (this._eventCallbacks.size === 0) {
        if (this._eventListeners.size !== 0) {
          throw new Error(`Expected event listeners size to be 0 but got ${this._eventListeners.size}`);
        }
        if (this._onLogsSubscriptionId !== void 0) {
          await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);
          this._onLogsSubscriptionId = void 0;
        }
      }
    }
  };
  var EventParser = class {
    constructor(programId, coder2) {
      this.coder = coder2;
      this.programId = programId;
    }
    // Each log given, represents an array of messages emitted by
    // a single transaction, which can execute many different programs across
    // CPI boundaries. However, the subscription is only interested in the
    // events emitted by *this* program. In achieving this, we keep track of the
    // program execution context by parsing each log and looking for a CPI
    // `invoke` call. If one exists, we know a new program is executing. So we
    // push the programId onto a stack and switch the program context. This
    // allows us to track, for a given log, which program was executing during
    // its emission, thereby allowing us to know if a given log event was
    // emitted by *this* program. If it was, then we parse the raw string and
    // emit the event if the string matches the event being subscribed to.
    *parseLogs(logs, errorOnDecodeFailure = false) {
      const logScanner = new LogScanner(logs);
      const execution = new ExecutionContext();
      let log = logScanner.next();
      while (log !== null) {
        let [event, newProgram, didPop] = this.handleLog(execution, log, errorOnDecodeFailure);
        if (event) {
          yield event;
        }
        if (newProgram) {
          execution.push(newProgram);
        }
        if (didPop) {
          execution.pop();
        }
        log = logScanner.next();
      }
    }
    // Main log handler. Returns a three element array of the event, the
    // next program that was invoked for CPI, and a boolean indicating if
    // a program has completed execution (and thus should be popped off the
    // execution stack).
    handleLog(execution, log, errorOnDecodeFailure) {
      if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {
        return this.handleProgramLog(log, errorOnDecodeFailure);
      } else {
        return [null, ...this.handleSystemLog(log)];
      }
    }
    // Handles logs from *this* program.
    handleProgramLog(log, errorOnDecodeFailure) {
      if (log.startsWith(PROGRAM_LOG) || log.startsWith(PROGRAM_DATA)) {
        const logStr = log.startsWith(PROGRAM_LOG) ? log.slice(PROGRAM_LOG_START_INDEX) : log.slice(PROGRAM_DATA_START_INDEX);
        const event = this.coder.events.decode(logStr);
        if (errorOnDecodeFailure && event === null) {
          throw new Error(`Unable to decode event ${logStr}`);
        }
        return [event, null, false];
      } else {
        return [null, ...this.handleSystemLog(log)];
      }
    }
    // Handles logs when the current program being executing is *not* this.
    handleSystemLog(log) {
      const logStart = log.split(":")[0];
      if (logStart.match(/^Program (.*) success/g) !== null) {
        return [null, true];
      } else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {
        return [this.programId.toString(), false];
      } else if (logStart.includes("invoke")) {
        return ["cpi", false];
      } else {
        return [null, false];
      }
    }
  };
  var ExecutionContext = class {
    constructor() {
      this.stack = [];
    }
    program() {
      if (!this.stack.length) {
        throw new Error("Expected the stack to have elements");
      }
      return this.stack[this.stack.length - 1];
    }
    push(newProgram) {
      this.stack.push(newProgram);
    }
    pop() {
      if (!this.stack.length) {
        throw new Error("Expected the stack to have elements");
      }
      this.stack.pop();
    }
  };
  var LogScanner = class {
    constructor(logs) {
      this.logs = logs;
    }
    next() {
      if (this.logs.length === 0) {
        return null;
      }
      let l = this.logs[0];
      this.logs = this.logs.slice(1);
      return l;
    }
  };
  var SimulateFactory = class {
    static build(idlIx, txFn, idlErrors, provider, coder2, programId, idl) {
      const simulate = async (...args) => {
        var _a;
        const tx = txFn(...args);
        const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
        let resp = void 0;
        if (provider.simulate === void 0) {
          throw new Error("This function requires 'Provider.simulate' to be implemented.");
        }
        try {
          resp = await provider.simulate(tx, ctx.signers, (_a = ctx.options) === null || _a === void 0 ? void 0 : _a.commitment);
        } catch (err2) {
          throw translateError(err2, idlErrors);
        }
        if (resp === void 0) {
          throw new Error("Unable to simulate transaction");
        }
        const logs = resp.logs;
        if (!logs) {
          throw new Error("Simulated logs not found");
        }
        const events = [];
        if (idl.events) {
          let parser = new EventParser(programId, coder2);
          for (const event of parser.parseLogs(logs)) {
            events.push(event);
          }
        }
        return { events, raw: logs };
      };
      return simulate;
    }
  };
  function uint64(property) {
    return new WrappedLayout(blob(8), (b) => u642.fromBuffer(b), (n) => n.toBuffer(), property);
  }
  function publicKey2(property) {
    return new WrappedLayout(blob(32), (b) => new import_web3.PublicKey(b), (key) => key.toBuffer(), property);
  }
  function coption(layout, property) {
    return new COptionLayout(layout, property);
  }
  var WrappedLayout = class extends Layout_2 {
    constructor(layout, decoder, encoder, property) {
      super(layout.span, property);
      this.layout = layout;
      this.decoder = decoder;
      this.encoder = encoder;
    }
    decode(b, offset2) {
      return this.decoder(this.layout.decode(b, offset2));
    }
    encode(src, b, offset2) {
      return this.layout.encode(this.encoder(src), b, offset2);
    }
    getSpan(b, offset2) {
      return this.layout.getSpan(b, offset2);
    }
  };
  var COptionLayout = class extends Layout_2 {
    constructor(layout, property) {
      super(-1, property);
      this.layout = layout;
      this.discriminator = u322();
    }
    encode(src, b, offset2 = 0) {
      if (src === null || src === void 0) {
        return this.layout.span + this.discriminator.encode(0, b, offset2);
      }
      this.discriminator.encode(1, b, offset2);
      return this.layout.encode(src, b, offset2 + 4) + 4;
    }
    decode(b, offset2 = 0) {
      const discriminator = this.discriminator.decode(b, offset2);
      if (discriminator === 0) {
        return null;
      } else if (discriminator === 1) {
        return this.layout.decode(b, offset2 + 4);
      }
      throw new Error("Invalid coption " + this.layout.property);
    }
    getSpan(b, offset2 = 0) {
      return this.layout.getSpan(b, offset2 + 4) + 4;
    }
  };
  var u642 = class _u64 extends import_bn.default {
    /**
     * Convert to Buffer representation
     */
    toBuffer() {
      const a = super.toArray().reverse();
      const b = Buffer.from(a);
      if (b.length === 8) {
        return b;
      }
      if (b.length >= 8) {
        throw new Error("u64 too large");
      }
      const zeroPad = Buffer.alloc(8);
      b.copy(zeroPad);
      return zeroPad;
    }
    /**
     * Construct a u64 from Buffer representation
     */
    static fromBuffer(buffer) {
      if (buffer.length !== 8) {
        throw new Error(`Invalid buffer length: ${buffer.length}`);
      }
      return new _u64([...buffer].reverse().map((i) => `00${i.toString(16)}`.slice(-2)).join(""), 16);
    }
  };
  var TOKEN_ACCOUNT_LAYOUT = struct2([
    publicKey2("mint"),
    publicKey2("owner"),
    uint64("amount"),
    coption(publicKey2(), "delegate"),
    ((p) => {
      const U = union(u82("discriminator"), null, p);
      U.addVariant(0, struct2([]), "uninitialized");
      U.addVariant(1, struct2([]), "initialized");
      U.addVariant(2, struct2([]), "frozen");
      return U;
    })("state"),
    coption(uint64(), "isNative"),
    uint64("delegatedAmount"),
    coption(publicKey2(), "closeAuthority")
  ]);
  function decodeTokenAccount(b) {
    return TOKEN_ACCOUNT_LAYOUT.decode(b);
  }
  var AccountsResolver = class {
    constructor(_args, _accounts, _provider2, _programId, _idlIx, accountNamespace, _idlTypes, _customResolver) {
      this._args = _args;
      this._accounts = _accounts;
      this._provider = _provider2;
      this._programId = _programId;
      this._idlIx = _idlIx;
      this._idlTypes = _idlTypes;
      this._customResolver = _customResolver;
      this._accountStore = new AccountStore(_provider2, accountNamespace, _programId);
    }
    args(args) {
      this._args = args;
    }
    // Note: We serially resolve PDAs one by one rather than doing them
    //       in parallel because there can be dependencies between
    //       addresses. That is, one PDA can be used as a seed in another.
    async resolve() {
      this.resolveEventCpi(this._idlIx.accounts);
      this.resolveConst(this._idlIx.accounts);
      let depth = 0;
      while (await this.resolvePdasAndRelations(this._idlIx.accounts) + await this.resolveCustom() > 0) {
        depth++;
        if (depth === 16) {
          throw new Error("Reached maximum depth for account resolution");
        }
      }
    }
    resolveOptionals(accounts) {
      Object.assign(this._accounts, this.resolveOptionalsHelper(accounts, this._idlIx.accounts));
    }
    get(path) {
      const ret = path.reduce((acc, subPath) => acc && acc[subPath], this._accounts);
      if (ret && ret.toBase58) {
        return ret;
      }
    }
    set(path, value) {
      let cur = this._accounts;
      path.forEach((p, i) => {
        var _a;
        const isLast = i === path.length - 1;
        if (isLast) {
          cur[p] = value;
        }
        cur[p] = (_a = cur[p]) !== null && _a !== void 0 ? _a : {};
        cur = cur[p];
      });
    }
    resolveOptionalsHelper(partialAccounts, accounts) {
      const nestedAccountsGeneric = {};
      for (const accountItem of accounts) {
        const accountName = accountItem.name;
        const partialAccount = partialAccounts[accountName];
        if (partialAccount === void 0)
          continue;
        if (isPartialAccounts(partialAccount)) {
          if (isCompositeAccounts(accountItem)) {
            nestedAccountsGeneric[accountName] = this.resolveOptionalsHelper(partialAccount, accountItem["accounts"]);
          } else {
            nestedAccountsGeneric[accountName] = flattenPartialAccounts(partialAccount, true);
          }
        } else {
          if (partialAccount !== null) {
            nestedAccountsGeneric[accountName] = translateAddress(partialAccount);
          } else if (accountItem["optional"]) {
            nestedAccountsGeneric[accountName] = this._programId;
          }
        }
      }
      return nestedAccountsGeneric;
    }
    async resolveCustom() {
      if (this._customResolver) {
        const { accounts, resolved } = await this._customResolver({
          args: this._args,
          accounts: this._accounts,
          provider: this._provider,
          programId: this._programId,
          idlIx: this._idlIx
        });
        this._accounts = accounts;
        return resolved;
      }
      return 0;
    }
    /**
     * Resolve event CPI accounts `eventAuthority` and `program`.
     *
     * Accounts will only be resolved if they are declared next to each other to
     * reduce the chance of name collision.
     */
    resolveEventCpi(accounts, path = []) {
      for (const i in accounts) {
        const accountOrAccounts = accounts[i];
        if (isCompositeAccounts(accountOrAccounts)) {
          this.resolveEventCpi(accountOrAccounts.accounts, [
            ...path,
            accountOrAccounts.name
          ]);
        }
        const nextIndex = +i + 1;
        if (nextIndex === accounts.length)
          return;
        const currentName = accounts[i].name;
        const nextName = accounts[nextIndex].name;
        if (currentName === "eventAuthority" && nextName === "program") {
          const currentPath = [...path, currentName];
          const nextPath = [...path, nextName];
          if (!this.get(currentPath)) {
            this.set(currentPath, import_web3.PublicKey.findProgramAddressSync([Buffer.from("__event_authority")], this._programId)[0]);
          }
          if (!this.get(nextPath)) {
            this.set(nextPath, this._programId);
          }
          return;
        }
      }
    }
    resolveConst(accounts, path = []) {
      for (const accountOrAccounts of accounts) {
        const name = accountOrAccounts.name;
        if (isCompositeAccounts(accountOrAccounts)) {
          this.resolveConst(accountOrAccounts.accounts, [...path, name]);
        } else {
          const account = accountOrAccounts;
          if ((account.signer || account.address) && !this.get([...path, name])) {
            if (account.signer) {
              if (!this._provider.wallet) {
                throw new Error("This function requires the `Provider` interface implementor to have a `wallet` field.");
              }
              this.set([...path, name], this._provider.wallet.publicKey);
            }
            if (account.address) {
              this.set([...path, name], translateAddress(account.address));
            }
          }
        }
      }
    }
    async resolvePdasAndRelations(accounts, path = []) {
      let found = 0;
      for (const accountOrAccounts of accounts) {
        const name = accountOrAccounts.name;
        if (isCompositeAccounts(accountOrAccounts)) {
          found += await this.resolvePdasAndRelations(accountOrAccounts.accounts, [...path, name]);
        } else {
          const account = accountOrAccounts;
          if ((account.pda || account.relations) && !this.get([...path, name])) {
            found++;
            try {
              if (account.pda) {
                const seeds = await Promise.all(account.pda.seeds.map((seed2) => this.toBuffer(seed2, path)));
                if (seeds.some((seed2) => !seed2)) {
                  continue;
                }
                const programId = await this.parseProgramId(account, path);
                const [pubkey2] = import_web3.PublicKey.findProgramAddressSync(seeds, programId);
                this.set([...path, name], pubkey2);
              }
            } catch {
            }
            try {
              if (account.relations) {
                const accountKey = this.get([...path, account.relations[0]]);
                if (accountKey) {
                  const account2 = await this._accountStore.fetchAccount({
                    publicKey: accountKey
                  });
                  this.set([...path, name], account2[name]);
                }
              }
            } catch {
            }
          }
        }
      }
      return found;
    }
    async parseProgramId(account, path = []) {
      var _a;
      if (!((_a = account.pda) === null || _a === void 0 ? void 0 : _a.program)) {
        return this._programId;
      }
      const buf = await this.toBuffer(account.pda.program, path);
      if (!buf) {
        throw new Error(`Program seed not resolved: ${account.name}`);
      }
      return new import_web3.PublicKey(buf);
    }
    async toBuffer(seed2, path = []) {
      switch (seed2.kind) {
        case "const":
          return this.toBufferConst(seed2);
        case "arg":
          return await this.toBufferArg(seed2);
        case "account":
          return await this.toBufferAccount(seed2, path);
        default:
          throw new Error(`Unexpected seed: ${seed2}`);
      }
    }
    toBufferConst(seed2) {
      return this.toBufferValue("bytes", seed2.value);
    }
    async toBufferArg(seed2) {
      const [name, ...path] = seed2.path.split(".");
      const index2 = this._idlIx.args.findIndex((arg) => arg.name === name);
      if (index2 === -1) {
        throw new Error(`Unable to find argument for seed: ${name}`);
      }
      const value = path.reduce((acc, path2) => (acc !== null && acc !== void 0 ? acc : {})[path2], this._args[index2]);
      if (value === void 0) {
        return;
      }
      const type2 = this.getType(this._idlIx.args[index2].type, path);
      return this.toBufferValue(type2, value);
    }
    async toBufferAccount(seed2, path = []) {
      const [name, ...paths] = seed2.path.split(".");
      const fieldPubkey = this.get([...path, name]);
      if (!fieldPubkey)
        return;
      if (!paths.length) {
        return this.toBufferValue("pubkey", fieldPubkey);
      }
      if (!seed2.account) {
        throw new Error(`Seed account is required in order to resolve type: ${seed2.path}`);
      }
      const account = await this._accountStore.fetchAccount({
        publicKey: fieldPubkey,
        name: seed2.account
      });
      let accountValue = account;
      let currentPaths = paths;
      while (currentPaths.length > 0) {
        accountValue = accountValue[currentPaths[0]];
        currentPaths = currentPaths.slice(1);
      }
      if (accountValue === void 0)
        return;
      const type2 = this.getType({ defined: { name: seed2.account } }, paths);
      return this.toBufferValue(type2, accountValue);
    }
    /**
     * Converts the given idl valaue into a Buffer. The values here must be
     * primitives, e.g. no structs.
     */
    toBufferValue(type2, value) {
      switch (type2) {
        case "u8":
        case "i8":
          return Buffer.from([value]);
        case "u16":
        case "i16":
          return new import_bn.default(value).toArrayLike(Buffer, "le", 2);
        case "u32":
        case "i32":
          return new import_bn.default(value).toArrayLike(Buffer, "le", 4);
        case "u64":
        case "i64":
          return new import_bn.default(value).toArrayLike(Buffer, "le", 8);
        case "u128":
        case "i128":
          return new import_bn.default(value).toArrayLike(Buffer, "le", 16);
        case "u256":
        case "i256":
          return new import_bn.default(value).toArrayLike(Buffer, "le", 32);
        case "string":
          return Buffer.from(value);
        case "pubkey":
          return value.toBuffer();
        case "bytes":
          return Buffer.from(value);
        default:
          if (type2 === null || type2 === void 0 ? void 0 : type2.array) {
            return Buffer.from(value);
          }
          throw new Error(`Unexpected seed type: ${type2}`);
      }
    }
    /**
     * Recursively get the type at some path of either a primitive or a user
     * defined struct.
     */
    getType(type2, path = []) {
      var _a;
      const typeName = (_a = type2 === null || type2 === void 0 ? void 0 : type2.defined) === null || _a === void 0 ? void 0 : _a.name;
      if (typeName) {
        if (typeName === "tokenAccount") {
          switch (path.at(0)) {
            case "mint":
            case "owner":
              return "pubkey";
            case "amount":
            case "delagatedAmount":
              return "u64";
            default:
              throw new Error(`Unknown token account path: ${path}`);
          }
        }
        const definedType = this._idlTypes.find((t) => t.name === typeName);
        if (!definedType) {
          throw new Error(`Type not found: ${typeName}`);
        }
        const [fieldName, ...subPath] = path;
        const fields = definedType.type.fields;
        const field = fields.find((field2) => field2.name === fieldName);
        if (!field) {
          throw new Error(`Field not found: ${fieldName}`);
        }
        return this.getType(field.type, subPath);
      }
      return type2;
    }
  };
  var AccountStore = class {
    constructor(_provider2, accounts, programId) {
      this._provider = _provider2;
      this._cache = /* @__PURE__ */ new Map();
      this._idls = {};
      this._idls[programId.toBase58()] = accounts;
    }
    async fetchAccount({ publicKey: publicKey3, name }) {
      const address = publicKey3.toBase58();
      if (!this._cache.has(address)) {
        const accountInfo = await this._provider.connection.getAccountInfo(publicKey3);
        if (accountInfo === null) {
          throw new Error(`Account not found: ${address}`);
        }
        if (name === "tokenAccount") {
          const account = decodeTokenAccount(accountInfo.data);
          this._cache.set(address, account);
        } else {
          const accounts = await this.getAccountsNs(accountInfo.owner);
          if (accounts) {
            const accountNs = Object.values(accounts)[0];
            if (accountNs) {
              const account = accountNs.coder.accounts.decodeAny(accountInfo.data);
              this._cache.set(address, account);
            }
          }
        }
      }
      return this._cache.get(address);
    }
    async getAccountsNs(programId) {
      const programIdStr = programId.toBase58();
      if (!this._idls[programIdStr]) {
        const idl = await Program.fetchIdl(programId, this._provider);
        if (idl) {
          const program2 = new Program(idl, this._provider);
          this._idls[programIdStr] = program2.account;
        }
      }
      return this._idls[programIdStr];
    }
  };
  var MethodsBuilderFactory = class {
    static build(provider, programId, idlIx, ixFn, txFn, rpcFn, simulateFn, viewFn, accountNamespace, idlTypes, customResolver) {
      return (...args) => new MethodsBuilder(args, ixFn, txFn, rpcFn, simulateFn, viewFn, provider, programId, idlIx, accountNamespace, idlTypes, customResolver);
    }
  };
  function isPartialAccounts(partialAccount) {
    return typeof partialAccount === "object" && partialAccount !== null && !("_bn" in partialAccount);
  }
  function flattenPartialAccounts(partialAccounts, throwOnNull) {
    const toReturn = {};
    for (const accountName in partialAccounts) {
      const account = partialAccounts[accountName];
      if (account === null) {
        if (throwOnNull)
          throw new Error("Failed to resolve optionals due to IDL type mismatch with input accounts!");
        continue;
      }
      toReturn[accountName] = isPartialAccounts(account) ? flattenPartialAccounts(account, true) : translateAddress(account);
    }
    return toReturn;
  }
  var MethodsBuilder = class {
    constructor(_args, _ixFn, _txFn, _rpcFn, _simulateFn, _viewFn, provider, programId, idlIx, accountNamespace, idlTypes, customResolver) {
      this._args = _args;
      this._ixFn = _ixFn;
      this._txFn = _txFn;
      this._rpcFn = _rpcFn;
      this._simulateFn = _simulateFn;
      this._viewFn = _viewFn;
      this._accounts = {};
      this._remainingAccounts = [];
      this._signers = [];
      this._preInstructions = [];
      this._postInstructions = [];
      this._resolveAccounts = true;
      this._accountsResolver = new AccountsResolver(_args, this._accounts, provider, programId, idlIx, accountNamespace, idlTypes, customResolver);
    }
    args(args) {
      this._args = args;
      this._accountsResolver.args(args);
    }
    /**
     * Set instruction accounts with account resolution.
     *
     * This method only accepts accounts that cannot be resolved.
     *
     * See {@link accountsPartial} for overriding the account resolution or
     * {@link accountsStrict} for strictly specifying all accounts.
     */
    accounts(accounts) {
      return this.accountsPartial(accounts);
    }
    /**
     * Set instruction accounts with account resolution.
     *
     * There is no functional difference between this method and {@link accounts}
     * method, the only difference is this method allows specifying all accounts
     * even if they can be resolved. On the other hand, {@link accounts} method
     * doesn't accept accounts that can be resolved.
     */
    accountsPartial(accounts) {
      this._resolveAccounts = true;
      this._accountsResolver.resolveOptionals(accounts);
      return this;
    }
    /**
     * Set instruction accounts without account resolution.
     *
     * All accounts strictly need to be specified when this method is used.
     *
     * See {@link accounts} and {@link accountsPartial} methods for automatically
     * resolving accounts.
     */
    accountsStrict(accounts) {
      this._resolveAccounts = false;
      this._accountsResolver.resolveOptionals(accounts);
      return this;
    }
    signers(signers) {
      this._signers = this._signers.concat(signers);
      return this;
    }
    remainingAccounts(accounts) {
      this._remainingAccounts = this._remainingAccounts.concat(accounts);
      return this;
    }
    preInstructions(ixs, prepend = false) {
      if (prepend) {
        this._preInstructions = ixs.concat(this._preInstructions);
      } else {
        this._preInstructions = this._preInstructions.concat(ixs);
      }
      return this;
    }
    postInstructions(ixs) {
      this._postInstructions = this._postInstructions.concat(ixs);
      return this;
    }
    /**
     * Get the public keys of the instruction accounts.
     *
     * The return type is an object with account names as keys and their public
     * keys as their values.
     *
     * Note that an account key is `undefined` if the account hasn't yet been
     * specified or resolved.
     */
    async pubkeys() {
      if (this._resolveAccounts) {
        await this._accountsResolver.resolve();
      }
      return this._accounts;
    }
    async rpc(options) {
      if (this._resolveAccounts) {
        await this._accountsResolver.resolve();
      }
      return this._rpcFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions,
        options
      });
    }
    async rpcAndKeys(options) {
      const pubkeys = await this.pubkeys();
      return {
        pubkeys,
        signature: await this.rpc(options)
      };
    }
    async view(options) {
      if (this._resolveAccounts) {
        await this._accountsResolver.resolve();
      }
      if (!this._viewFn) {
        throw new Error("Method does not support views");
      }
      return this._viewFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions,
        options
      });
    }
    async simulate(options) {
      if (this._resolveAccounts) {
        await this._accountsResolver.resolve();
      }
      return this._simulateFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions,
        options
      });
    }
    async instruction() {
      if (this._resolveAccounts) {
        await this._accountsResolver.resolve();
      }
      return this._ixFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions
      });
    }
    /**
     * Convenient shortcut to get instructions and pubkeys via:
     *
     * ```ts
     * const { pubkeys, instructions } = await method.prepare();
     * ```
     */
    async prepare() {
      return {
        instruction: await this.instruction(),
        pubkeys: await this.pubkeys(),
        signers: this._signers
      };
    }
    async transaction() {
      if (this._resolveAccounts) {
        await this._accountsResolver.resolve();
      }
      return this._txFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions
      });
    }
  };
  var ViewFactory = class {
    static build(programId, idlIx, simulateFn, idl) {
      const isWritable = idlIx.accounts.find((a) => a.writable);
      const hasReturn = !!idlIx.returns;
      if (isWritable || !hasReturn)
        return;
      const view = async (...args) => {
        let simulationResult = await simulateFn(...args);
        const returnPrefix = `Program return: ${programId} `;
        let returnLog = simulationResult.raw.find((l) => l.startsWith(returnPrefix));
        if (!returnLog) {
          throw new Error("View expected return log");
        }
        let returnData = decode(returnLog.slice(returnPrefix.length));
        let returnType = idlIx.returns;
        if (!returnType) {
          throw new Error("View expected return type");
        }
        const coder2 = IdlCoder.fieldLayout({ type: returnType }, idl.types);
        return coder2.decode(returnData);
      };
      return view;
    }
  };
  var NamespaceFactory = class {
    /**
     * Generates all namespaces for a given program.
     */
    static build(idl, coder2, programId, provider, getCustomResolver) {
      const rpc2 = {};
      const instruction = {};
      const transaction = {};
      const simulate = {};
      const methods = {};
      const view = {};
      const idlErrors = parseIdlErrors(idl);
      const account = idl.accounts ? AccountFactory.build(idl, coder2, programId, provider) : {};
      idl.instructions.forEach((idlIx) => {
        const ixItem = InstructionNamespaceFactory.build(idlIx, (ixName, ix) => coder2.instruction.encode(ixName, ix), programId);
        const txItem = TransactionFactory.build(idlIx, ixItem);
        const rpcItem = RpcFactory.build(idlIx, txItem, idlErrors, provider);
        const simulateItem = SimulateFactory.build(idlIx, txItem, idlErrors, provider, coder2, programId, idl);
        const viewItem = ViewFactory.build(programId, idlIx, simulateItem, idl);
        const methodItem = MethodsBuilderFactory.build(provider, programId, idlIx, ixItem, txItem, rpcItem, simulateItem, viewItem, account, idl.types || [], getCustomResolver === null || getCustomResolver === void 0 ? void 0 : getCustomResolver(idlIx));
        const name = idlIx.name;
        instruction[name] = ixItem;
        transaction[name] = txItem;
        rpc2[name] = rpcItem;
        simulate[name] = simulateItem;
        methods[name] = methodItem;
        if (viewItem) {
          view[name] = viewItem;
        }
      });
      return [
        rpc2,
        instruction,
        transaction,
        account,
        simulate,
        methods,
        view
      ];
    }
  };
  var Program = class _Program {
    /**
     * Address of the program.
     */
    get programId() {
      return this._programId;
    }
    /**
     * IDL in camelCase format to work in TypeScript.
     *
     * See {@link rawIdl} field if you need the original IDL.
     */
    get idl() {
      return this._idl;
    }
    /**
     * Raw IDL i.e. the original IDL without camelCase conversion.
     *
     * See {@link idl} field if you need the camelCased version of the IDL.
     */
    get rawIdl() {
      return this._rawIdl;
    }
    /**
     * Coder for serializing requests.
     */
    get coder() {
      return this._coder;
    }
    /**
     * Wallet and network provider.
     */
    get provider() {
      return this._provider;
    }
    /**
     * @param idl       The interface definition.
     * @param provider  The network and wallet context to use. If not provided
     *                  then uses [[getProvider]].
     * @param getCustomResolver A function that returns a custom account resolver
     *                          for the given instruction. This is useful for resolving
     *                          public keys of missing accounts when building instructions
     */
    constructor(idl, provider = getProvider(), coder2, getCustomResolver) {
      const camelCasedIdl = convertIdlToCamelCase(idl);
      this._idl = camelCasedIdl;
      this._rawIdl = idl;
      this._provider = provider;
      this._programId = translateAddress(idl.address);
      this._coder = coder2 !== null && coder2 !== void 0 ? coder2 : new BorshCoder(camelCasedIdl);
      this._events = new EventManager(this._programId, provider, this._coder);
      const [rpc2, instruction, transaction, account, simulate, methods, views] = NamespaceFactory.build(camelCasedIdl, this._coder, this._programId, provider, getCustomResolver);
      this.rpc = rpc2;
      this.instruction = instruction;
      this.transaction = transaction;
      this.account = account;
      this.simulate = simulate;
      this.methods = methods;
      this.views = views;
    }
    /**
     * Generates a Program client by fetching the IDL from the network.
     *
     * In order to use this method, an IDL must have been previously initialized
     * via the anchor CLI's `anchor idl init` command.
     *
     * @param programId The on-chain address of the program.
     * @param provider  The network and wallet context.
     */
    static async at(address, provider) {
      const programId = translateAddress(address);
      const idl = await _Program.fetchIdl(programId, provider);
      if (!idl) {
        throw new Error(`IDL not found for program: ${address.toString()}`);
      }
      return new _Program(idl, provider);
    }
    /**
     * Fetches an idl from the blockchain.
     *
     * In order to use this method, an IDL must have been previously initialized
     * via the anchor CLI's `anchor idl init` command.
     *
     * @param programId The on-chain address of the program.
     * @param provider  The network and wallet context.
     */
    static async fetchIdl(address, provider) {
      provider = provider !== null && provider !== void 0 ? provider : getProvider();
      const programId = translateAddress(address);
      const idlAddr = await idlAddress(programId);
      const accountInfo = await provider.connection.getAccountInfo(idlAddr);
      if (!accountInfo) {
        return null;
      }
      let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));
      const inflatedIdl = inflate_1(idlAccount.data);
      return JSON.parse(decode$2(inflatedIdl));
    }
    /**
     * Invokes the given callback every time the given event is emitted.
     *
     * @param eventName The PascalCase name of the event, provided by the IDL.
     * @param callback  The function to invoke whenever the event is emitted from
     *                  program logs.
     */
    addEventListener(eventName, callback) {
      return this._events.addEventListener(eventName, callback);
    }
    /**
     * Unsubscribes from the given eventName.
     */
    async removeEventListener(listener) {
      return await this._events.removeEventListener(listener);
    }
  };
  new import_web3.PublicKey("11111111111111111111111111111111");
  function program(provider) {
    return new Program(IDL, provider, coder());
  }
  function coder() {
    return new SystemCoder(IDL);
  }
  var IDL = {
    address: "11111111111111111111111111111111",
    metadata: {
      name: "systemProgram",
      version: "0.1.0",
      spec: "0.1.0"
    },
    instructions: [
      {
        name: "advanceNonceAccount",
        discriminator: [4, 0, 0, 0],
        accounts: [
          {
            name: "nonce",
            writable: true
          },
          {
            name: "recentBlockhashes"
          },
          {
            name: "authorized",
            signer: true
          }
        ],
        args: [
          {
            name: "authorized",
            type: "pubkey"
          }
        ]
      },
      {
        name: "allocate",
        discriminator: [8, 0, 0, 0],
        accounts: [
          {
            name: "pubkey",
            writable: true,
            signer: true
          }
        ],
        args: [
          {
            name: "space",
            type: "u64"
          }
        ]
      },
      {
        name: "allocateWithSeed",
        discriminator: [9, 0, 0, 0],
        accounts: [
          {
            name: "account",
            writable: true
          },
          {
            name: "base",
            signer: true
          }
        ],
        args: [
          {
            name: "base",
            type: "pubkey"
          },
          {
            name: "seed",
            type: "string"
          },
          {
            name: "space",
            type: "u64"
          },
          {
            name: "owner",
            type: "pubkey"
          }
        ]
      },
      {
        name: "assign",
        discriminator: [1, 0, 0, 0],
        accounts: [
          {
            name: "pubkey",
            writable: true,
            signer: true
          }
        ],
        args: [
          {
            name: "owner",
            type: "pubkey"
          }
        ]
      },
      {
        name: "assignWithSeed",
        discriminator: [10, 0, 0, 0],
        accounts: [
          {
            name: "account",
            writable: true
          },
          {
            name: "base",
            signer: true
          }
        ],
        args: [
          {
            name: "base",
            type: "pubkey"
          },
          {
            name: "seed",
            type: "string"
          },
          {
            name: "owner",
            type: "pubkey"
          }
        ]
      },
      {
        name: "authorizeNonceAccount",
        discriminator: [7, 0, 0, 0],
        accounts: [
          {
            name: "nonce",
            writable: true
          },
          {
            name: "authorized",
            signer: true
          }
        ],
        args: [
          {
            name: "authorized",
            type: "pubkey"
          }
        ]
      },
      {
        name: "createAccount",
        discriminator: [0, 0, 0, 0],
        accounts: [
          {
            name: "from",
            writable: true,
            signer: true
          },
          {
            name: "to",
            writable: true,
            signer: true
          }
        ],
        args: [
          {
            name: "lamports",
            type: "u64"
          },
          {
            name: "space",
            type: "u64"
          },
          {
            name: "owner",
            type: "pubkey"
          }
        ]
      },
      {
        name: "createAccountWithSeed",
        discriminator: [3, 0, 0, 0],
        accounts: [
          {
            name: "from",
            writable: true,
            signer: true
          },
          {
            name: "to",
            writable: true
          },
          {
            name: "base",
            signer: true
          }
        ],
        args: [
          {
            name: "base",
            type: "pubkey"
          },
          {
            name: "seed",
            type: "string"
          },
          {
            name: "lamports",
            type: "u64"
          },
          {
            name: "space",
            type: "u64"
          },
          {
            name: "owner",
            type: "pubkey"
          }
        ]
      },
      {
        name: "initializeNonceAccount",
        discriminator: [6, 0, 0, 0],
        accounts: [
          {
            name: "nonce",
            writable: true,
            signer: true
          },
          {
            name: "recentBlockhashes"
          },
          {
            name: "rent",
            address: "SysvarRent111111111111111111111111111111111"
          }
        ],
        args: [
          {
            name: "authorized",
            type: "pubkey"
          }
        ]
      },
      {
        name: "transfer",
        discriminator: [2, 0, 0, 0],
        accounts: [
          {
            name: "from",
            writable: true,
            signer: true
          },
          {
            name: "to",
            writable: true
          }
        ],
        args: [
          {
            name: "lamports",
            type: "u64"
          }
        ]
      },
      {
        name: "transferWithSeed",
        discriminator: [11, 0, 0, 0],
        accounts: [
          {
            name: "from",
            writable: true
          },
          {
            name: "base",
            signer: true
          },
          {
            name: "to",
            writable: true
          }
        ],
        args: [
          {
            name: "lamports",
            type: "u64"
          },
          {
            name: "seed",
            type: "string"
          },
          {
            name: "owner",
            type: "pubkey"
          }
        ]
      },
      {
        name: "withdrawNonceAccount",
        discriminator: [5, 0, 0, 0],
        accounts: [
          {
            name: "nonce",
            writable: true
          },
          {
            name: "to",
            writable: true
          },
          {
            name: "recentBlockhashes"
          },
          {
            name: "rent",
            address: "SysvarRent111111111111111111111111111111111"
          },
          {
            name: "authorized",
            signer: true
          }
        ],
        args: [
          {
            name: "lamports",
            type: "u64"
          }
        ]
      }
    ],
    accounts: [
      {
        name: "nonce",
        discriminator: []
      }
    ],
    types: [
      {
        name: "feeCalculator",
        type: {
          kind: "struct",
          fields: [
            {
              name: "lamportsPerSignature",
              type: "u64"
            }
          ]
        }
      },
      {
        name: "nonce",
        type: {
          kind: "struct",
          fields: [
            {
              name: "version",
              type: "u32"
            },
            {
              name: "state",
              type: "u32"
            },
            {
              name: "authorizedPubkey",
              type: "pubkey"
            },
            {
              name: "nonce",
              type: "pubkey"
            },
            {
              name: "feeCalculator",
              type: {
                defined: {
                  name: "feeCalculator"
                }
              }
            }
          ]
        }
      }
    ]
  };
  var Native = class {
    static system(provider) {
      return program(provider);
    }
  };
  return __toCommonJS(index_exports);
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@noble/hashes/utils.js:
@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/edwards.js:
@noble/curves/abstract/montgomery.js:
@noble/curves/ed25519.js:
@noble/curves/abstract/weierstrass.js:
@noble/curves/_shortw_utils.js:
@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@solana/buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Uint8Array instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Buffer instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
*/

// ✅ Expose critical symbols for SanctOS
if (typeof window !== "undefined") {
  window.anchor = window.anchor || {};
  if (typeof AnchorProvider !== "undefined") window.anchor.AnchorProvider = AnchorProvider;
  if (typeof Provider !== "undefined") window.anchor.Provider = Provider;
  if (typeof Program !== "undefined") window.anchor.Program = Program;
  if (typeof utils !== "undefined") window.anchor.utils = utils;
  console.log("[SanctOS] 🧩 AnchorProvider + Program exported globally");
}
